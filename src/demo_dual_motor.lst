00000                 | 
00000                 | #line 1 "/home/kevin/Code/Kevinbot/KevinbotV3-HW-Core/P2-BLDC-Motor-Control/src/demo_dual_motor.p2asm"
00000                 | con
00000                 | 	_clkfreq = 270000000
00000                 | 	_clkmode = 17046267
00000                 | ' 
00000                 | '   CLK_FREQ = 270_000_000                                        ' system freq as a constant
00000                 | 	CLK_FREQ = 270000000
00000                 | '   _clkfreq = CLK_FREQ                                           ' set system clock
00000                 | ' 
00000                 | '   RX1      = 63  { I }                                          ' programming / debug
00000                 | 	RX1 = 63
00000                 | '   TX1      = 62  { O }
00000                 | 	TX1 = 62
00000                 | ' 
00000                 | '   SF_CS    = 61  { O }                                          ' serial flash
00000                 | 	SF_CS = 61
00000                 | '   SF_SCK   = 60  { O }
00000                 | 	SF_SCK = 60
00000                 | '   SF_SDO   = 59  { O }
00000                 | 	SF_SDO = 59
00000                 | '   SF_SDI   = 58  { I }
00000                 | 	SF_SDI = 58
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 270000000
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $1041afb
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 EA 06 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 04 90 5D |  if_ne	jmp	#spininit
0040c 002 70 F1 03 F6 | 	mov	ptra, objptr
00410 003 28 D6 67 FD | 	setq	#491
00414 004 61 01 6C FC | 	wrlong	#0, ptra++
00418 005 14 EC 0F FB | 	rdlong	pa, #20 wz
0041c 006 E4 03 90 5D |  if_ne	jmp	#skip_clock_set_
00420 007 00 00 64 FD | 	hubset	#0
00424 008 0D 82 80 FF 
00428 009 00 F0 65 FD | 	hubset	##17046264
0042c 00a 86 01 80 FF 
00430 00b 1F 80 66 FD | 	waitx	##200000
00434 00c 0D 82 00 FF 
00438 00d FB EC 07 F6 | 	mov	pa, ##17046267
0043c 00e 00 EC 63 FD | 	hubset	pa
00440 00f 18 EC 67 FC | 	wrlong	pa, #24
00444 010 EF 0B 88 FF 
00448 011 14 00 6F FC | 	wrlong	##270000000, #20
0044c 012 B4 03 90 FD | 	jmp	#skip_clock_set_
00450 013 00 00 00 00 
      ...             
007fc 0fe 00 00 00 00 
00800 0ff 00 00 00 00 | 	orgf	256
00804 100             | skip_clock_set_
00804 100 E4 09 A0 FD | 	call	#_main
00808 101             | cogexit
00808 101 38 01 80 FF 
0080c 102 1F 00 66 FD | 	waitx	##160000
00810 103 01 F6 62 FD | 	cogid	arg01
00814 104 03 F6 62 FD | 	cogstop	arg01
00818 105             | spininit
00818 105 61 E1 06 FB | 	rdlong	objptr, ptra++
0081c 106 61 EB 06 FB | 	rdlong	result1, ptra++
00820 107 28 06 64 FD | 	setq	#3
00824 108 00 F7 06 FB | 	rdlong	arg01, ptra
00828 109 04 F0 87 F1 | 	sub	ptra, #4
0082c 10a 2D EA 62 FD | 	call	result1
00830 10b D4 FF 9F FD | 	jmp	#cogexit
00834 10c             | FCACHE_LOAD_
00834 10c F9 2D 02 F6 |     mov	fcache_tmpb_,ptrb
00838 10d 2B F2 63 FD |     pop	ptrb
0083c 10e 15 ED 8B F9 |     altd	pa,ret_instr_
00840 10f 15 01 00 F6 |     mov	 0-0, ret_instr_
00844 110 28 EC 63 FD |     setq	pa
00848 111 E1 01 04 FB |     rdlong	$0, ptrb++
0084c 112 2A F2 63 FD |     push	ptrb
00850 113 16 F3 03 F6 |     mov ptrb,fcache_tmpb_
00854 114 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00858 115             | ret_instr_
00858 115 00 FE 07 02 |     _ret_ cmp inb,#0
0085c 116             | fcache_tmpb_
0085c 116 00 00 00 00 |     long 0
00860 117             | fcache_load_ptr_
00860 117 0C 01 00 00 |     long FCACHE_LOAD_
00864 118             | builtin_bytefill_
00864 118 01 FA 56 F0 |         shr	arg03, #1 wc
00868 119 7B F9 42 CC |  if_c   wrbyte	arg02, arg01
0086c 11a 01 F6 06 C1 |  if_c   add	arg01, #1
00870 11b 00 F8 FE F9 |         movbyts	arg02, #0
00874 11c             | builtin_wordfill_
00874 11c 01 FA 56 F0 |         shr	arg03, #1 wc
00878 11d 7B F9 52 CC |  if_c   wrword	arg02, arg01
0087c 11e 02 F6 06 C1 |  if_c   add	arg01, #2
00880 11f 7C F9 2A F9 |         setword	arg02, arg02, #1
00884 120             | builtin_longfill_
00884 120 7B 01 88 FC |         wrfast	#0,arg01
00888 121 00 FA 0E F2 |         cmp	arg03, #0 wz
0088c 122 7D 03 D8 5C |  if_nz  rep	#1, arg03
00890 123 17 F8 62 5D |  if_nz  wflong	arg02
00894 124 2D 00 64 FD |         ret
00898 125             | COUNT_
00898 125 00 00 00 00 |     long 0
0089c 126             | RETADDR_
0089c 126 00 00 00 00 |     long 0
008a0 127             | fp
008a0 127 00 00 00 00 |     long 0
008a4 128             | pushregs_
008a4 128 2B EC 63 FD |     pop  pa
008a8 129 2B 4C 62 FD |     pop  RETADDR_
008ac 12a 03 4A 96 FB |     tjz  COUNT_, #pushregs_done_
008b0 12b FF 4B 8E F9 |     altd  COUNT_, #511
008b4 12c 28 00 64 FD |     setq #0-0
008b8 12d 61 01 67 FC |     wrlong local01, ptra++
008bc 12e             | pushregs_done_
008bc 12e 28 04 64 FD |     setq #2 ' push 3 registers starting at COUNT_
008c0 12f 61 4B 66 FC |     wrlong COUNT_, ptra++
008c4 130 F8 4F 02 F6 |     mov    fp, ptra
008c8 131 2C EC 63 FD |     jmp  pa
008cc 132             |  popregs_
008cc 132 2B EC 63 FD |     pop    pa
008d0 133 28 04 64 FD |     setq   #2
008d4 134 5F 4B 06 FB |     rdlong COUNT_, --ptra
008d8 135 02 4A 76 FB |     djf    COUNT_, #popregs__ret
008dc 136 28 4A 62 FD |     setq   COUNT_
008e0 137 5F 01 07 FB |     rdlong local01, --ptra
008e4 138             | popregs__ret
008e4 138 2A 4C 62 FD |     push   RETADDR_
008e8 139 2C EC 63 FD |     jmp    pa
008ec 13a             | 
008ec 13a             | divide_
008ec 13a 9C 39 5B F6 |        abs     muldivb_,muldivb_     wcz      'abs(y)
008f0 13b 6C DE 62 FD |        wrc     itmp2_                         'store sign of y
008f4 13c 9B 37 53 F6 |        abs     muldiva_,muldiva_     wc       'abs(x)
008f8 13d 9C 37 13 FD |        qdiv    muldiva_, muldivb_             'queue divide
008fc 13e 01 DE 66 C5 |  if_c  xor     itmp2_,#1                      'store sign of x
00900 13f 18 38 63 FD |        getqx   muldivb_                       'get quotient
00904 140 19 36 63 FD |        getqy   muldiva_                       'get remainder
00908 141 9B 37 83 F6 |        negc    muldiva_,muldiva_              'restore sign, remainder (sign of x)
0090c 142 00 DE 16 F4 |        testb   itmp2_,#0             wc       'restore sign, division result
00910 143 9C 39 83 06 |  _ret_ negc    muldivb_,muldivb_     
00914 144             | __pc long 0
00914 144 00 00 00 00 
00918 145             | __setjmp
00918 145 2B 88 62 FD |     pop __pc
0091c 146 00 EA 06 F6 |     mov result1, #0
00920 147 00 EC 06 F6 |     mov result2, #0
00924 148 7B D9 02 F6 |     mov abortchain, arg01
00928 149 7B 4F 62 FC |     wrlong fp, arg01
0092c 14a 04 F6 06 F1 |     add arg01, #4
00930 14b 7B F1 63 FC |     wrlong ptra, arg01
00934 14c 04 F6 06 F1 |     add arg01, #4
00938 14d 7B E1 62 FC |     wrlong objptr, arg01
0093c 14e 04 F6 06 F1 |     add arg01, #4
00940 14f 7B 89 62 FC |     wrlong __pc, arg01
00944 150 2C 88 62 FD |     jmp __pc
00948 151             | __unwind_pc long 0
00948 151 00 00 00 00 
0094c 152             | __unwind_stack
0094c 152 2B A2 62 FD |    pop  __unwind_pc
00950 153             | __unwind_loop
00950 153 7C F7 0A F2 |    cmp  arg01, arg02 wz
00954 154 10 00 90 AD |   if_z jmp #__unwind_stack_ret
00958 155 7B F1 03 F6 |    mov   ptra, arg01
0095c 156 6C FF BF FD |    call  #popregs_
00960 157 27 F7 02 F6 |    mov   arg01, fp
00964 158 E8 FF 9F FD |    jmp   #__unwind_loop
00968 159             | __unwind_stack_ret
00968 159 2C A2 62 FD |    jmp  __unwind_pc
0096c 15a             | __longjmp
0096c 15a 2B 88 62 FD |     pop __pc
00970 15b 00 F6 0E F2 |     cmp    arg01, #0 wz
00974 15c 30 00 90 AD |  if_z jmp #nocatch
00978 15d 7C EB 02 F6 |     mov result1, arg02
0097c 15e 01 EC 06 F6 |     mov result2, #1
00980 15f 7B F9 02 FB |     rdlong arg02, arg01
00984 160 04 F6 06 F1 |     add arg01, #4
00988 161 7B F1 03 FB |     rdlong ptra, arg01
0098c 162 04 F6 06 F1 |     add arg01, #4
00990 163 7B E1 02 FB |     rdlong objptr, arg01
00994 164 04 F6 06 F1 |     add arg01, #4
00998 165 7B 89 02 FB |     rdlong __pc, arg01
0099c 166 27 F7 02 F6 |     mov arg01, fp
009a0 167 A8 FF BF FD |     call #__unwind_stack
009a4 168             | __longjmp_ret
009a4 168 2C 88 62 FD |     jmp  __pc
009a8 169             | nocatch
009a8 169 00 FA 0E F2 |     cmp arg03, #0 wz
009ac 16a 58 FE 9F AD |  if_z jmp #cogexit
009b0 16b F0 FF 9F FD |     jmp #__longjmp_ret
009b4 16c             | 
009b4 16c             | abortchain
009b4 16c 00 00 00 00 | 	long	0
009b8 16d             | entryptr__
009b8 16d 04 04 00 00 | 	long	@entry
009bc 16e             | itmp1_
009bc 16e 00 00 00 00 | 	long	0
009c0 16f             | itmp2_
009c0 16f 00 00 00 00 | 	long	0
009c4 170             | objptr
009c4 170 E8 43 00 00 | 	long	@objmem
009c8 171             | ptr___system__dat__
009c8 171 C8 43 00 00 | 	long	@__system__dat_
009cc 172             | ptr__isp_bldc_motor_dat__
009cc 172 40 3A 00 00 | 	long	@_isp_bldc_motor_dat_
009d0 173             | ptr__isp_steering_2wheel_dat__
009d0 173 4C 39 00 00 | 	long	@_isp_steering_2wheel_dat_
009d4 174             | ptr__isp_steering_2wheel_taskPostionSense_
009d4 174 E4 13 00 00 | 	long	@_isp_steering_2wheel_taskPostionSense
009d8 175             | result1
009d8 175 00 00 00 00 | 	long	0
009dc 176             | result2
009dc 176 01 00 00 00 | 	long	1
009e0 177             | result3
009e0 177 02 00 00 00 | 	long	2
009e4 178             | COG_BSS_START
009e4 178             | 	fit	480
009e4                 | 	orgh
009e4                 | hubentry
009e4                 | 
009e4                 | ' 
009e4                 | ' PUB main() | basePinLt, basePinRt, voltage, motor, detectModeLt, detectModeRt
009e4                 | _main
009e4     07 4A 06 F6 | 	mov	COUNT_, #7
009e8     28 01 A0 FD | 	call	#pushregs_
009ec     36 02 64 FD | 	brk	#1
009f0                 | ' 
009f0                 | '     ' validate user settings/choicess
009f0                 | '     '  do NOT start motor unless all are legit!
009f0                 | '     basePinLt := wheels.validBasePinForChoice(user.LEFT_MOTOR_BASE)
009f0     00 F6 06 F6 | 	mov	arg01, #0
009f4                 | ' '' VALIDATE users' base-pin choice returns legalBasePin or INVALID_PIN_BASE
009f4                 | '     legalBasePin := ltWheel.validBasePinForChoice(userBasePin)
009f4     84 E1 06 F1 | 	add	objptr, #388
009f8                 | ' '' VALIDATE users' base-pin choice returns legalBasePin or INVALID_PIN_BASE
009f8                 | '     legalBasePin := validatePinBase(userBasePin)
009f8     EC 13 B0 FD | 	call	#_isp_bldc_motor_validatePinBase
009fc     75 01 00 F6 | 	mov	0-0, result1
00a00     36 5E 64 FD | 	brk	#47
00a04     75 01 03 F6 | 	mov	local01, result1
00a08                 | '     basePinRt := wheels.validBasePinForChoice(user.RIGHT_MOTOR_BASE)
00a08     10 F6 06 F6 | 	mov	arg01, #16
00a0c                 | ' '' VALIDATE users' base-pin choice returns legalBasePin or INVALID_PIN_BASE
00a0c                 | '     legalBasePin := ltWheel.validBasePinForChoice(userBasePin)
00a0c                 | ' '' VALIDATE users' base-pin choice returns legalBasePin or INVALID_PIN_BASE
00a0c                 | '     legalBasePin := validatePinBase(userBasePin)
00a0c     D8 13 B0 FD | 	call	#_isp_bldc_motor_validatePinBase
00a10     75 01 00 F6 | 	mov	0-0, result1
00a14     36 5E 64 FD | 	brk	#47
00a18     75 03 03 F6 | 	mov	local02, result1
00a1c                 | '     detectModeLt := wheels.validDetectModeForChoice(user.LEFT_BOARD_TYPE)
00a1c     20 F6 06 F6 | 	mov	arg01, #32
00a20                 | ' '' VALIDATE users' detection mode choice returns legalMode or INVALID_DET_MODE
00a20                 | '     legalMode := ltWheel.validDetectModeForChoice(userDetMode)
00a20     B4 1B B0 FD | 	call	#_isp_bldc_motor_validDetectModeForChoice
00a24     75 05 03 F6 | 	mov	local03, result1
00a28                 | '     detectModeRt := wheels.validDetectModeForChoice(user.RIGHT_BOARD_TYPE)
00a28     20 F6 06 F6 | 	mov	arg01, #32
00a2c                 | ' '' VALIDATE users' detection mode choice returns legalMode or INVALID_DET_MODE
00a2c                 | '     legalMode := ltWheel.validDetectModeForChoice(userDetMode)
00a2c     A8 1B B0 FD | 	call	#_isp_bldc_motor_validDetectModeForChoice
00a30     75 07 03 F6 | 	mov	local04, result1
00a34                 | '     voltage := wheels.validVoltageForChoice(user.DRIVE_VOLTAGE)
00a34     06 F6 06 F6 | 	mov	arg01, #6
00a38                 | ' '' VALIDATE users' voltage choice returns legalVoltage or INVALID_VOLTAGE
00a38                 | '     legalVoltage := ltWheel.validVoltageForChoice(userVoltage)
00a38     58 1B B0 FD | 	call	#_isp_bldc_motor_validVoltageForChoice
00a3c     75 09 03 F6 | 	mov	local05, result1
00a40                 | '     motor := wheels.validMotorForChoice(user.MOTOR_TYPE)
00a40     00 F6 06 F6 | 	mov	arg01, #0
00a44                 | ' '' VALIDATE users' motor choice returns legalMotor or INVALID_MOTOR
00a44                 | '     legalMotor := ltWheel.validMotorForChoice(userMotor)
00a44                 | ' '' VALIDATE users' motor choice returns legalMotor or INVALID_MOTOR
00a44                 | '     legalMotor := userMotor
00a44     00 0A 07 F6 | 	mov	local06, #0
00a48                 | '     if lookdown(userMotor: MOTR_6_5_INCH, MOTR_DOCO_4KRPM) == 0
00a48     72 FB 02 F6 | 	mov	arg03, ptr__isp_bldc_motor_dat__
00a4c     03 00 00 FF 
00a50     EC FB 06 F1 | 	add	arg03, ##2028
00a54     01 F8 06 F6 | 	mov	arg02, #1
00a58     02 FC 06 F6 | 	mov	arg04, #2
00a5c     04 27 B0 FD | 	call	#__system___lookdown
00a60     00 EA 0E F2 | 	cmp	result1, #0 wz
00a64                 | '         legalMotor := INVALID_MOTOR
00a64     01 0A 67 A6 |  if_e	neg	local06, #1
00a68     85 01 00 F6 | 	mov	0-0, local06
00a6c     36 62 64 FD | 	brk	#49
00a70     85 EB 02 F6 | 	mov	result1, local06
00a74     84 E1 86 F1 | 	sub	objptr, #388
00a78                 | ' 
00a78                 | '     if basePinLt <> wheels.INVALID_PIN_BASE and basePinRt <> wheels.INVALID_PIN_BASE and voltage <> wheels.INVALID_VOLTAGE and motor <> wheels.INVALID_MOTOR and detectModeLt <> wheels.INVALID_DET_MODE and detectModeRt <> wheels.INVALID_DET_MODE
00a78     FF FF 7F FF 
00a7c     FF 01 0F F2 | 	cmp	local01, ##-1 wz
00a80     FF FF 7F 5F 
00a84     FF 03 0F 52 |  if_ne	cmp	local02, ##-1 wz
00a88     FF FF 7F 5F 
00a8c     FF 09 0F 52 |  if_ne	cmp	local05, ##-1 wz
00a90     FF FF 7F 5F 
00a94     FF EB 0E 52 |  if_ne	cmp	result1, ##-1 wz
00a98     FF FF 7F 5F 
00a9c     FF 05 0F 52 |  if_ne	cmp	local03, ##-1 wz
00aa0     FF FF 7F 5F 
00aa4     FF 07 0F 52 |  if_ne	cmp	local04, ##-1 wz
00aa8     2C 03 90 AD |  if_e	jmp	#LR__0005
00aac     14 38 07 FB | 	rdlong	muldivb_, #20
00ab0     9C 39 53 F6 | 	abs	muldivb_, muldivb_ wc
00ab4     01 00 00 FF 
00ab8     E8 39 17 FD | 	qdiv	muldivb_, ##1000
00abc                 | '         ' start our dual motor driver
00abc                 | ' 
00abc                 | '         ' start our motor drivers (left and right)
00abc                 | '         wheels.start(basePinLt, basePinRt, voltage, detectModeLt, detectModeRt)
00abc     80 F7 02 F6 | 	mov	arg01, local01
00ac0     18 38 63 FD | 	getqx	muldivb_
00ac4     9C 39 83 F6 | 	negc	muldivb_, muldivb_
00ac8     70 39 63 FC | 	wrlong	muldivb_, objptr
00acc     14 36 07 FB | 	rdlong	muldiva_, #20
00ad0     9B 37 53 F6 | 	abs	muldiva_, muldiva_ wc
00ad4     A1 07 00 FF 
00ad8     40 36 17 FD | 	qdiv	muldiva_, ##1000000
00adc                 | ' '' Start our drive cogs connected to our left and right motor control pin-sets
00adc                 | '     ticks1ms   := (clkfreq / 1_000)
00adc     18 36 63 FD | 	getqx	muldiva_
00ae0     7D 38 07 FD | 	qmul	muldivb_, #125
00ae4     9B 39 83 F6 | 	negc	muldivb_, muldiva_
00ae8                 | '     ticks1us   := (clkfreq / 1_000_000)
00ae8     04 E0 06 F1 | 	add	objptr, #4
00aec     70 39 63 FC | 	wrlong	muldivb_, objptr
00af0                 | '     ticks125ms := ticks1ms * 125
00af0     04 E0 06 F1 | 	add	objptr, #4
00af4                 | ' 
00af4                 | '     ' iff HDMI is needed, then we need this!
00af4                 | '     'if clkfreq <> 270_000_000
00af4                 | '     '    debug("!! ERROR bad CLOCK value")
00af4                 | '     '    repeat ' halt here
00af4                 | ' 
00af4                 | '     ltcog := ltWheel.startEx(leftBasePin, driveVoltage, leftDetectMode, true)
00af4     84 F9 02 F6 | 	mov	arg02, local05
00af8     82 FB 02 F6 | 	mov	arg03, local03
00afc     01 FC 66 F6 | 	neg	arg04, #1
00b00     18 38 63 FD | 	getqx	muldivb_
00b04     70 39 63 FC | 	wrlong	muldivb_, objptr
00b08     7C E1 06 F1 | 	add	objptr, #380
00b0c     78 11 B0 FD | 	call	#_isp_bldc_motor_startEx
00b10     75 05 03 F6 | 	mov	local03, result1
00b14                 | '     ltWheel.testSetMotorId(@"ltMot")
00b14     1C 00 00 FF 
00b18     1C F9 06 F6 | 	mov	arg02, ##@LR__0450
00b1c     70 F7 02 F6 | 	mov	arg01, objptr
00b20     50 F6 06 F1 | 	add	arg01, #80
00b24                 | ' '' TESTING USE: save name used in debug messages
00b24                 | '     strcopy(@motorId, pIdStr, MOTOR_ID_STRLEN)
00b24     0A FA 06 F6 | 	mov	arg03, #10
00b28     78 26 B0 FD | 	call	#__system____builtin_strncpy
00b2c                 | '     rtcog := rtWheel.startEx(rightBasePin, driveVoltage, rightDetectMode, true)
00b2c     81 F7 02 F6 | 	mov	arg01, local02
00b30     84 F9 02 F6 | 	mov	arg02, local05
00b34     83 FB 02 F6 | 	mov	arg03, local04
00b38     01 FC 66 F6 | 	neg	arg04, #1
00b3c     01 00 00 FF 
00b40     14 E1 06 F1 | 	add	objptr, ##788
00b44     40 11 B0 FD | 	call	#_isp_bldc_motor_startEx
00b48     75 09 03 F6 | 	mov	local05, result1
00b4c                 | '     rtWheel.testSetMotorId(@"rtMot")
00b4c     1C 00 00 FF 
00b50     22 F9 06 F6 | 	mov	arg02, ##@LR__0451
00b54     70 F7 02 F6 | 	mov	arg01, objptr
00b58     50 F6 06 F1 | 	add	arg01, #80
00b5c                 | ' '' TESTING USE: save name used in debug messages
00b5c                 | '     strcopy(@motorId, pIdStr, MOTOR_ID_STRLEN)
00b5c     0A FA 06 F6 | 	mov	arg03, #10
00b60     40 26 B0 FD | 	call	#__system____builtin_strncpy
00b64                 | '     rtWheel.forwardIsReverse()
00b64                 | ' '' Call when we have two motors and one of them needs to be reversed
00b64                 | '     motorIsReversed := TRUE
00b64     38 E0 06 F1 | 	add	objptr, #56
00b68     FF FF FF FF 
00b6c     70 FF 6B FC | 	wrlong	##-1, objptr
00b70     82 FD 02 F6 | 	mov	arg04, local03
00b74     01 FC 86 F1 | 	sub	arg04, #1
00b78     7E FD C2 F9 | 	decod	arg04, arg04
00b7c     84 FB 02 F6 | 	mov	arg03, local05
00b80     01 FA 86 F1 | 	sub	arg03, #1
00b84     7D FB C2 F9 | 	decod	arg03, arg03
00b88     7D FD 42 F5 | 	or	arg04, arg03
00b8c                 | '     cogmask := (1<<(ltcog-1))|(1<<(rtcog-1))
00b8c     01 00 00 FF 
00b90     98 E1 86 F1 | 	sub	objptr, ##920
00b94     70 FD 62 FC | 	wrlong	arg04, objptr
00b98     38 E1 86 F1 | 	sub	objptr, #312
00b9c                 | '     waitms(100)
00b9c     64 F6 06 F6 | 	mov	arg01, #100
00ba0     50 26 B0 FD | 	call	#__system___waitms
00ba4     01 04 87 F1 | 	sub	local03, #1
00ba8     82 01 00 F6 | 	mov	0-0, local03
00bac     01 08 87 F1 | 	sub	local05, #1
00bb0     84 03 00 F6 | 	mov	1-0, local05
00bb4     36 1A 64 FD | 	brk	#13
00bb8                 | '     cogatn(cogmask)                                     ' sync the 2 motor cogs
00bb8     38 E1 06 F1 | 	add	objptr, #312
00bbc     70 F7 02 FB | 	rdlong	arg01, objptr
00bc0     3F F6 62 FD | 	cogatn	arg01
00bc4                 | ' 
00bc4                 | '     _, ticsPerRotation := ltWheel.hallTicInfoForMotor()
00bc4                 | ' '' Return numbers for user selected motor (for use by two-wheel-steering object!)
00bc4                 | '     if user.MOTOR_TYPE == user.MOTR_DOCO_4KRPM
00bc4                 | '         ' degrees = ticks * 4
00bc4                 | '         degreesPerTic := 4
00bc4                 | '         ' rotations = ticks / 90
00bc4                 | '         ticsPerRotation := 90
00bc4     5A 08 07 F6 | 	mov	local05, #90
00bc8                 | '     if user.WHEEL_DIA_IN_INCH <> 0                      ' use wheel diameter independent of motor type
00bc8                 | '         circInMM_x10 := distConv.circInMMforDiaInInchFloat(user.WHEEL_DIA_IN_INCH) * 10
00bc8     00 68 20 FF 
00bcc     00 F6 06 F6 | 	mov	arg01, ##1087373312
00bd0     03 00 00 FF 
00bd4     74 E0 06 F1 | 	add	objptr, ##1652
00bd8     CC 23 B0 FD | 	call	#_isp_dist_utils_circInMMforDiaInInchFloat
00bdc     75 07 03 F6 | 	mov	local04, result1
00be0     83 37 03 F6 | 	mov	muldiva_, local04
00be4     02 36 67 F0 | 	shl	muldiva_, #2
00be8     83 37 03 F1 | 	add	muldiva_, local04
00bec     01 36 67 F0 | 	shl	muldiva_, #1
00bf0     03 00 00 FF 
00bf4     98 E0 86 F1 | 	sub	objptr, ##1688
00bf8     70 37 63 FC | 	wrlong	muldiva_, objptr
00bfc     14 E1 86 F1 | 	sub	objptr, #276
00c00     84 39 03 F6 | 	mov	muldivb_, local05
00c04     3A 01 A0 FD | 	call	#divide_
00c08                 | '         tickInMM_x10 := circInMM_x10 / ticsPerRotation
00c08     18 E1 06 F1 | 	add	objptr, #280
00c0c     70 39 63 FC | 	wrlong	muldivb_, objptr
00c10                 | ' 
00c10                 | '     ' init user tracking vars
00c10                 | '     motorStopHallTicks := 0
00c10     04 E0 06 F1 | 	add	objptr, #4
00c14     70 01 68 FC | 	wrlong	#0, objptr
00c18                 | '     motorStopMSecs := 0
00c18     04 E0 06 F1 | 	add	objptr, #4
00c1c     70 01 68 FC | 	wrlong	#0, objptr
00c20                 | '     rqstPower := 0
00c20     04 E0 06 F1 | 	add	objptr, #4
00c24     70 01 68 FC | 	wrlong	#0, objptr
00c28                 | '     rqstLtPower := 0
00c28     08 E0 06 F1 | 	add	objptr, #8
00c2c     70 01 68 FC | 	wrlong	#0, objptr
00c30                 | '     rqstRtPower := 0
00c30     04 E0 06 F1 | 	add	objptr, #4
00c34     70 01 68 FC | 	wrlong	#0, objptr
00c38                 | '     rqstDirection := 0
00c38     08 E0 86 F1 | 	sub	objptr, #8
00c3c     70 01 68 FC | 	wrlong	#0, objptr
00c40                 | '     userCutoff := FALSE
00c40     0C E0 06 F1 | 	add	objptr, #12
00c44     70 01 68 FC | 	wrlong	#0, objptr
00c48                 | '     notUsed := 0
00c48     08 E0 06 F1 | 	add	objptr, #8
00c4c     70 01 68 FC | 	wrlong	#0, objptr
00c50     3C E1 86 F1 | 	sub	objptr, #316
00c54                 | ' 
00c54                 | '     ok := senseCog := cogspin(NEWCOG, taskPostionSense(), @taskStack) + 1
00c54     70 09 03 F6 | 	mov	local05, objptr
00c58     10 E0 06 F1 | 	add	objptr, #16
00c5c     70 FB 02 F6 | 	mov	arg03, objptr
00c60     7D 09 63 FC | 	wrlong	local05, arg03
00c64     04 FA 06 F1 | 	add	arg03, #4
00c68     7D E9 62 FC | 	wrlong	ptr__isp_steering_2wheel_taskPostionSense_, arg03
00c6c     6D F9 02 F6 | 	mov	arg02, entryptr__
00c70     10 EA 06 F6 | 	mov	result1, #16
00c74     28 E0 62 FD | 	setq	objptr
00c78     7C EB F2 FC | 	coginit	result1, arg02 wc
00c7c     01 EA 66 C6 |  if_b	neg	result1, #1
00c80     01 EA 06 F1 | 	add	result1, #1
00c84     75 0D 0B F6 | 	mov	local07, result1 wz
00c88     04 E0 86 F1 | 	sub	objptr, #4
00c8c     70 0D 63 FC | 	wrlong	local07, objptr
00c90                 | '     if senseCog == 0    ' did fail?
00c90     0C E0 86 F1 | 	sub	objptr, #12
00c94     04 00 90 5D |  if_ne	jmp	#LR__0001
00c98     36 1C 64 FD | 	brk	#14
00c9c                 | LR__0001
00c9c                 | ' 
00c9c                 | '         ' just don't draw current at stop
00c9c                 | '         wheels.holdAtStop(false)
00c9c                 | ' '' Informs the motor drivers to actively hold position (bEnable=true) or coast (bEnable=false) at end of motion
00c9c                 | '     ltWheel.holdAtStop(bEnable)
00c9c                 | ' '' Informs the motor control cog to actively hold position (bEnable=true) or coast (bEnable=false) at end of motion
00c9c                 | '     stop_mode := (bEnable) ? SM_BRAKE : SM_FLOAT
00c9c     02 00 00 FF 
00ca0     7F E0 06 F1 | 	add	objptr, ##1151
00ca4     70 03 68 FC | 	wrlong	#1, objptr
00ca8                 | '     rtWheel.holdAtStop(bEnable)
00ca8                 | ' '' Informs the motor control cog to actively hold position (bEnable=true) or coast (bEnable=false) at end of motion
00ca8                 | '     stop_mode := (bEnable) ? SM_BRAKE : SM_FLOAT
00ca8     01 00 00 FF 
00cac     14 E1 06 F1 | 	add	objptr, ##788
00cb0     70 03 68 FC | 	wrlong	#1, objptr
00cb4     03 00 00 FF 
00cb8     93 E1 86 F1 | 	sub	objptr, ##1939
00cbc                 | '         'wheels.setMaxSpeed(100)  ' override 75% with 100%
00cbc                 | ' 
00cbc                 | '         ' now drive!
00cbc                 | '         waitUntilMotorReady()
00cbc                 | '     if wheels.isReady() == false
00cbc     18 06 B0 FD | 	call	#_isp_steering_2wheel_isReady
00cc0     00 EA 0E F2 | 	cmp	result1, #0 wz
00cc4     1C 00 90 5D |  if_ne	jmp	#LR__0004
00cc8     36 10 64 FD | 	brk	#8
00ccc                 | '         repeat
00ccc                 | LR__0002
00ccc                 | '             if wheels.isReady()
00ccc     08 06 B0 FD | 	call	#_isp_steering_2wheel_isReady
00cd0     00 EA 0E F2 | 	cmp	result1, #0 wz
00cd4                 | '                 quit
00cd4     0C 00 90 5D |  if_ne	jmp	#LR__0003
00cd8                 | '             else
00cd8                 | '                 waitms(2)
00cd8     02 F6 06 F6 | 	mov	arg01, #2
00cdc     14 25 B0 FD | 	call	#__system___waitms
00ce0     E8 FF 9F FD | 	jmp	#LR__0002
00ce4                 | LR__0003
00ce4                 | LR__0004
00ce4     36 12 64 FD | 	brk	#9
00ce8     36 04 64 FD | 	brk	#2
00cec                 | '         wheels.driveForDistance(1, 1, wheels.DDU_FT)
00cec                 | ' '' Control the forward direction or rate of turn of your robot using the {leftDistance} and {rightDistance} inputs.
00cec                 | ' '' Turn both motors on then turn them off again when either reaches the specified distance {leftDistance} or
00cec                 | ' ''  {rightDistance}, where {*distance} is in {distanceUnits} [DDU_IN, DDU_FT, DDU_CM, or DDU_M].
00cec                 | ' '' AFFECTED BY: setAcceleration(), setMaxSpeedForDistance(), holdAtStop()
00cec                 | '     shorterDistance := leftDistance < rightDistance ? leftDistance : rightDistance
00cec                 | '     stopAfterDistance(shorterDistance, eDistanceUnits)
00cec     01 F6 06 F6 | 	mov	arg01, #1
00cf0     04 F8 06 F6 | 	mov	arg02, #4
00cf4     F4 01 B0 FD | 	call	#_isp_steering_2wheel_stopAfterDistance
00cf8                 | '     maxLtSpeed := ltWheel.getMaxSpeedForDistance()
00cf8                 | ' '' Returns the last specified {maxSpeedForDistance}
00cf8                 | '     nSpeed4dist := maxSpeed4dist  ' return last specified user value
00cf8     AC E1 06 F1 | 	add	objptr, #428
00cfc     70 F7 02 FB | 	rdlong	arg01, objptr
00d00                 | '     maxRtSpeed := rtWheel.getMaxSpeedForDistance()
00d00                 | ' '' Returns the last specified {maxSpeedForDistance}
00d00                 | '     nSpeed4dist := maxSpeed4dist  ' return last specified user value
00d00     01 00 00 FF 
00d04     14 E1 06 F1 | 	add	objptr, ##788
00d08     70 F9 02 FB | 	rdlong	arg02, objptr
00d0c     02 00 00 FF 
00d10     C0 E0 86 F1 | 	sub	objptr, ##1216
00d14                 | '     driveAtPower(maxLtSpeed, maxRtSpeed)
00d14     54 01 B0 FD | 	call	#_isp_steering_2wheel_driveAtPower
00d18                 | '         waitUntilMotorDone()
00d18     D0 00 B0 FD | 	call	#_waitUntilMotorDone
00d1c     36 06 64 FD | 	brk	#3
00d20                 | '         wheels.driveDirection(80, -25)
00d20     50 F6 06 F6 | 	mov	arg01, #80
00d24     19 F8 66 F6 | 	neg	arg02, #25
00d28     18 01 B0 FD | 	call	#_isp_steering_2wheel_driveDirection
00d2c                 | '         wheels.stopAfterTime(15, wheels.DTU_SEC)      ' hold at speed for 15 Sec
00d2c     0F F6 06 F6 | 	mov	arg01, #15
00d30     02 F8 06 F6 | 	mov	arg02, #2
00d34     14 04 B0 FD | 	call	#_isp_steering_2wheel_stopAfterTime
00d38                 | ' 
00d38                 | '         waitUntilMotorDone()
00d38     B0 00 B0 FD | 	call	#_waitUntilMotorDone
00d3c                 | ' 
00d3c                 | '         wheels.driveDirection(80, 25)
00d3c     50 F6 06 F6 | 	mov	arg01, #80
00d40     19 F8 06 F6 | 	mov	arg02, #25
00d44     FC 00 B0 FD | 	call	#_isp_steering_2wheel_driveDirection
00d48                 | '         wheels.stopAfterTime(15, wheels.DTU_SEC)      ' hold at speed for 15 Sec
00d48     0F F6 06 F6 | 	mov	arg01, #15
00d4c     02 F8 06 F6 | 	mov	arg02, #2
00d50     F8 03 B0 FD | 	call	#_isp_steering_2wheel_stopAfterTime
00d54                 | ' 
00d54                 | '         waitUntilMotorDone()
00d54     94 00 B0 FD | 	call	#_waitUntilMotorDone
00d58     36 08 64 FD | 	brk	#4
00d5c                 | '         wheels.driveAtPower(100, 0)
00d5c     64 F6 06 F6 | 	mov	arg01, #100
00d60     00 F8 06 F6 | 	mov	arg02, #0
00d64     04 01 B0 FD | 	call	#_isp_steering_2wheel_driveAtPower
00d68                 | '         wheels.stopAfterTime(15, wheels.DTU_SEC)      ' hold at speed for 15 Sec
00d68     0F F6 06 F6 | 	mov	arg01, #15
00d6c     02 F8 06 F6 | 	mov	arg02, #2
00d70     D8 03 B0 FD | 	call	#_isp_steering_2wheel_stopAfterTime
00d74                 | ' 
00d74                 | '         waitUntilMotorDone()
00d74     74 00 B0 FD | 	call	#_waitUntilMotorDone
00d78     36 0A 64 FD | 	brk	#5
00d7c                 | '         wheels.driveAtPower(0, 100)
00d7c     00 F6 06 F6 | 	mov	arg01, #0
00d80     64 F8 06 F6 | 	mov	arg02, #100
00d84     E4 00 B0 FD | 	call	#_isp_steering_2wheel_driveAtPower
00d88                 | '         wheels.stopAfterTime(15, wheels.DTU_SEC)      ' hold at speed for 15 Sec
00d88     0F F6 06 F6 | 	mov	arg01, #15
00d8c     02 F8 06 F6 | 	mov	arg02, #2
00d90     B8 03 B0 FD | 	call	#_isp_steering_2wheel_stopAfterTime
00d94                 | ' 
00d94                 | '         waitUntilMotorDone()
00d94     54 00 B0 FD | 	call	#_waitUntilMotorDone
00d98                 | ' '}
00d98                 | '         ' turn off our motor drivers
00d98                 | '         wheels.stop()
00d98                 | ' '' Stop our left/right drive and Sense cogs and release allocated pins
00d98                 | '     if senseCog     ' stop motor reads
00d98     0C E0 06 F1 | 	add	objptr, #12
00d9c     70 F7 0A FB | 	rdlong	arg01, objptr wz
00da0     0C E0 86 F1 | 	sub	objptr, #12
00da4     01 F6 86 51 |  if_ne	sub	arg01, #1
00da8                 | '         cogstop(senseCog - 1)
00da8     03 F6 62 5D |  if_ne	cogstop	arg01
00dac                 | '         senseCog := 0
00dac     0C E0 06 51 |  if_ne	add	objptr, #12
00db0     70 01 68 5C |  if_ne	wrlong	#0, objptr
00db4     0C E0 86 51 |  if_ne	sub	objptr, #12
00db8                 | ' 
00db8                 | '     ltWheel.stop()
00db8     84 E1 06 F1 | 	add	objptr, #388
00dbc     7C 0F B0 FD | 	call	#_isp_bldc_motor_stop
00dc0                 | '     rtWheel.stop()
00dc0     01 00 00 FF 
00dc4     14 E1 06 F1 | 	add	objptr, ##788
00dc8     70 0F B0 FD | 	call	#_isp_bldc_motor_stop
00dcc     02 00 00 FF 
00dd0     98 E0 86 F1 | 	sub	objptr, ##1176
00dd4     04 00 90 FD | 	jmp	#LR__0006
00dd8                 | LR__0005
00dd8                 | '     else
00dd8     36 0C 64 FD | 	brk	#6
00ddc                 | LR__0006
00ddc     36 0E 64 FD | 	brk	#7
00de0     27 F1 03 F6 | 	mov	ptra, fp
00de4     32 01 A0 FD | 	call	#popregs_
00de8                 | _main_ret
00de8     2D 00 64 FD | 	ret
00dec                 | 
00dec                 | ' 
00dec                 | ' 
00dec                 | ' PRI waitUntilMotorDone()
00dec                 | _waitUntilMotorDone
00dec                 | '     if wheels.isStarting() == false
00dec     98 05 B0 FD | 	call	#_isp_steering_2wheel_isStarting
00df0     00 EA 0E F2 | 	cmp	result1, #0 wz
00df4     1C 00 90 5D |  if_ne	jmp	#LR__0012
00df8     36 14 64 FD | 	brk	#10
00dfc                 | '          repeat
00dfc                 | LR__0010
00dfc                 | '             if wheels.isStarting()
00dfc     88 05 B0 FD | 	call	#_isp_steering_2wheel_isStarting
00e00     00 EA 0E F2 | 	cmp	result1, #0 wz
00e04                 | '                 quit
00e04     0C 00 90 5D |  if_ne	jmp	#LR__0011
00e08                 | '             else
00e08                 | '                 waitms(2)
00e08     02 F6 06 F6 | 	mov	arg01, #2
00e0c     E4 23 B0 FD | 	call	#__system___waitms
00e10     E8 FF 9F FD | 	jmp	#LR__0010
00e14                 | LR__0011
00e14                 | LR__0012
00e14                 | ' 
00e14                 | '     if wheels.isStopped() == false
00e14     14 05 B0 FD | 	call	#_isp_steering_2wheel_isStopped
00e18     00 EA 0E F2 | 	cmp	result1, #0 wz
00e1c     1C 00 90 5D |  if_ne	jmp	#LR__0015
00e20     36 16 64 FD | 	brk	#11
00e24                 | '         repeat
00e24                 | LR__0013
00e24                 | '             if wheels.isStopped()
00e24     04 05 B0 FD | 	call	#_isp_steering_2wheel_isStopped
00e28     00 EA 0E F2 | 	cmp	result1, #0 wz
00e2c                 | '                 quit
00e2c     0C 00 90 5D |  if_ne	jmp	#LR__0014
00e30                 | '             else
00e30                 | '                 waitms(2)
00e30     02 F6 06 F6 | 	mov	arg01, #2
00e34     BC 23 B0 FD | 	call	#__system___waitms
00e38     E8 FF 9F FD | 	jmp	#LR__0013
00e3c                 | LR__0014
00e3c                 | LR__0015
00e3c     36 18 64 FD | 	brk	#12
00e40                 | _waitUntilMotorDone_ret
00e40     2D 00 64 FD | 	ret
00e44                 | 
00e44                 | ' 
00e44                 | ' PUB driveDirection(power, direction)
00e44                 | _isp_steering_2wheel_driveDirection
00e44                 | ' '' Control the speed and direction of your robot using the {power} and {direction} inputs.
00e44                 | ' '' Turns both motors on at {power, [(-100) to 100]} but adjusted by {direction, [(-100) to 100]}.
00e44                 | ' '' AFFECTED BY: setAcceleration(), setMaxSpeed(), holdAtStop()
00e44                 | '     rqstPower, rqstDirection := power, direction        ' calculate effective power based on direction
00e44     24 E1 06 F1 | 	add	objptr, #292
00e48     70 F7 62 FC | 	wrlong	arg01, objptr
00e4c     04 E0 06 F1 | 	add	objptr, #4
00e50     70 F9 62 FC | 	wrlong	arg02, objptr
00e54     28 E1 86 F1 | 	sub	objptr, #296
00e58                 | '     driveAtPower(calcPowerForDirection(power, direction))
00e58     0C 04 B0 FD | 	call	#_isp_steering_2wheel_calcPowerForDirection
00e5c     75 F7 02 F6 | 	mov	arg01, result1
00e60     76 F9 02 F6 | 	mov	arg02, result2
00e64     04 00 B0 FD | 	call	#_isp_steering_2wheel_driveAtPower
00e68                 | _isp_steering_2wheel_driveDirection_ret
00e68     2D 00 64 FD | 	ret
00e6c                 | 
00e6c                 | ' 
00e6c                 | ' PUB driveAtPower(leftPower, rightPower)
00e6c                 | _isp_steering_2wheel_driveAtPower
00e6c                 | ' '' Control the speed and direction of your robot using the {leftPower} and {rightPower} inputs.
00e6c                 | ' '' Turns left motor on at {leftPower} and right at {rightPower}. Where {*Power} are in the range [(-100) to 100].
00e6c                 | ' '' AFFECTED BY: setAcceleration(), setMaxSpeed(), holdAtStop()
00e6c                 | '     rqstLtPower, rqstRtPower := leftPower, rightPower
00e6c     2C E1 06 F1 | 	add	objptr, #300
00e70     70 F7 62 FC | 	wrlong	arg01, objptr
00e74     04 E0 06 F1 | 	add	objptr, #4
00e78     70 F9 62 FC | 	wrlong	arg02, objptr
00e7c                 | ' 
00e7c                 | '     ltWheel.driveAtPowerEx(rqstLtPower, true)
00e7c     01 F8 66 F6 | 	neg	arg02, #1
00e80     54 E0 06 F1 | 	add	objptr, #84
00e84     B0 14 B0 FD | 	call	#_isp_bldc_motor_driveAtPowerEx
00e88                 | '     rtWheel.driveAtPowerEx(rqstRtPower, true)
00e88     54 E0 86 F1 | 	sub	objptr, #84
00e8c     70 F7 02 FB | 	rdlong	arg01, objptr
00e90     01 F8 66 F6 | 	neg	arg02, #1
00e94     01 00 00 FF 
00e98     68 E1 06 F1 | 	add	objptr, ##872
00e9c     98 14 B0 FD | 	call	#_isp_bldc_motor_driveAtPowerEx
00ea0                 | '     cogatn(cogmask)                                     ' sync the 2 motor cogs
00ea0     01 00 00 FF 
00ea4     60 E1 86 F1 | 	sub	objptr, ##864
00ea8     70 F7 02 FB | 	rdlong	arg01, objptr
00eac     3F F6 62 FD | 	cogatn	arg01
00eb0                 | '     ltWheel.SyncStatus()                                ' make sure both motors have taken value
00eb0                 | ' '' Wait until both motors are in sync (when configured for synchronization)
00eb0                 | '     repeat while targetIncre & $8000_0000
00eb0     01 00 00 FF 
00eb4     7F E0 06 F1 | 	add	objptr, ##639
00eb8                 | LR__0020
00eb8     70 F9 02 FB | 	rdlong	arg02, objptr
00ebc     1F F8 2E F4 | 	testbn	arg02, #31 wz
00ec0     F4 FF 9F 5D |  if_ne	jmp	#LR__0020
00ec4                 | '     rtWheel.SyncStatus()
00ec4                 | ' '' Wait until both motors are in sync (when configured for synchronization)
00ec4                 | '     repeat while targetIncre & $8000_0000
00ec4     01 00 00 FF 
00ec8     14 E1 06 F1 | 	add	objptr, ##788
00ecc                 | LR__0021
00ecc     70 F9 02 FB | 	rdlong	arg02, objptr
00ed0     1F F8 2E F4 | 	testbn	arg02, #31 wz
00ed4     F4 FF 9F 5D |  if_ne	jmp	#LR__0021
00ed8     01 00 00 FF 
00edc     33 E0 86 F1 | 	sub	objptr, ##563
00ee0     02 00 00 FF 
00ee4     98 E0 86 F1 | 	sub	objptr, ##1176
00ee8                 | _isp_steering_2wheel_driveAtPower_ret
00ee8     2D 00 64 FD | 	ret
00eec                 | 
00eec                 | ' 
00eec                 | ' 
00eec                 | ' '' Stops both motors, after either of the motors reaches {distance} specified in {distanceUnits} [DDU_IN or DDU_MM].
00eec                 | ' '' USE WITH: driveDirection(), drive()
00eec                 | ' PUB stopAfterDistance(nDistance, eDistanceUnits) | fValue
00eec                 | _isp_steering_2wheel_stopAfterDistance
00eec     04 4A 06 F6 | 	mov	COUNT_, #4
00ef0     28 01 A0 FD | 	call	#pushregs_
00ef4     7B 01 03 F6 | 	mov	local01, arg01
00ef8     7C 03 03 F6 | 	mov	local02, arg02
00efc                 | ' '' Stops the motors after one of them reaches {distance} specified in {distanceUnits} [DDU_MM, DDU_CM, DDU_IN, DDU_FT, DDU_M].
00efc                 | ' '' USE WITH:  driveAtPower()
00efc                 | ' '' Will ABORT if {distance} < 1
00efc                 | '     if nDistance < 1
00efc     01 00 57 F2 | 	cmps	local01, #1 wc
00f00     18 00 90 3D |  if_ae	jmp	#LR__0030
00f04     80 01 00 F6 | 	mov	0-0, local01
00f08     36 1E 64 FD | 	brk	#15
00f0c                 | '         ' FIXME: UNDONE should be more than ticks needed for spin-up/down ramps!!!
00f0c                 | '         abort
00f0c     6C F7 02 F6 | 	mov	arg01, abortchain
00f10     00 F8 06 F6 | 	mov	arg02, #0
00f14     00 FA 06 F6 | 	mov	arg03, #0
00f18     5A 01 A0 FD | 	call	#__longjmp
00f1c                 | LR__0030
00f1c                 | ' 
00f1c                 | '     ' if user configured wheel-diameter is 0.0 then tickInMM_x10 is 0
00f1c                 | '     ' if so, abort this method as we can't do this!
00f1c                 | '     if tickInMM_x10 == 0
00f1c     18 E1 06 F1 | 	add	objptr, #280
00f20     70 EB 0A FB | 	rdlong	result1, objptr wz
00f24     18 E1 86 F1 | 	sub	objptr, #280
00f28     14 00 90 5D |  if_ne	jmp	#LR__0031
00f2c     36 20 64 FD | 	brk	#16
00f30                 | '         abort
00f30     6C F7 02 F6 | 	mov	arg01, abortchain
00f34     00 F8 06 F6 | 	mov	arg02, #0
00f38     00 FA 06 F6 | 	mov	arg03, #0
00f3c     5A 01 A0 FD | 	call	#__longjmp
00f40                 | LR__0031
00f40                 | ' 
00f40                 | '     resetTracking()  ' clear tracking values to start counting again
00f40                 | ' '' Resets the position tracking values returned by getDistance() and getRotations()
00f40                 | ' ''  Effectively: use current position as home from now on
00f40                 | '     ltWheel.resetWindowAccumulators()
00f40     84 E1 06 F1 | 	add	objptr, #388
00f44     78 1B B0 FD | 	call	#_isp_bldc_motor_resetWindowAccumulators
00f48                 | '     rtWheel.resetWindowAccumulators()
00f48     01 00 00 FF 
00f4c     14 E1 06 F1 | 	add	objptr, ##788
00f50     6C 1B B0 FD | 	call	#_isp_bldc_motor_resetWindowAccumulators
00f54     02 00 00 FF 
00f58     98 E0 86 F1 | 	sub	objptr, ##1176
00f5c                 | ' 
00f5c                 | '     ' convert distance to ticks (will stop at ticks limit)
00f5c                 | '     ' Distance is translated to Hall ticks and compared with left and right motor hall ticks
00f5c                 | '     ' The motor ticks are from start but reset on fault or estop.
00f5c                 | '     ' So, need to getDistance and add required distance to it, to stop after a distance
00f5c                 | '     ' So, call getDistance, then driveAtPower to start moving and then stopAfterDistance with total distance to stop.
00f5c                 | '     ' If a fault occurs, will stop immedetely and hall ticks are reset on the faulting motor.
00f5c                 | '     ' getDistance returns each motor separately. So use largest return distance to calculate stopAfterDistance
00f5c                 | '     case eDistanceUnits
00f5c     81 05 03 F6 | 	mov	local03, local02
00f60     01 04 87 F1 | 	sub	local03, #1
00f64     05 04 27 F3 | 	fle	local03, #5
00f68     30 04 63 FD | 	jmprel	local03
00f6c                 | LR__0032
00f6c     14 00 90 FD | 	jmp	#LR__0033
00f70     40 00 90 FD | 	jmp	#LR__0034
00f74     7C 00 90 FD | 	jmp	#LR__0035
00f78     EC 00 90 FD | 	jmp	#LR__0036
00f7c     6C 01 90 FD | 	jmp	#LR__0037
00f80     A0 01 90 FD | 	jmp	#LR__0038
00f84                 | LR__0033
00f84                 | '         DDU_MM:
00f84                 | '             motorStopHallTicks := (nDistance * 10) / tickInMM_x10
00f84     80 37 03 F6 | 	mov	muldiva_, local01
00f88     02 36 67 F0 | 	shl	muldiva_, #2
00f8c     80 37 03 F1 | 	add	muldiva_, local01
00f90     01 36 67 F0 | 	shl	muldiva_, #1
00f94     18 E1 06 F1 | 	add	objptr, #280
00f98     70 39 03 FB | 	rdlong	muldivb_, objptr
00f9c     18 E1 86 F1 | 	sub	objptr, #280
00fa0     3A 01 A0 FD | 	call	#divide_
00fa4     1C E1 06 F1 | 	add	objptr, #284
00fa8     70 39 63 FC | 	wrlong	muldivb_, objptr
00fac     1C E1 86 F1 | 	sub	objptr, #284
00fb0     88 01 90 FD | 	jmp	#LR__0039
00fb4                 | LR__0034
00fb4                 | '         DDU_CM:
00fb4                 | '             motorStopHallTicks := (nDistance * 10 * 10) / tickInMM_x10
00fb4     80 05 03 F6 | 	mov	local03, local01
00fb8     02 04 67 F0 | 	shl	local03, #2
00fbc     80 05 03 F1 | 	add	local03, local01
00fc0     01 04 67 F0 | 	shl	local03, #1
00fc4     82 37 03 F6 | 	mov	muldiva_, local03
00fc8     02 36 67 F0 | 	shl	muldiva_, #2
00fcc     82 37 03 F1 | 	add	muldiva_, local03
00fd0     01 36 67 F0 | 	shl	muldiva_, #1
00fd4     18 E1 06 F1 | 	add	objptr, #280
00fd8     70 39 03 FB | 	rdlong	muldivb_, objptr
00fdc     18 E1 86 F1 | 	sub	objptr, #280
00fe0     3A 01 A0 FD | 	call	#divide_
00fe4     1C E1 06 F1 | 	add	objptr, #284
00fe8     70 39 63 FC | 	wrlong	muldivb_, objptr
00fec     1C E1 86 F1 | 	sub	objptr, #284
00ff0     48 01 90 FD | 	jmp	#LR__0039
00ff4                 | LR__0035
00ff4                 | '         DDU_IN:
00ff4                 | '             fValue := distConv.fIn2mm(nDistance)
00ff4     03 00 00 FF 
00ff8     AC E1 06 F1 | 	add	objptr, ##1964
00ffc                 | ' '' Convert distance in inch to mm
00ffc                 | '     ' RULE: One inch is equal to 25.4 mm
00ffc                 | '     fValue := float(nDistInInch) *. kMM_IN_INCH
00ffc     80 F7 52 F6 | 	abs	arg01, local01 wc
01000     1F 06 C7 C9 |  if_b	decod	local04, #31
01004     00 06 07 36 |  if_ae	mov	local04, #0
01008     54 22 B0 FD | 	call	#__system___float_fromuns
0100c     83 EB 62 F5 | 	xor	result1, local04
01010     75 F7 02 F6 | 	mov	arg01, result1
01014     99 E5 20 FF 
01018     33 F9 06 F6 | 	mov	arg02, ##1103835955
0101c     74 22 B0 FD | 	call	#__system___float_mul
01020                 | '     fDistInMM := fValue
01020     03 00 00 FF 
01024     AC E1 86 F1 | 	sub	objptr, ##1964
01028     75 F7 02 F6 | 	mov	arg01, result1
0102c                 | '             motorStopHallTicks := round(fValue *. 10.0) / tickInMM_x10
0102c     00 90 20 FF 
01030     00 F8 06 F6 | 	mov	arg02, ##1092616192
01034     5C 22 B0 FD | 	call	#__system___float_mul
01038     75 F7 02 F6 | 	mov	arg01, result1
0103c     01 F8 06 F6 | 	mov	arg02, #1
01040     90 26 B0 FD | 	call	#__system___float_tointeger
01044     75 37 03 F6 | 	mov	muldiva_, result1
01048     18 E1 06 F1 | 	add	objptr, #280
0104c     70 39 03 FB | 	rdlong	muldivb_, objptr
01050     18 E1 86 F1 | 	sub	objptr, #280
01054     3A 01 A0 FD | 	call	#divide_
01058     1C E1 06 F1 | 	add	objptr, #284
0105c     70 39 63 FC | 	wrlong	muldivb_, objptr
01060     1C E1 86 F1 | 	sub	objptr, #284
01064     D4 00 90 FD | 	jmp	#LR__0039
01068                 | LR__0036
01068                 | '         DDU_FT:
01068                 | '             fValue := distConv.fIn2mm(nDistance * 12)
01068     80 F7 02 F6 | 	mov	arg01, local01
0106c     01 F6 66 F0 | 	shl	arg01, #1
01070     80 F7 02 F1 | 	add	arg01, local01
01074     02 F6 66 F0 | 	shl	arg01, #2
01078     03 00 00 FF 
0107c     AC E1 06 F1 | 	add	objptr, ##1964
01080                 | ' '' Convert distance in inch to mm
01080                 | '     ' RULE: One inch is equal to 25.4 mm
01080                 | '     fValue := float(nDistInInch) *. kMM_IN_INCH
01080     7B F7 52 F6 | 	abs	arg01, arg01 wc
01084     1F 06 C7 C9 |  if_b	decod	local04, #31
01088     00 06 07 36 |  if_ae	mov	local04, #0
0108c     D0 21 B0 FD | 	call	#__system___float_fromuns
01090     83 EB 62 F5 | 	xor	result1, local04
01094     75 F7 02 F6 | 	mov	arg01, result1
01098     99 E5 20 FF 
0109c     33 F9 06 F6 | 	mov	arg02, ##1103835955
010a0     F0 21 B0 FD | 	call	#__system___float_mul
010a4                 | '     fDistInMM := fValue
010a4     03 00 00 FF 
010a8     AC E1 86 F1 | 	sub	objptr, ##1964
010ac     75 F7 02 F6 | 	mov	arg01, result1
010b0                 | '             motorStopHallTicks := round(fValue *. 10.0) / tickInMM_x10
010b0     00 90 20 FF 
010b4     00 F8 06 F6 | 	mov	arg02, ##1092616192
010b8     D8 21 B0 FD | 	call	#__system___float_mul
010bc     75 F7 02 F6 | 	mov	arg01, result1
010c0     01 F8 06 F6 | 	mov	arg02, #1
010c4     0C 26 B0 FD | 	call	#__system___float_tointeger
010c8     75 37 03 F6 | 	mov	muldiva_, result1
010cc     18 E1 06 F1 | 	add	objptr, #280
010d0     70 39 03 FB | 	rdlong	muldivb_, objptr
010d4     18 E1 86 F1 | 	sub	objptr, #280
010d8     3A 01 A0 FD | 	call	#divide_
010dc     1C E1 06 F1 | 	add	objptr, #284
010e0     70 39 63 FC | 	wrlong	muldivb_, objptr
010e4     1C E1 86 F1 | 	sub	objptr, #284
010e8     50 00 90 FD | 	jmp	#LR__0039
010ec                 | LR__0037
010ec     64 00 07 FD | 	qmul	local01, #100
010f0                 | '         DDU_M:
010f0                 | '             motorStopHallTicks := (nDistance * 100 * 10) / tickInMM_x10
010f0     18 E1 06 F1 | 	add	objptr, #280
010f4     70 39 03 FB | 	rdlong	muldivb_, objptr
010f8     18 E1 86 F1 | 	sub	objptr, #280
010fc     18 04 63 FD | 	getqx	local03
01100     82 37 03 F6 | 	mov	muldiva_, local03
01104     02 36 67 F0 | 	shl	muldiva_, #2
01108     82 37 03 F1 | 	add	muldiva_, local03
0110c     01 36 67 F0 | 	shl	muldiva_, #1
01110     3A 01 A0 FD | 	call	#divide_
01114     1C E1 06 F1 | 	add	objptr, #284
01118     70 39 63 FC | 	wrlong	muldivb_, objptr
0111c     1C E1 86 F1 | 	sub	objptr, #284
01120     18 00 90 FD | 	jmp	#LR__0039
01124                 | LR__0038
01124     81 01 00 F6 | 	mov	0-0, local02
01128     36 22 64 FD | 	brk	#17
0112c                 | '             abort
0112c     6C F7 02 F6 | 	mov	arg01, abortchain
01130     00 F8 06 F6 | 	mov	arg02, #0
01134     00 FA 06 F6 | 	mov	arg03, #0
01138     5A 01 A0 FD | 	call	#__longjmp
0113c                 | LR__0039
0113c     00 EA 06 F6 | 	mov	result1, #0
01140     27 F1 03 F6 | 	mov	ptra, fp
01144     32 01 A0 FD | 	call	#popregs_
01148                 | _isp_steering_2wheel_stopAfterDistance_ret
01148     2D 00 64 FD | 	ret
0114c                 | 
0114c                 | ' 
0114c                 | ' 
0114c                 | ' '' Stops both motors, after either of the motors reaches {distance} specified in {distanceUnits} [DDU_IN or DDU_MM].
0114c                 | ' '' USE WITH: driveDirection(), drive()
0114c                 | ' PUB stopAfterTime(nTime, eTimeUnits) | timeNow
0114c                 | _isp_steering_2wheel_stopAfterTime
0114c     04 4A 06 F6 | 	mov	COUNT_, #4
01150     28 01 A0 FD | 	call	#pushregs_
01154     7B 01 03 F6 | 	mov	local01, arg01
01158     7C 03 03 F6 | 	mov	local02, arg02
0115c                 | ' '' Stops the motors after {time} specified in {timeUnits} [DTU_MILLISEC or DTU_SEC] has elapsed.
0115c                 | ' '' USE WITH:  driveAtPower()
0115c                 | ' '' Will ABORT if {time} < 1
0115c                 | '     if nTime < 1
0115c     01 00 57 F2 | 	cmps	local01, #1 wc
01160     18 00 90 3D |  if_ae	jmp	#LR__0040
01164     80 01 00 F6 | 	mov	0-0, local01
01168     36 24 64 FD | 	brk	#18
0116c                 | '         ' FIXME: UNDONE should be more than time needed for spin-up/down ramps!!!
0116c                 | '         abort
0116c     6C F7 02 F6 | 	mov	arg01, abortchain
01170     00 F8 06 F6 | 	mov	arg02, #0
01174     00 FA 06 F6 | 	mov	arg03, #0
01178     5A 01 A0 FD | 	call	#__longjmp
0117c                 | LR__0040
0117c                 | ' 
0117c                 | '     case eTimeUnits
0117c     01 02 0F F2 | 	cmp	local02, #1 wz
01180     02 02 0F 52 |  if_ne	cmp	local02, #2 wz
01184     18 00 90 AD |  if_e	jmp	#LR__0041
01188     81 01 00 F6 | 	mov	0-0, local02
0118c     36 26 64 FD | 	brk	#19
01190                 | '             abort
01190     6C F7 02 F6 | 	mov	arg01, abortchain
01194     00 F8 06 F6 | 	mov	arg02, #0
01198     00 FA 06 F6 | 	mov	arg03, #0
0119c     5A 01 A0 FD | 	call	#__longjmp
011a0                 | LR__0041
011a0                 | ' 
011a0                 | '     if eTimeUnits == DTU_SEC
011a0     02 02 0F F2 | 	cmp	local02, #2 wz
011a4     20 00 90 5D |  if_ne	jmp	#LR__0042
011a8                 | '         timeNow := getms()
011a8     50 1E B0 FD | 	call	#__system___getms
011ac     01 00 00 FF 
011b0     E8 01 07 FD | 	qmul	local01, ##1000
011b4     75 05 03 F6 | 	mov	local03, result1
011b8     82 07 03 F6 | 	mov	local04, local03
011bc                 | '         motorStopMSecs := timeNow + (nTime * 1_000)
011bc                 | '         if motorStopMSecs == 0
011bc                 | '           motorStopMSecs := 1
011bc     18 02 63 FD | 	getqx	local02
011c0     81 07 0B F1 | 	add	local04, local02 wz
011c4     10 00 90 FD | 	jmp	#LR__0043
011c8                 | LR__0042
011c8                 | '     else
011c8                 | '         timeNow := getms()
011c8     30 1E B0 FD | 	call	#__system___getms
011cc     75 05 03 F6 | 	mov	local03, result1
011d0     82 07 03 F6 | 	mov	local04, local03
011d4     80 07 0B F1 | 	add	local04, local01 wz
011d8                 | '         motorStopMSecs := timeNow + nTime
011d8                 | '         if motorStopMSecs == 0
011d8                 | '           motorStopMSecs := 1
011d8                 | LR__0043
011d8     20 E1 06 F1 | 	add	objptr, #288
011dc     70 07 63 FC | 	wrlong	local04, objptr
011e0     20 E1 86 F1 | 	sub	objptr, #288
011e4     20 E1 06 A1 |  if_e	add	objptr, #288
011e8     70 03 68 AC |  if_e	wrlong	#1, objptr
011ec     20 E1 86 A1 |  if_e	sub	objptr, #288
011f0                 | ' 
011f0                 | '     if motorStopMSecs > 0
011f0     20 E1 06 F1 | 	add	objptr, #288
011f4     70 07 03 FB | 	rdlong	local04, objptr
011f8     20 E1 86 F1 | 	sub	objptr, #288
011fc     01 06 57 F2 | 	cmps	local04, #1 wc
01200     0C 00 90 CD |  if_b	jmp	#LR__0044
01204     83 01 00 F6 | 	mov	0-0, local04
01208     82 03 00 F6 | 	mov	1-0, local03
0120c     36 28 64 FD | 	brk	#20
01210                 | LR__0044
01210     00 EA 06 F6 | 	mov	result1, #0
01214     27 F1 03 F6 | 	mov	ptra, fp
01218     32 01 A0 FD | 	call	#popregs_
0121c                 | _isp_steering_2wheel_stopAfterTime_ret
0121c     2D 00 64 FD | 	ret
01220                 | 
01220                 | ' 
01220                 | ' PUB stopMotors()
01220                 | _isp_steering_2wheel_stopMotors
01220                 | ' '' Stops both motors, killing any motion that was still in progress
01220                 | ' '' AFFECTED BY:holdAtStop()
01220                 | '     rqstPower := rqstLtPower := rqstRtPower := 0
01220     30 E1 06 F1 | 	add	objptr, #304
01224     70 01 68 FC | 	wrlong	#0, objptr
01228     04 E0 86 F1 | 	sub	objptr, #4
0122c     70 01 68 FC | 	wrlong	#0, objptr
01230     08 E0 86 F1 | 	sub	objptr, #8
01234     70 01 68 FC | 	wrlong	#0, objptr
01238                 | '     ltWheel.stopMotor()
01238     60 E0 06 F1 | 	add	objptr, #96
0123c                 | ' '' Stops the motor, killing any motion that was still in progress
0123c                 | ' ''  AFFECTED BY:holdAtStop()
0123c                 | '     setTargetAccel(0, false)
0123c     00 F6 06 F6 | 	mov	arg01, #0
01240     00 F8 06 F6 | 	mov	arg02, #0
01244     98 17 B0 FD | 	call	#_isp_bldc_motor_setTargetAccel
01248                 | '     rtWheel.stopMotor()
01248     01 00 00 FF 
0124c     14 E1 06 F1 | 	add	objptr, ##788
01250                 | ' '' Stops the motor, killing any motion that was still in progress
01250                 | ' ''  AFFECTED BY:holdAtStop()
01250                 | '     setTargetAccel(0, false)
01250     00 F6 06 F6 | 	mov	arg01, #0
01254     00 F8 06 F6 | 	mov	arg02, #0
01258     84 17 B0 FD | 	call	#_isp_bldc_motor_setTargetAccel
0125c     02 00 00 FF 
01260     98 E0 86 F1 | 	sub	objptr, ##1176
01264                 | _isp_steering_2wheel_stopMotors_ret
01264     2D 00 64 FD | 	ret
01268                 | 
01268                 | ' 
01268                 | ' PRI calcPowerForDirection(power, direction) : ltPower, rtPower | limitPwr, limitDir, reducedPower
01268                 | _isp_steering_2wheel_calcPowerForDirection
01268     64 F0 66 F6 | 	neg	_var01, #100
0126c     7B F1 42 F3 | 	fges	_var01, arg01
01270     64 F0 66 F3 | 	fles	_var01, #100
01274     64 F2 66 F6 | 	neg	_var02, #100
01278     7C F3 42 F3 | 	fges	_var02, arg02
0127c     64 F2 66 F3 | 	fles	_var02, #100
01280     79 EB 42 F6 | 	abs	result1, _var02
01284     64 EC 06 F6 | 	mov	result2, #100
01288     75 ED 82 F1 | 	sub	result2, result1
0128c     78 ED 02 FD | 	qmul	result2, _var01
01290                 | ' ' determine porportional power based on direction
01290                 | '     limitPwr :=  -100 #> power <# 100
01290                 | '     limitDir :=  -100 #> direction <# 100
01290                 | '     reducedPower := ((100 - abs(limitDir)) * limitPwr) / 100                    ' calculate reduced power for turning
01290     18 EA 62 FD | 	getqx	result1
01294     75 EB 52 F6 | 	abs	result1, result1 wc
01298     64 EA 16 FD | 	qdiv	result1, #100
0129c                 | '     {
0129c                 | '     }
0129c                 | '     ltPower := ((limitDir <= 0)) ? limitPwr : reducedPower                      ' which side if either should be reducedpower
0129c                 | '     rtPower := ((limitDir >= 0)) ? limitPwr : reducedPower
0129c     18 EA 62 FD | 	getqx	result1
012a0     75 F5 82 F6 | 	negc	_var03, result1
012a4     01 F2 56 F2 | 	cmps	_var02, #1 wc
012a8     78 ED 02 C6 |  if_b	mov	result2, _var01
012ac     7A ED 02 36 |  if_ae	mov	result2, _var03
012b0     76 EB 02 F6 | 	mov	result1, result2
012b4     00 F2 56 F2 | 	cmps	_var02, #0 wc
012b8     78 ED 02 36 |  if_ae	mov	result2, _var01
012bc     7A ED 02 C6 |  if_b	mov	result2, _var03
012c0     7B 01 00 F6 | 	mov	0-0, arg01
012c4     7C 03 00 F6 | 	mov	1-0, arg02
012c8     75 05 00 F6 | 	mov	2-0, result1
012cc     76 07 00 F6 | 	mov	3-0, result2
012d0     36 34 64 FD | 	brk	#26
012d4                 | _isp_steering_2wheel_calcPowerForDirection_ret
012d4     2D 00 64 FD | 	ret
012d8                 | 
012d8                 | ' 
012d8                 | ' PUB isReady() : bState
012d8                 | _isp_steering_2wheel_isReady
012d8                 | ' '' Return T/F where T means the both motor cogs are running
012d8                 | '     bState := ltWheel.isReady() and rtWheel.isReady()
012d8     00 F0 06 F6 | 	mov	_var01, #0
012dc                 | ' '' Return T/F where T means the motor cog is running
012dc                 | '     bState := (drv_state <> DCS_Unknown) ? true : false
012dc     01 00 00 FF 
012e0     EF E1 06 F1 | 	add	objptr, ##1007
012e4     70 F3 0A FB | 	rdlong	_var02, objptr wz
012e8     01 EA 66 56 |  if_ne	neg	result1, #1
012ec     00 EA 06 A6 |  if_e	mov	result1, #0
012f0     00 EA 0E F2 | 	cmp	result1, #0 wz
012f4     00 F0 26 56 |  if_ne	not	_var01, #0
012f8     00 F4 06 F6 | 	mov	_var03, #0
012fc                 | ' '' Return T/F where T means the motor cog is running
012fc                 | '     bState := (drv_state <> DCS_Unknown) ? true : false
012fc     01 00 00 FF 
01300     14 E1 06 F1 | 	add	objptr, ##788
01304     70 F3 0A FB | 	rdlong	_var02, objptr wz
01308     01 EA 66 56 |  if_ne	neg	result1, #1
0130c     00 EA 06 A6 |  if_e	mov	result1, #0
01310     03 00 00 FF 
01314     03 E1 86 F1 | 	sub	objptr, ##1795
01318     00 EA 0E F2 | 	cmp	result1, #0 wz
0131c     00 F4 26 56 |  if_ne	not	_var03, #0
01320     7A F1 02 F5 | 	and	_var01, _var03
01324     78 EB 02 F6 | 	mov	result1, _var01
01328                 | _isp_steering_2wheel_isReady_ret
01328     2D 00 64 FD | 	ret
0132c                 | 
0132c                 | ' 
0132c                 | ' PUB isStopped() : bState
0132c                 | _isp_steering_2wheel_isStopped
0132c                 | ' '' Return T/F where T means the both motors are stopped
0132c                 | '     bState := ltWheel.isStopped() and rtWheel.isStopped()
0132c     00 F0 06 F6 | 	mov	_var01, #0
01330                 | ' '' Return T/F where T means the motor is stopped
01330                 | '     bState := (drv_state == DCS_STOPPED) ? true : false
01330     01 00 00 FF 
01334     EF E1 06 F1 | 	add	objptr, ##1007
01338     70 F3 02 FB | 	rdlong	_var02, objptr
0133c     01 F2 0E F2 | 	cmp	_var02, #1 wz
01340     01 EA 66 A6 |  if_e	neg	result1, #1
01344     00 EA 06 56 |  if_ne	mov	result1, #0
01348     00 EA 0E F2 | 	cmp	result1, #0 wz
0134c     00 F0 26 56 |  if_ne	not	_var01, #0
01350     00 F4 06 F6 | 	mov	_var03, #0
01354                 | ' '' Return T/F where T means the motor is stopped
01354                 | '     bState := (drv_state == DCS_STOPPED) ? true : false
01354     01 00 00 FF 
01358     14 E1 06 F1 | 	add	objptr, ##788
0135c     70 F3 02 FB | 	rdlong	_var02, objptr
01360     01 F2 0E F2 | 	cmp	_var02, #1 wz
01364     01 EA 66 A6 |  if_e	neg	result1, #1
01368     00 EA 06 56 |  if_ne	mov	result1, #0
0136c     03 00 00 FF 
01370     03 E1 86 F1 | 	sub	objptr, ##1795
01374     00 EA 0E F2 | 	cmp	result1, #0 wz
01378     00 F4 26 56 |  if_ne	not	_var03, #0
0137c     7A F1 02 F5 | 	and	_var01, _var03
01380     78 EB 02 F6 | 	mov	result1, _var01
01384                 | _isp_steering_2wheel_isStopped_ret
01384     2D 00 64 FD | 	ret
01388                 | 
01388                 | ' 
01388                 | ' PUB isStarting() : bState
01388                 | _isp_steering_2wheel_isStarting
01388                 | ' '' Return T/F where T means the either motor is spinning up
01388                 | '     bState := ltWheel.isStarting() or rtWheel.isStarting()
01388     00 F0 06 F6 | 	mov	_var01, #0
0138c                 | ' '' Return T/F where T means the motor is spinning up
0138c                 | '     'bState := (drv_state == DCS_SPIN_UP or drv_state == DCS_AT_SPEED) ? true : false
0138c                 | '     bState := (drv_state == DCS_SPIN_UP) ? true : false
0138c     01 00 00 FF 
01390     EF E1 06 F1 | 	add	objptr, ##1007
01394     70 F3 02 FB | 	rdlong	_var02, objptr
01398     02 F2 0E F2 | 	cmp	_var02, #2 wz
0139c     01 EA 66 A6 |  if_e	neg	result1, #1
013a0     00 EA 06 56 |  if_ne	mov	result1, #0
013a4     00 EA 0E F2 | 	cmp	result1, #0 wz
013a8     00 F0 26 56 |  if_ne	not	_var01, #0
013ac     00 F4 06 F6 | 	mov	_var03, #0
013b0                 | ' '' Return T/F where T means the motor is spinning up
013b0                 | '     'bState := (drv_state == DCS_SPIN_UP or drv_state == DCS_AT_SPEED) ? true : false
013b0                 | '     bState := (drv_state == DCS_SPIN_UP) ? true : false
013b0     01 00 00 FF 
013b4     14 E1 06 F1 | 	add	objptr, ##788
013b8     70 F3 02 FB | 	rdlong	_var02, objptr
013bc     02 F2 0E F2 | 	cmp	_var02, #2 wz
013c0     01 EA 66 A6 |  if_e	neg	result1, #1
013c4     00 EA 06 56 |  if_ne	mov	result1, #0
013c8     03 00 00 FF 
013cc     03 E1 86 F1 | 	sub	objptr, ##1795
013d0     00 EA 0E F2 | 	cmp	result1, #0 wz
013d4     00 F4 26 56 |  if_ne	not	_var03, #0
013d8     7A F1 42 F5 | 	or	_var01, _var03
013dc     78 EB 02 F6 | 	mov	result1, _var01
013e0                 | _isp_steering_2wheel_isStarting_ret
013e0     2D 00 64 FD | 	ret
013e4                 | 
013e4                 | ' 
013e4                 | ' PRI taskPostionSense() | senseStartTicks, eStopState
013e4                 | _isp_steering_2wheel_taskPostionSense
013e4     1B 4A 06 F6 | 	mov	COUNT_, #27
013e8     28 01 A0 FD | 	call	#pushregs_
013ec                 | ' ' TASK: every 1/8 Sec (8Hz) read motor pos and calculate RPM and countOf90ths/Sec
013ec                 | '     LAINIT()
013ec                 | ' 
013ec                 | '     eStopState := false
013ec     00 00 07 F6 | 	mov	local01, #0
013f0                 | '     ltWheel.resetWindowAccumulators()
013f0     84 E1 06 F1 | 	add	objptr, #388
013f4     C8 16 B0 FD | 	call	#_isp_bldc_motor_resetWindowAccumulators
013f8                 | '     rtWheel.resetWindowAccumulators()
013f8     01 00 00 FF 
013fc     14 E1 06 F1 | 	add	objptr, ##788
01400     BC 16 B0 FD | 	call	#_isp_bldc_motor_resetWindowAccumulators
01404     02 00 00 FF 
01408     98 E0 86 F1 | 	sub	objptr, ##1176
0140c                 | ' 
0140c                 | '     repeat
0140c                 | LR__0050
0140c                 | '         senseStartTicks := getct()
0140c     1A 02 63 FD | 	getct	local02
01410                 | ' 
01410                 | '         ' Q: Do we want to reset both accum on a fault?
01410                 | '         ' if MOTOR FAULT or estop, reset our tracker
01410                 | '         if ltWheel.getDriverState() == DCS_FAULTED or  ltWheel.getDriverState() == DCS_ESTOP
01410     00 04 07 F6 | 	mov	local03, #0
01414     00 06 07 F6 | 	mov	local04, #0
01418                 | ' '' Return Enum [DCS_*] value representing state of driver
01418                 | '     eDrvrState := drv_state
01418     01 00 00 FF 
0141c     EF E1 06 F1 | 	add	objptr, ##1007
01420     70 EB 02 FB | 	rdlong	result1, objptr
01424     06 EA 0E F2 | 	cmp	result1, #6 wz
01428     00 06 27 A6 |  if_e	not	local04, #0
0142c     00 06 0F F2 | 	cmp	local04, #0 wz
01430     00 04 27 56 |  if_ne	not	local03, #0
01434     00 08 07 F6 | 	mov	local05, #0
01438     00 0A 07 F6 | 	mov	local06, #0
0143c                 | ' '' Return Enum [DCS_*] value representing state of driver
0143c                 | '     eDrvrState := drv_state
0143c     01 00 00 FF 
01440     EF E1 86 F1 | 	sub	objptr, ##1007
01444     07 EA 0E F2 | 	cmp	result1, #7 wz
01448     00 0A 27 A6 |  if_e	not	local06, #0
0144c     00 0A 0F F2 | 	cmp	local06, #0 wz
01450     00 08 27 56 |  if_ne	not	local05, #0
01454     84 05 4B F5 | 	or	local03, local05 wz
01458     0C 00 90 AD |  if_e	jmp	#LR__0051
0145c                 | '             ltWheel.resetWindowAccumulators()
0145c     84 E1 06 F1 | 	add	objptr, #388
01460     5C 16 B0 FD | 	call	#_isp_bldc_motor_resetWindowAccumulators
01464     84 E1 86 F1 | 	sub	objptr, #388
01468                 | LR__0051
01468                 | ' 
01468                 | '         if rtWheel.getDriverState() == DCS_FAULTED or  rtWheel.getDriverState() == DCS_ESTOP
01468     00 04 07 F6 | 	mov	local03, #0
0146c     00 06 07 F6 | 	mov	local04, #0
01470                 | ' '' Return Enum [DCS_*] value representing state of driver
01470                 | '     eDrvrState := drv_state
01470     03 00 00 FF 
01474     03 E1 06 F1 | 	add	objptr, ##1795
01478     70 EB 02 FB | 	rdlong	result1, objptr
0147c     06 EA 0E F2 | 	cmp	result1, #6 wz
01480     00 06 27 A6 |  if_e	not	local04, #0
01484     00 06 0F F2 | 	cmp	local04, #0 wz
01488     00 04 27 56 |  if_ne	not	local03, #0
0148c     00 08 07 F6 | 	mov	local05, #0
01490     00 0A 07 F6 | 	mov	local06, #0
01494                 | ' '' Return Enum [DCS_*] value representing state of driver
01494                 | '     eDrvrState := drv_state
01494     03 00 00 FF 
01498     03 E1 86 F1 | 	sub	objptr, ##1795
0149c     07 EA 0E F2 | 	cmp	result1, #7 wz
014a0     00 0A 27 A6 |  if_e	not	local06, #0
014a4     00 0A 0F F2 | 	cmp	local06, #0 wz
014a8     00 08 27 56 |  if_ne	not	local05, #0
014ac     84 05 4B F5 | 	or	local03, local05 wz
014b0     14 00 90 AD |  if_e	jmp	#LR__0052
014b4                 | '             rtWheel.resetWindowAccumulators()
014b4     02 00 00 FF 
014b8     98 E0 06 F1 | 	add	objptr, ##1176
014bc     00 16 B0 FD | 	call	#_isp_bldc_motor_resetWindowAccumulators
014c0     02 00 00 FF 
014c4     98 E0 86 F1 | 	sub	objptr, ##1176
014c8                 | LR__0052
014c8                 | ' 
014c8                 | '         showDriveStatesOnChange()
014c8                 | '     reportDrvStatusOnChange()
014c8                 | '     ltState, rtState := getDriverState()
014c8                 | ' ' Returns status of motor-driver state for each motor: enumerated constants: DCS_*
014c8                 | '     eLeftState := ltWheel.getDriverState()
014c8                 | ' '' Return Enum [DCS_*] value representing state of driver
014c8                 | '     eDrvrState := drv_state
014c8     01 00 00 FF 
014cc     EF E1 06 F1 | 	add	objptr, ##1007
014d0     70 0D 03 FB | 	rdlong	local07, objptr
014d4                 | '     eRightState := rtWheel.getDriverState()
014d4                 | ' '' Return Enum [DCS_*] value representing state of driver
014d4                 | '     eDrvrState := drv_state
014d4     01 00 00 FF 
014d8     14 E1 06 F1 | 	add	objptr, ##788
014dc     70 0F 03 FB | 	rdlong	local08, objptr
014e0     03 00 00 FF 
014e4     03 E1 86 F1 | 	sub	objptr, ##1795
014e8                 | '     if priorLtState <> ltState
014e8     A4 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #164
014ec     73 F7 02 FB | 	rdlong	arg01, ptr__isp_steering_2wheel_dat__
014f0     A4 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #164
014f4     86 F7 0A F2 | 	cmp	arg01, local07 wz
014f8     1C 00 90 AD |  if_e	jmp	#LR__0053
014fc                 | '         showDriverState(ltState, @"ltMot")
014fc     1C 00 00 FF 
01500     28 F9 06 F6 | 	mov	arg02, ##@LR__0452
01504     86 F7 02 F6 | 	mov	arg01, local07
01508     F4 04 B0 FD | 	call	#_isp_steering_2wheel_showDriverState
0150c                 | '         priorLtState := ltState
0150c     A4 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #164
01510     73 0D 63 FC | 	wrlong	local07, ptr__isp_steering_2wheel_dat__
01514     A4 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #164
01518                 | LR__0053
01518                 | ' 
01518                 | '     if priorRtState <> rtState
01518     A8 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #168
0151c     73 0D 03 FB | 	rdlong	local07, ptr__isp_steering_2wheel_dat__
01520     A8 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #168
01524     87 0D 0B F2 | 	cmp	local07, local08 wz
01528     1C 00 90 AD |  if_e	jmp	#LR__0054
0152c                 | '         showDriverState(rtState, @"rtMot")
0152c     1C 00 00 FF 
01530     2E F9 06 F6 | 	mov	arg02, ##@LR__0453
01534     87 F7 02 F6 | 	mov	arg01, local08
01538     C4 04 B0 FD | 	call	#_isp_steering_2wheel_showDriverState
0153c                 | '         priorRtState := rtState
0153c     A8 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #168
01540     73 0F 63 FC | 	wrlong	local08, ptr__isp_steering_2wheel_dat__
01544     A8 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #168
01548                 | LR__0054
01548                 | '     reportMotorStatusOnChange()
01548                 | '     ltStatus, rtStatus := getStatus()
01548                 | ' '' Returns status of motor drive state for each motor: enumerated constant: DS_MOVING, DS_HOLDING or DS_OFF
01548                 | '     eLeftStatus := ltWheel.getStatus()
01548     84 E1 06 F1 | 	add	objptr, #388
0154c     8C 0E B0 FD | 	call	#_isp_bldc_motor_getStatus
01550     75 11 03 F6 | 	mov	local09, result1
01554                 | '     eRightStatus := rtWheel.getStatus()
01554     01 00 00 FF 
01558     14 E1 06 F1 | 	add	objptr, ##788
0155c     7C 0E B0 FD | 	call	#_isp_bldc_motor_getStatus
01560     02 00 00 FF 
01564     98 E0 86 F1 | 	sub	objptr, ##1176
01568     75 13 03 F6 | 	mov	local10, result1
0156c     88 EB 02 F6 | 	mov	result1, local09
01570     75 15 03 F6 | 	mov	local11, result1
01574                 | '     if priorLtStatus <> ltStatus
01574     9C E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #156
01578     73 F7 02 FB | 	rdlong	arg01, ptr__isp_steering_2wheel_dat__
0157c     9C E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #156
01580     8A F7 0A F2 | 	cmp	arg01, local11 wz
01584     1C 00 90 AD |  if_e	jmp	#LR__0055
01588                 | '         showStatus(ltStatus, @"ltMot")
01588     1C 00 00 FF 
0158c     34 F9 06 F6 | 	mov	arg02, ##@LR__0454
01590     8A F7 02 F6 | 	mov	arg01, local11
01594     B0 05 B0 FD | 	call	#_isp_steering_2wheel_showStatus
01598                 | '         priorLtStatus := ltStatus
01598     9C E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #156
0159c     73 15 63 FC | 	wrlong	local11, ptr__isp_steering_2wheel_dat__
015a0     9C E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #156
015a4                 | LR__0055
015a4                 | ' 
015a4                 | '     if priorRtStatus <> rtStatus
015a4     A0 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #160
015a8     73 15 03 FB | 	rdlong	local11, ptr__isp_steering_2wheel_dat__
015ac     A0 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #160
015b0     89 15 0B F2 | 	cmp	local11, local10 wz
015b4     1C 00 90 AD |  if_e	jmp	#LR__0056
015b8                 | '         showStatus(rtStatus, @"rtMot")
015b8     1C 00 00 FF 
015bc     3A F9 06 F6 | 	mov	arg02, ##@LR__0455
015c0     89 F7 02 F6 | 	mov	arg01, local10
015c4     80 05 B0 FD | 	call	#_isp_steering_2wheel_showStatus
015c8                 | '         priorRtStatus := rtStatus
015c8     A0 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #160
015cc     73 13 63 FC | 	wrlong	local10, ptr__isp_steering_2wheel_dat__
015d0     A0 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #160
015d4                 | LR__0056
015d4                 | '     reportMotorFaultOnChange()
015d4                 | '     bLeftStatus, bRightStatus := getFaultStatus()
015d4                 | ' ' Returns status of motor-driver fault-state for each motor: T/F
015d4                 | '     bLeftStatus := ltWheel.isFaulted()
015d4                 | ' '' Return T/F where T means the motor has faulted
015d4                 | '     bState := (drv_state == DCS_FAULTED) ? true : false
015d4     01 00 00 FF 
015d8     EF E1 06 F1 | 	add	objptr, ##1007
015dc     70 ED 02 FB | 	rdlong	result2, objptr
015e0     06 EC 0E F2 | 	cmp	result2, #6 wz
015e4     01 EA 66 A6 |  if_e	neg	result1, #1
015e8     00 EA 06 56 |  if_ne	mov	result1, #0
015ec     75 17 03 F6 | 	mov	local12, result1
015f0                 | '     bRightStatus := rtWheel.isFaulted()
015f0                 | ' '' Return T/F where T means the motor has faulted
015f0                 | '     bState := (drv_state == DCS_FAULTED) ? true : false
015f0     01 00 00 FF 
015f4     14 E1 06 F1 | 	add	objptr, ##788
015f8     70 ED 02 FB | 	rdlong	result2, objptr
015fc     06 EC 0E F2 | 	cmp	result2, #6 wz
01600     01 EA 66 A6 |  if_e	neg	result1, #1
01604     00 EA 06 56 |  if_ne	mov	result1, #0
01608     75 19 03 F6 | 	mov	local13, result1
0160c                 | ' 
0160c                 | '     bLeftSignal := ltWheel.isFaultSignal()
0160c                 | ' '' Return T/F where T means the motor has faulted
0160c                 | '     bState := (fault <> false) ? true : false
0160c     01 00 00 FF 
01610     10 E1 86 F1 | 	sub	objptr, ##784
01614     70 ED 0A FB | 	rdlong	result2, objptr wz
01618     01 EA 66 56 |  if_ne	neg	result1, #1
0161c     00 EA 06 A6 |  if_e	mov	result1, #0
01620     75 1B 03 F6 | 	mov	local14, result1
01624                 | '     bRightSignal := rtWheel.isFaultSignal()
01624                 | ' '' Return T/F where T means the motor has faulted
01624                 | '     bState := (fault <> false) ? true : false
01624     01 00 00 FF 
01628     14 E1 06 F1 | 	add	objptr, ##788
0162c     70 ED 0A FB | 	rdlong	result2, objptr wz
01630     01 EA 66 56 |  if_ne	neg	result1, #1
01634     00 EA 06 A6 |  if_e	mov	result1, #0
01638     03 00 00 FF 
0163c     07 E1 86 F1 | 	sub	objptr, ##1799
01640     75 1D 03 F6 | 	mov	local15, result1
01644                 | ' 
01644                 | '     ' if fault appears then let it stay for 3*1000 mSec
01644                 | '     ' . after that, clear it
01644                 | ' 
01644                 | '     if bLeftSignal == TRUE and ltFaultSeenMS == 0
01644     FF FF 7F FF 
01648     FF 1B 0F F2 | 	cmp	local14, ##-1 wz
0164c     73 1F 0B AB |  if_e	rdlong	local16, ptr__isp_steering_2wheel_dat__ wz
01650     1C 00 90 5D |  if_ne	jmp	#LR__0057
01654                 | '         ltFaultSeenMS := getms() + 3000
01654     A4 19 B0 FD | 	call	#__system___getms
01658     05 00 00 FF 
0165c     B8 EB 0E F1 | 	add	result1, ##3000 wz
01660     73 EB 62 FC | 	wrlong	result1, ptr__isp_steering_2wheel_dat__
01664                 | '         if ltFaultSeenMS == 0                                                   ' just in case happens to add to 0
01664                 | '           ltFaultSeenMS := 1
01664     73 03 68 AC |  if_e	wrlong	#1, ptr__isp_steering_2wheel_dat__
01668     36 2C 64 FD | 	brk	#22
0166c     64 00 90 FD | 	jmp	#LR__0060
01670                 | LR__0057
01670                 | '     elseif bLeftSignal == TRUE and ltFaultSeenMS <> 0 and getms() > ltFaultSeenMS
01670     00 1E 07 F6 | 	mov	local16, #0
01674     00 20 07 F6 | 	mov	local17, #0
01678     FF FF 7F FF 
0167c     FF 1B 0F F2 | 	cmp	local14, ##-1 wz
01680     08 00 90 5D |  if_ne	jmp	#LR__0058
01684     73 1B 0B FB | 	rdlong	local14, ptr__isp_steering_2wheel_dat__ wz
01688     01 20 67 56 |  if_ne	neg	local17, #1
0168c                 | LR__0058
0168c     00 20 0F F2 | 	cmp	local17, #0 wz
01690     8F 1F 23 56 |  if_ne	not	local16, local16
01694     00 22 07 F6 | 	mov	local18, #0
01698     00 24 07 F6 | 	mov	local19, #0
0169c     5C 19 B0 FD | 	call	#__system___getms
016a0     75 27 03 F6 | 	mov	local20, result1
016a4     73 21 03 FB | 	rdlong	local17, ptr__isp_steering_2wheel_dat__
016a8     90 27 5B F2 | 	cmps	local20, local17 wcz
016ac     00 24 27 16 |  if_a	not	local19, #0
016b0     00 24 0F F2 | 	cmp	local19, #0 wz
016b4     00 22 27 56 |  if_ne	not	local18, #0
016b8     91 1F CB F7 | 	test	local16, local18 wz
016bc     14 00 90 AD |  if_e	jmp	#LR__0059
016c0     36 2E 64 FD | 	brk	#23
016c4                 | '         ltWheel.clearFaultSignal()
016c4     84 E1 06 F1 | 	add	objptr, #388
016c8     94 0E B0 FD | 	call	#_isp_bldc_motor_clearFaultSignal
016cc     84 E1 86 F1 | 	sub	objptr, #388
016d0                 | '         ltFaultSeenMS := 0
016d0     73 01 68 FC | 	wrlong	#0, ptr__isp_steering_2wheel_dat__
016d4                 | LR__0059
016d4                 | LR__0060
016d4                 | ' 
016d4                 | '     if bRightSignal == TRUE and rtFaultSeenMS == 0
016d4     FF FF 7F FF 
016d8     FF 1D 0F F2 | 	cmp	local15, ##-1 wz
016dc     3C 00 90 5D |  if_ne	jmp	#LR__0061
016e0     04 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #4
016e4     73 1F 0B FB | 	rdlong	local16, ptr__isp_steering_2wheel_dat__ wz
016e8     04 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #4
016ec     2C 00 90 5D |  if_ne	jmp	#LR__0061
016f0                 | '         rtFaultSeenMS := getms() + 3000
016f0     08 19 B0 FD | 	call	#__system___getms
016f4     05 00 00 FF 
016f8     B8 EB 0E F1 | 	add	result1, ##3000 wz
016fc     04 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #4
01700     73 EB 62 FC | 	wrlong	result1, ptr__isp_steering_2wheel_dat__
01704                 | '         if rtFaultSeenMS == 0                                                   ' just in case happens to add to 0
01704     04 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #4
01708                 | '           rtFaultSeenMS := 1
01708     04 E6 06 A1 |  if_e	add	ptr__isp_steering_2wheel_dat__, #4
0170c     73 03 68 AC |  if_e	wrlong	#1, ptr__isp_steering_2wheel_dat__
01710     04 E6 86 A1 |  if_e	sub	ptr__isp_steering_2wheel_dat__, #4
01714     36 30 64 FD | 	brk	#24
01718     84 00 90 FD | 	jmp	#LR__0064
0171c                 | LR__0061
0171c                 | '     elseif bRightSignal == TRUE and rtFaultSeenMS <> 0 and getms() > rtFaultSeenMS
0171c     00 1E 07 F6 | 	mov	local16, #0
01720     00 20 07 F6 | 	mov	local17, #0
01724     FF FF 7F FF 
01728     FF 1D 0F F2 | 	cmp	local15, ##-1 wz
0172c     10 00 90 5D |  if_ne	jmp	#LR__0062
01730     04 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #4
01734     73 27 0B FB | 	rdlong	local20, ptr__isp_steering_2wheel_dat__ wz
01738     04 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #4
0173c     01 20 67 56 |  if_ne	neg	local17, #1
01740                 | LR__0062
01740     00 20 0F F2 | 	cmp	local17, #0 wz
01744     8F 1F 23 56 |  if_ne	not	local16, local16
01748     00 24 07 F6 | 	mov	local19, #0
0174c     00 26 07 F6 | 	mov	local20, #0
01750     A8 18 B0 FD | 	call	#__system___getms
01754     75 29 03 F6 | 	mov	local21, result1
01758     04 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #4
0175c     73 2B 03 FB | 	rdlong	local22, ptr__isp_steering_2wheel_dat__
01760     04 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #4
01764     95 29 5B F2 | 	cmps	local21, local22 wcz
01768     00 26 27 16 |  if_a	not	local20, #0
0176c     00 26 0F F2 | 	cmp	local20, #0 wz
01770     00 24 27 56 |  if_ne	not	local19, #0
01774     92 1F CB F7 | 	test	local16, local19 wz
01778     24 00 90 AD |  if_e	jmp	#LR__0063
0177c     36 32 64 FD | 	brk	#25
01780                 | '         rtWheel.clearFaultSignal()
01780     02 00 00 FF 
01784     98 E0 06 F1 | 	add	objptr, ##1176
01788     D4 0D B0 FD | 	call	#_isp_bldc_motor_clearFaultSignal
0178c     02 00 00 FF 
01790     98 E0 86 F1 | 	sub	objptr, ##1176
01794                 | '         rtFaultSeenMS := 0
01794     04 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #4
01798     73 01 68 FC | 	wrlong	#0, ptr__isp_steering_2wheel_dat__
0179c     04 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #4
017a0                 | LR__0063
017a0                 | LR__0064
017a0     8B 2D 03 F6 | 	mov	local23, local12
017a4     8C 2F 03 F6 | 	mov	local24, local13
017a8                 | '     if priorLtFault <> bLeftStatus
017a8     AC E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #172
017ac     73 FB 02 FB | 	rdlong	arg03, ptr__isp_steering_2wheel_dat__
017b0     AC E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #172
017b4     96 FB 0A F2 | 	cmp	arg03, local23 wz
017b8     20 00 90 AD |  if_e	jmp	#LR__0065
017bc                 | '         showFaultStatus(bLeftStatus, @"ltMot", true)       ' force output
017bc     1C 00 00 FF 
017c0     40 F9 06 F6 | 	mov	arg02, ##@LR__0456
017c4     96 F7 02 F6 | 	mov	arg01, local23
017c8     01 FA 66 F6 | 	neg	arg03, #1
017cc     54 04 B0 FD | 	call	#_isp_steering_2wheel_showFaultStatus
017d0                 | '         priorLtFault := bLeftStatus
017d0     AC E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #172
017d4     73 2D 63 FC | 	wrlong	local23, ptr__isp_steering_2wheel_dat__
017d8     AC E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #172
017dc                 | LR__0065
017dc                 | ' 
017dc                 | '     if priorRtFault <> bRightStatus
017dc     B0 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #176
017e0     73 2D 03 FB | 	rdlong	local23, ptr__isp_steering_2wheel_dat__
017e4     B0 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #176
017e8     97 2D 0B F2 | 	cmp	local23, local24 wz
017ec     20 00 90 AD |  if_e	jmp	#LR__0066
017f0                 | '         showFaultStatus(bRightStatus, @"rtMot", true)
017f0     1C 00 00 FF 
017f4     46 F9 06 F6 | 	mov	arg02, ##@LR__0457
017f8     97 F7 02 F6 | 	mov	arg01, local24
017fc     01 FA 66 F6 | 	neg	arg03, #1
01800     20 04 B0 FD | 	call	#_isp_steering_2wheel_showFaultStatus
01804                 | '         priorRtFault := bRightStatus
01804     B0 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #176
01808     73 2F 63 FC | 	wrlong	local24, ptr__isp_steering_2wheel_dat__
0180c     B0 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #176
01810                 | LR__0066
01810                 | ' 
01810                 | '         LALOOPSTART()
01810                 | ' 
01810                 | '         ' PROCESS left/right motor
01810                 | '         updateWindowAccumulators()
01810                 | '     ltWheel.updateWindowAccumulators()
01810     84 E1 06 F1 | 	add	objptr, #388
01814     2C 13 B0 FD | 	call	#_isp_bldc_motor_updateWindowAccumulators
01818                 | '     rtWheel.updateWindowAccumulators()
01818     01 00 00 FF 
0181c     14 E1 06 F1 | 	add	objptr, ##788
01820     20 13 B0 FD | 	call	#_isp_bldc_motor_updateWindowAccumulators
01824                 | ' 
01824                 | '         ' if user set time/distance to stop then stop if we are past the time or distance
01824                 | '         ' if both time and distance is used, first check until time is passed and then check distance
01824                 | '         if motorStopMSecs > 0 and (getms() > motorStopMSecs)
01824     00 04 07 F6 | 	mov	local03, #0
01828     00 06 07 F6 | 	mov	local04, #0
0182c     01 00 00 FF 
01830     78 E1 86 F1 | 	sub	objptr, ##888
01834     70 0B 03 FB | 	rdlong	local06, objptr
01838     20 E1 86 F1 | 	sub	objptr, #288
0183c     01 0A 57 F2 | 	cmps	local06, #1 wc
01840     01 06 67 36 |  if_ae	neg	local04, #1
01844     00 06 0F F2 | 	cmp	local04, #0 wz
01848     00 04 27 56 |  if_ne	not	local03, #0
0184c     00 0A 07 F6 | 	mov	local06, #0
01850     00 08 07 F6 | 	mov	local05, #0
01854     A4 17 B0 FD | 	call	#__system___getms
01858     75 F7 02 F6 | 	mov	arg01, result1
0185c     20 E1 06 F1 | 	add	objptr, #288
01860     70 31 03 FB | 	rdlong	local25, objptr
01864     20 E1 86 F1 | 	sub	objptr, #288
01868     98 F7 5A F2 | 	cmps	arg01, local25 wcz
0186c     00 08 27 16 |  if_a	not	local05, #0
01870     00 08 0F F2 | 	cmp	local05, #0 wz
01874     00 0A 27 56 |  if_ne	not	local06, #0
01878     85 05 CB F7 | 	test	local03, local06 wz
0187c     14 00 90 AD |  if_e	jmp	#LR__0067
01880                 | '             stopMotors()
01880     9C F9 BF FD | 	call	#_isp_steering_2wheel_stopMotors
01884                 | '             motorStopMSecs := 0 ' and clear user request
01884     20 E1 06 F1 | 	add	objptr, #288
01888     70 01 68 FC | 	wrlong	#0, objptr
0188c     20 E1 86 F1 | 	sub	objptr, #288
01890     88 00 90 FD | 	jmp	#LR__0070
01894                 | LR__0067
01894                 | '         elseif motorStopHallTicks > 0
01894     1C E1 06 F1 | 	add	objptr, #284
01898     70 05 03 FB | 	rdlong	local03, objptr
0189c     1C E1 86 F1 | 	sub	objptr, #284
018a0     01 04 57 F2 | 	cmps	local03, #1 wc
018a4     74 00 90 CD |  if_b	jmp	#LR__0069
018a8                 | '             'debug(" taskPostionSense: ", udec(motorStopHallTicks), " ", udec(ltWheel.getposTrkHallTicks()), " ", udec(rtWheel.getposTrkHallTicks()))
018a8                 | '             if (ltWheel.getposTrkHallTicks() > motorStopHallTicks or rtWheel.getposTrkHallTicks() > motorStopHallTicks)
018a8     00 04 07 F6 | 	mov	local03, #0
018ac     00 06 07 F6 | 	mov	local04, #0
018b0                 | ' '' INTERNAL USE: return our position tracking hall-ticks
018b0                 | '     retv := posTrkHallTicks
018b0     01 00 00 FF 
018b4     F7 E1 06 F1 | 	add	objptr, ##1015
018b8     70 31 03 FB | 	rdlong	local25, objptr
018bc     01 00 00 FF 
018c0     DB E0 86 F1 | 	sub	objptr, ##731
018c4     70 F7 02 FB | 	rdlong	arg01, objptr
018c8     7B 31 5B F2 | 	cmps	local25, arg01 wcz
018cc     00 06 27 16 |  if_a	not	local04, #0
018d0     00 06 0F F2 | 	cmp	local04, #0 wz
018d4     00 04 27 56 |  if_ne	not	local03, #0
018d8     00 08 07 F6 | 	mov	local05, #0
018dc     00 32 07 F6 | 	mov	local26, #0
018e0                 | ' '' INTERNAL USE: return our position tracking hall-ticks
018e0                 | '     retv := posTrkHallTicks
018e0     02 00 00 FF 
018e4     EF E1 06 F1 | 	add	objptr, ##1519
018e8     70 31 03 FB | 	rdlong	local25, objptr
018ec     03 00 00 FF 
018f0     0B E1 86 F1 | 	sub	objptr, ##1803
018f4     7B 31 5B F2 | 	cmps	local25, arg01 wcz
018f8     00 32 27 16 |  if_a	not	local26, #0
018fc     00 32 0F F2 | 	cmp	local26, #0 wz
01900     00 08 27 56 |  if_ne	not	local05, #0
01904     84 05 4B F5 | 	or	local03, local05 wz
01908     10 00 90 AD |  if_e	jmp	#LR__0068
0190c                 | '                 stopMotors()
0190c     10 F9 BF FD | 	call	#_isp_steering_2wheel_stopMotors
01910                 | '                 motorStopHallTicks := 0 ' and clear user request
01910     1C E1 06 F1 | 	add	objptr, #284
01914     70 01 68 FC | 	wrlong	#0, objptr
01918     1C E1 86 F1 | 	sub	objptr, #284
0191c                 | LR__0068
0191c                 | LR__0069
0191c                 | LR__0070
0191c                 | ' 
0191c                 | '         LALOOPEND()
0191c                 | '         ' ------------------------------------------
0191c                 | '         ' iff driver reports e-stop then clear the emergency stop request
0191c                 | '         '  user will request it again if needed
0191c                 | '         ' NOTE: we leave e_stop set for at least 1/4 second before clearing!
0191c                 | '         if isEmergency()
0191c                 | ' ' return T/F where T means one or both wheels are in emergency cutoff state
0191c                 | '     bEmergencyState := ltWheel.isEmergency()
0191c                 | ' '' Return T/F where T means the motor is emergency-stopped
0191c                 | '     bState := (drv_state == DCS_ESTOP) ? true : false
0191c     01 00 00 FF 
01920     EF E1 06 F1 | 	add	objptr, ##1007
01924     70 35 03 FB | 	rdlong	local27, objptr
01928     07 34 0F F2 | 	cmp	local27, #7 wz
0192c     01 EA 66 A6 |  if_e	neg	result1, #1
01930     00 EA 06 56 |  if_ne	mov	result1, #0
01934     01 00 00 FF 
01938     EF E1 86 F1 | 	sub	objptr, ##1007
0193c     75 0B 0B F6 | 	mov	local06, result1 wz
01940                 | '     if not bEmergencyState
01940     24 00 90 5D |  if_ne	jmp	#LR__0071
01944                 | '         bEmergencyState := rtWheel.isEmergency()
01944                 | ' '' Return T/F where T means the motor is emergency-stopped
01944                 | '     bState := (drv_state == DCS_ESTOP) ? true : false
01944     03 00 00 FF 
01948     03 E1 06 F1 | 	add	objptr, ##1795
0194c     70 35 03 FB | 	rdlong	local27, objptr
01950     07 34 0F F2 | 	cmp	local27, #7 wz
01954     01 EA 66 A6 |  if_e	neg	result1, #1
01958     00 EA 06 56 |  if_ne	mov	result1, #0
0195c     03 00 00 FF 
01960     03 E1 86 F1 | 	sub	objptr, ##1795
01964     75 0B 03 F6 | 	mov	local06, result1
01968                 | LR__0071
01968                 | '     if bEmergencyState
01968     00 0A 0F F2 | 	cmp	local06, #0 wz
0196c     04 00 90 AD |  if_e	jmp	#LR__0072
01970     36 36 64 FD | 	brk	#27
01974                 | LR__0072
01974     00 0A 0F F2 | 	cmp	local06, #0 wz
01978     50 00 90 AD |  if_e	jmp	#LR__0074
0197c                 | '             if eStopState == true
0197c     FF FF 7F FF 
01980     FF 01 0F F2 | 	cmp	local01, ##-1 wz
01984                 | '                 clearEmergency()
01984     34 00 90 5D |  if_ne	jmp	#LR__0073
01988                 | ' '' Remove emergency override allowing motors to be driven again
01988                 | ' ' used by wheels*.spin2 methods
01988                 | '     userCutoff := FALSE
01988     34 E1 06 F1 | 	add	objptr, #308
0198c     70 01 68 FC | 	wrlong	#0, objptr
01990                 | '     ltWheel.clearEmergency()
01990                 | ' '' Clear EMERGENCY-Stop - remove the need to stop!
01990                 | '     e_stop := FALSE
01990     01 00 00 FF 
01994     4F E1 06 F1 | 	add	objptr, ##847
01998     70 01 68 FC | 	wrlong	#0, objptr
0199c     36 52 64 FD | 	brk	#41
019a0                 | '     rtWheel.clearEmergency()
019a0                 | ' '' Clear EMERGENCY-Stop - remove the need to stop!
019a0                 | '     e_stop := FALSE
019a0     01 00 00 FF 
019a4     14 E1 06 F1 | 	add	objptr, ##788
019a8     70 01 68 FC | 	wrlong	#0, objptr
019ac     36 52 64 FD | 	brk	#41
019b0     03 00 00 FF 
019b4     97 E1 86 F1 | 	sub	objptr, ##1943
019b8     36 2A 64 FD | 	brk	#21
019bc                 | LR__0073
019bc                 | '             !!= eStopState                                                      ' toggle stop flag
019bc     00 04 07 F6 | 	mov	local03, #0
019c0     00 00 0F F2 | 	cmp	local01, #0 wz
019c4     01 04 67 A6 |  if_e	neg	local03, #1
019c8     82 01 03 F6 | 	mov	local01, local03
019cc                 | LR__0074
019cc                 | ' 
019cc                 | '         ' keep track of runtime for this sensor loop (for debug, HDMI, etc.)
019cc                 | '         deltaTicks := getct() - senseStartTicks
019cc     1A EA 62 FD | 	getct	result1
019d0     81 EB 82 F1 | 	sub	result1, local02
019d4     10 E1 06 F1 | 	add	objptr, #272
019d8     70 EB 62 FC | 	wrlong	result1, objptr
019dc     08 E1 86 F1 | 	sub	objptr, #264
019e0     70 31 03 FB | 	rdlong	local25, objptr
019e4     08 E0 86 F1 | 	sub	objptr, #8
019e8                 | ' 
019e8                 | '         ' code uses about 1_880 ticks. This is little over 9 uS  @200MHz clock
019e8                 | '         '   wait remainder of 125 mSec before next sample
019e8                 | '         waitct(senseStartTicks + ticks125ms)    ' wait to create "sense" time-base
019e8     98 03 63 FA | 	addct1	local02, local25
019ec     24 22 60 FD | 	waitct1
019f0     18 FA 9F FD | 	jmp	#LR__0050
019f4     27 F1 03 F6 | 	mov	ptra, fp
019f8     32 01 A0 FD | 	call	#popregs_
019fc                 | _isp_steering_2wheel_taskPostionSense_ret
019fc     2D 00 64 FD | 	ret
01a00                 | 
01a00                 | ' 
01a00                 | ' 
01a00                 | ' PRI showDriverState(eState, pMsg)
01a00                 | _isp_steering_2wheel_showDriverState
01a00     03 4A 06 F6 | 	mov	COUNT_, #3
01a04     28 01 A0 FD | 	call	#pushregs_
01a08     7B 01 03 F6 | 	mov	local01, arg01
01a0c     7C 03 03 F6 | 	mov	local02, arg02
01a10                 | '     case eState
01a10     80 05 03 F6 | 	mov	local03, local01
01a14     08 04 27 F3 | 	fle	local03, #8
01a18     30 04 63 FD | 	jmprel	local03
01a1c                 | LR__0080
01a1c     20 00 90 FD | 	jmp	#LR__0081
01a20     34 00 90 FD | 	jmp	#LR__0082
01a24     48 00 90 FD | 	jmp	#LR__0083
01a28     5C 00 90 FD | 	jmp	#LR__0084
01a2c     70 00 90 FD | 	jmp	#LR__0085
01a30     84 00 90 FD | 	jmp	#LR__0086
01a34     98 00 90 FD | 	jmp	#LR__0087
01a38     AC 00 90 FD | 	jmp	#LR__0088
01a3c     C0 00 90 FD | 	jmp	#LR__0089
01a40                 | LR__0081
01a40                 | '         DCS_Unknown:
01a40                 | '             pStatVal := @dcsUnknown
01a40     30 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #48
01a44     73 05 03 F6 | 	mov	local03, ptr__isp_steering_2wheel_dat__
01a48     68 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #104
01a4c     73 05 63 FC | 	wrlong	local03, ptr__isp_steering_2wheel_dat__
01a50     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01a54     CC 00 90 FD | 	jmp	#LR__0090
01a58                 | LR__0082
01a58                 | '         DCS_STOPPED:
01a58                 | '             pStatVal := @dcsSTOPPED
01a58     37 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #55
01a5c     73 05 03 F6 | 	mov	local03, ptr__isp_steering_2wheel_dat__
01a60     61 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #97
01a64     73 05 63 FC | 	wrlong	local03, ptr__isp_steering_2wheel_dat__
01a68     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01a6c     B4 00 90 FD | 	jmp	#LR__0090
01a70                 | LR__0083
01a70                 | '         DCS_SPIN_UP:
01a70                 | '             pStatVal := @dcsSPIN_UP
01a70     42 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #66
01a74     73 05 03 F6 | 	mov	local03, ptr__isp_steering_2wheel_dat__
01a78     56 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #86
01a7c     73 05 63 FC | 	wrlong	local03, ptr__isp_steering_2wheel_dat__
01a80     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01a84     9C 00 90 FD | 	jmp	#LR__0090
01a88                 | LR__0084
01a88                 | '         DCS_AT_SPEED:
01a88                 | '             pStatVal := @dcsAT_SPEED
01a88     4D E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #77
01a8c     73 05 03 F6 | 	mov	local03, ptr__isp_steering_2wheel_dat__
01a90     4B E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #75
01a94     73 05 63 FC | 	wrlong	local03, ptr__isp_steering_2wheel_dat__
01a98     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01a9c     84 00 90 FD | 	jmp	#LR__0090
01aa0                 | LR__0085
01aa0                 | '         DCS_SPIN_DN:
01aa0                 | '             pStatVal := @dcsSPIN_DN
01aa0     59 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #89
01aa4     73 05 03 F6 | 	mov	local03, ptr__isp_steering_2wheel_dat__
01aa8     3F E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #63
01aac     73 05 63 FC | 	wrlong	local03, ptr__isp_steering_2wheel_dat__
01ab0     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01ab4     6C 00 90 FD | 	jmp	#LR__0090
01ab8                 | LR__0086
01ab8                 | '         DCS_SLOW_TO_CHG:
01ab8                 | '             pStatVal := @dcsSLOW_TO_CHG
01ab8     64 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #100
01abc     73 05 03 F6 | 	mov	local03, ptr__isp_steering_2wheel_dat__
01ac0     34 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #52
01ac4     73 05 63 FC | 	wrlong	local03, ptr__isp_steering_2wheel_dat__
01ac8     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01acc     54 00 90 FD | 	jmp	#LR__0090
01ad0                 | LR__0087
01ad0                 | '         DCS_FAULTED:
01ad0                 | '             pStatVal := @dcsFAULTED
01ad0     73 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #115
01ad4     73 05 03 F6 | 	mov	local03, ptr__isp_steering_2wheel_dat__
01ad8     25 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #37
01adc     73 05 63 FC | 	wrlong	local03, ptr__isp_steering_2wheel_dat__
01ae0     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01ae4     3C 00 90 FD | 	jmp	#LR__0090
01ae8                 | LR__0088
01ae8                 | '         DCS_ESTOP:
01ae8                 | '             pStatVal := @dcsESTOP
01ae8     7E E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #126
01aec     73 05 03 F6 | 	mov	local03, ptr__isp_steering_2wheel_dat__
01af0     1A E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #26
01af4     73 05 63 FC | 	wrlong	local03, ptr__isp_steering_2wheel_dat__
01af8     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01afc     24 00 90 FD | 	jmp	#LR__0090
01b00                 | LR__0089
01b00                 | '         other:
01b00                 | '             placeAsciiDigits(@dcsOtherVal, eState)
01b00     73 F7 02 F6 | 	mov	arg01, ptr__isp_steering_2wheel_dat__
01b04     8D F6 06 F1 | 	add	arg01, #141
01b08     80 F9 02 F6 | 	mov	arg02, local01
01b0c     48 01 B0 FD | 	call	#_isp_steering_2wheel_placeAsciiDigits
01b10                 | '             pStatVal := @dcsOther
01b10     87 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #135
01b14     73 05 03 F6 | 	mov	local03, ptr__isp_steering_2wheel_dat__
01b18     11 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #17
01b1c     73 05 63 FC | 	wrlong	local03, ptr__isp_steering_2wheel_dat__
01b20     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01b24                 | LR__0090
01b24     81 01 00 F6 | 	mov	0-0, local02
01b28     98 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #152
01b2c     73 05 03 FB | 	rdlong	local03, ptr__isp_steering_2wheel_dat__
01b30     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01b34     82 03 00 F6 | 	mov	1-0, local03
01b38     36 38 64 FD | 	brk	#28
01b3c     27 F1 03 F6 | 	mov	ptra, fp
01b40     32 01 A0 FD | 	call	#popregs_
01b44                 | _isp_steering_2wheel_showDriverState_ret
01b44     2D 00 64 FD | 	ret
01b48                 | 
01b48                 | ' 
01b48                 | ' PRI showStatus(eStatus, pMsg)
01b48                 | _isp_steering_2wheel_showStatus
01b48     03 4A 06 F6 | 	mov	COUNT_, #3
01b4c     28 01 A0 FD | 	call	#pushregs_
01b50     7B 01 03 F6 | 	mov	local01, arg01
01b54     7C 03 03 F6 | 	mov	local02, arg02
01b58                 | '     case eStatus
01b58     80 05 03 F6 | 	mov	local03, local01
01b5c     0A 04 87 F1 | 	sub	local03, #10
01b60     04 04 27 F3 | 	fle	local03, #4
01b64     30 04 63 FD | 	jmprel	local03
01b68                 | LR__0100
01b68     10 00 90 FD | 	jmp	#LR__0101
01b6c     24 00 90 FD | 	jmp	#LR__0102
01b70     38 00 90 FD | 	jmp	#LR__0103
01b74     4C 00 90 FD | 	jmp	#LR__0104
01b78     60 00 90 FD | 	jmp	#LR__0105
01b7c                 | LR__0101
01b7c                 | '         DS_Unknown:
01b7c                 | '             pStatVal := @dsUnknown
01b7c     08 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #8
01b80     73 05 03 F6 | 	mov	local03, ptr__isp_steering_2wheel_dat__
01b84     90 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #144
01b88     73 05 63 FC | 	wrlong	local03, ptr__isp_steering_2wheel_dat__
01b8c     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01b90     6C 00 90 FD | 	jmp	#LR__0106
01b94                 | LR__0102
01b94                 | '         DS_MOVING:
01b94                 | '             pStatVal := @dsMOVING
01b94     0E E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #14
01b98     73 05 03 F6 | 	mov	local03, ptr__isp_steering_2wheel_dat__
01b9c     8A E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #138
01ba0     73 05 63 FC | 	wrlong	local03, ptr__isp_steering_2wheel_dat__
01ba4     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01ba8     54 00 90 FD | 	jmp	#LR__0106
01bac                 | LR__0103
01bac                 | '         DS_HOLDING:
01bac                 | '             pStatVal := @dsHOLDING
01bac     14 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #20
01bb0     73 05 03 F6 | 	mov	local03, ptr__isp_steering_2wheel_dat__
01bb4     84 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #132
01bb8     73 05 63 FC | 	wrlong	local03, ptr__isp_steering_2wheel_dat__
01bbc     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01bc0     3C 00 90 FD | 	jmp	#LR__0106
01bc4                 | LR__0104
01bc4                 | '         DS_OFF:
01bc4                 | '             pStatVal := @dsOFF
01bc4     1A E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #26
01bc8     73 05 03 F6 | 	mov	local03, ptr__isp_steering_2wheel_dat__
01bcc     7E E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #126
01bd0     73 05 63 FC | 	wrlong	local03, ptr__isp_steering_2wheel_dat__
01bd4     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01bd8     24 00 90 FD | 	jmp	#LR__0106
01bdc                 | LR__0105
01bdc                 | '         other:
01bdc                 | '             placeAsciiDigits(@dsOtherVal, eStatus)
01bdc     73 F7 02 F6 | 	mov	arg01, ptr__isp_steering_2wheel_dat__
01be0     25 F6 06 F1 | 	add	arg01, #37
01be4     80 F9 02 F6 | 	mov	arg02, local01
01be8     6C 00 B0 FD | 	call	#_isp_steering_2wheel_placeAsciiDigits
01bec                 | '             pStatVal := @dsOther
01bec     20 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #32
01bf0     73 05 03 F6 | 	mov	local03, ptr__isp_steering_2wheel_dat__
01bf4     78 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #120
01bf8     73 05 63 FC | 	wrlong	local03, ptr__isp_steering_2wheel_dat__
01bfc     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01c00                 | LR__0106
01c00     81 01 00 F6 | 	mov	0-0, local02
01c04     98 E6 06 F1 | 	add	ptr__isp_steering_2wheel_dat__, #152
01c08     73 05 03 FB | 	rdlong	local03, ptr__isp_steering_2wheel_dat__
01c0c     98 E6 86 F1 | 	sub	ptr__isp_steering_2wheel_dat__, #152
01c10     82 03 00 F6 | 	mov	1-0, local03
01c14     36 3A 64 FD | 	brk	#29
01c18     27 F1 03 F6 | 	mov	ptra, fp
01c1c     32 01 A0 FD | 	call	#popregs_
01c20                 | _isp_steering_2wheel_showStatus_ret
01c20     2D 00 64 FD | 	ret
01c24                 | 
01c24                 | ' 
01c24                 | ' PRI showFaultStatus(bStatus, pMsg, bForceOutput)
01c24                 | _isp_steering_2wheel_showFaultStatus
01c24                 | '     if bStatus == true
01c24     FF FF 7F FF 
01c28     FF F7 0E F2 | 	cmp	arg01, ##-1 wz
01c2c     0C 00 90 5D |  if_ne	jmp	#LR__0110
01c30     7C 01 00 F6 | 	mov	0-0, arg02
01c34     36 3C 64 FD | 	brk	#30
01c38     18 00 90 FD | 	jmp	#LR__0112
01c3c                 | LR__0110
01c3c                 | '     elseif bStatus == false and bForceOutput == true
01c3c     00 F6 0E F2 | 	cmp	arg01, #0 wz
01c40     FF FF 7F AF 
01c44     FF FB 0E A2 |  if_e	cmp	arg03, ##-1 wz
01c48     08 00 90 5D |  if_ne	jmp	#LR__0111
01c4c     7C 01 00 F6 | 	mov	0-0, arg02
01c50     36 3E 64 FD | 	brk	#31
01c54                 | LR__0111
01c54                 | LR__0112
01c54                 | _isp_steering_2wheel_showFaultStatus_ret
01c54     2D 00 64 FD | 	ret
01c58                 | 
01c58                 | ' 
01c58                 | ' PRI placeAsciiDigits(pStrBytes, byt) | hiNyb, lowNyb
01c58                 | _isp_steering_2wheel_placeAsciiDigits
01c58     7C F1 42 F8 | 	getnib	_var01, arg02, #0
01c5c     30 F0 06 F1 | 	add	_var01, #48
01c60                 | '         hiNyb := byt & $f0 >> 4 + $30
01c60                 | '         if hiNyb > $39
01c60     3A F0 56 F2 | 	cmps	_var01, #58 wc
01c64                 | '             hiNyb += 7
01c64     07 F0 06 31 |  if_ae	add	_var01, #7
01c68     7C F9 42 F8 | 	getnib	arg02, arg02, #0
01c6c     30 F8 06 F1 | 	add	arg02, #48
01c70                 | '         lowNyb := byt & $0f      + $30
01c70                 | '         if lowNyb > $39
01c70     3A F8 56 F2 | 	cmps	arg02, #58 wc
01c74                 | '             lowNyb += 7
01c74     07 F8 06 31 |  if_ae	add	arg02, #7
01c78                 | '         BYTE [pStrBytes][0] := hiNyb
01c78     7B F1 42 FC | 	wrbyte	_var01, arg01
01c7c                 | '         BYTE [pStrBytes][1] := lowNyb
01c7c     01 F6 06 F1 | 	add	arg01, #1
01c80     7B F9 42 FC | 	wrbyte	arg02, arg01
01c84                 | _isp_steering_2wheel_placeAsciiDigits_ret
01c84     2D 00 64 FD | 	ret
01c88                 | 
01c88                 | ' 
01c88                 | ' PUB startEx(eMotorBasePin, eMotorVoltage, eDetectionMode, sync) : ok | legalBase
01c88                 | _isp_bldc_motor_startEx
01c88                 | ' '' Specify motor control board connect location for this motor and start the driver, specify sync setting
01c88                 | ' 
01c88                 | '     sync_required := sync
01c88     03 00 00 FF 
01c8c     08 E5 06 F1 | 	add	ptr__isp_bldc_motor_dat__, ##1800
01c90     72 FD 62 FC | 	wrlong	arg04, ptr__isp_bldc_motor_dat__
01c94     03 00 00 FF 
01c98     08 E5 86 F1 | 	sub	ptr__isp_bldc_motor_dat__, ##1800
01c9c                 | '     init(eMotorBasePin, eMotorVoltage, eDetectionMode)  ' setup runtime constants
01c9c     8C 01 B0 FD | 	call	#_isp_bldc_motor_init
01ca0     01 00 00 FF 
01ca4     D7 E0 06 F1 | 	add	objptr, ##727
01ca8     70 FB 02 F6 | 	mov	arg03, objptr
01cac                 | '     params_ptr := @offset_fwd   ' point to driver variables
01cac     AC E0 86 F1 | 	sub	objptr, #172
01cb0     70 FB 62 FC | 	wrlong	arg03, objptr
01cb4     01 00 00 FF 
01cb8     2B E0 86 F1 | 	sub	objptr, ##555
01cbc                 | '     setTargetAccel(0, false)                            ' do NOT move at startup
01cbc     00 F6 06 F6 | 	mov	arg01, #0
01cc0     00 F8 06 F6 | 	mov	arg02, #0
01cc4     18 0D B0 FD | 	call	#_isp_bldc_motor_setTargetAccel
01cc8                 | ' 
01cc8                 | '     ok := motorCog := coginit(NEWCOG, @driver, @pinbase) + 1
01cc8     72 F9 02 F6 | 	mov	arg02, ptr__isp_bldc_motor_dat__
01ccc     C0 F9 06 F1 | 	add	arg02, #448
01cd0     70 FB 02 F6 | 	mov	arg03, objptr
01cd4     01 00 00 FF 
01cd8     27 FA 06 F1 | 	add	arg03, ##551
01cdc     10 EA 06 F6 | 	mov	result1, #16
01ce0     28 FA 62 FD | 	setq	arg03
01ce4     7C EB F2 FC | 	coginit	result1, arg02 wc
01ce8     01 EA 66 C6 |  if_b	neg	result1, #1
01cec     01 EA 06 F1 | 	add	result1, #1
01cf0     75 FB 0A F6 | 	mov	arg03, result1 wz
01cf4     01 00 00 FF 
01cf8     17 E0 06 F1 | 	add	objptr, ##535
01cfc     70 FB 62 FC | 	wrlong	arg03, objptr
01d00                 | '     if motorCog == 0    ' did fail?
01d00     01 00 00 FF 
01d04     17 E0 86 F1 | 	sub	objptr, ##535
01d08     08 00 90 5D |  if_ne	jmp	#LR__0120
01d0c     36 40 64 FD | 	brk	#32
01d10     20 00 90 FD | 	jmp	#LR__0121
01d14                 | LR__0120
01d14                 | '     else
01d14     01 00 00 FF 
01d18     17 E0 06 F1 | 	add	objptr, ##535
01d1c     70 EB 02 FB | 	rdlong	result1, objptr
01d20     01 00 00 FF 
01d24     17 E0 86 F1 | 	sub	objptr, ##535
01d28     01 EA 86 F1 | 	sub	result1, #1
01d2c     75 01 00 F6 | 	mov	0-0, result1
01d30     36 42 64 FD | 	brk	#33
01d34                 | LR__0121
01d34     7D EB 02 F6 | 	mov	result1, arg03
01d38                 | _isp_bldc_motor_startEx_ret
01d38     2D 00 64 FD | 	ret
01d3c                 | 
01d3c                 | ' 
01d3c                 | ' PUB stop()
01d3c                 | _isp_bldc_motor_stop
01d3c                 | ' '' Stop cogs and release pins assigned to this motor
01d3c                 | ' 
01d3c                 | '     if motorCog     ' stop motor drive
01d3c     01 00 00 FF 
01d40     17 E0 06 F1 | 	add	objptr, ##535
01d44     70 F7 0A FB | 	rdlong	arg01, objptr wz
01d48     01 00 00 FF 
01d4c     17 E0 86 F1 | 	sub	objptr, ##535
01d50     01 F6 86 51 |  if_ne	sub	arg01, #1
01d54                 | '         cogstop(motorCog - 1)
01d54     03 F6 62 5D |  if_ne	cogstop	arg01
01d58                 | '         motorCog := 0
01d58     01 00 00 5F 
01d5c     17 E0 06 51 |  if_ne	add	objptr, ##535
01d60     70 01 68 5C |  if_ne	wrlong	#0, objptr
01d64     01 00 00 5F 
01d68     17 E0 86 51 |  if_ne	sub	objptr, ##535
01d6c                 | ' 
01d6c                 | '     if senseCog     ' stop motor reads
01d6c     01 00 00 FF 
01d70     1B E0 06 F1 | 	add	objptr, ##539
01d74     70 F7 0A FB | 	rdlong	arg01, objptr wz
01d78     01 00 00 FF 
01d7c     1B E0 86 F1 | 	sub	objptr, ##539
01d80     01 F6 86 51 |  if_ne	sub	arg01, #1
01d84                 | '         cogstop(senseCog - 1)
01d84     03 F6 62 5D |  if_ne	cogstop	arg01
01d88                 | '         senseCog := 0
01d88     01 00 00 5F 
01d8c     1B E0 06 51 |  if_ne	add	objptr, ##539
01d90     70 01 68 5C |  if_ne	wrlong	#0, objptr
01d94     01 00 00 5F 
01d98     1B E0 86 51 |  if_ne	sub	objptr, ##539
01d9c                 | ' 
01d9c                 | '     ' Bottom 8 pins are sensed, top 8 are driven, so clear only the top 8
01d9c                 | '     if pinbase <> VALUE_NOT_SET
01d9c     01 00 00 FF 
01da0     27 E0 06 F1 | 	add	objptr, ##551
01da4     70 F7 02 FB | 	rdlong	arg01, objptr
01da8     01 00 00 FF 
01dac     27 E0 86 F1 | 	sub	objptr, ##551
01db0     FF FF 7F FF 
01db4     FF F7 0E F2 | 	cmp	arg01, ##-1 wz
01db8     28 00 90 AD |  if_e	jmp	#LR__0130
01dbc     08 F6 06 F1 | 	add	arg01, #8
01dc0     C0 F7 46 F5 | 	or	arg01, #448
01dc4                 | '         pinclear(pinbase+8 addpins 7)
01dc4     50 F6 62 FD | 	fltl	arg01
01dc8     7B 01 08 FC | 	wrpin	#0, arg01
01dcc                 | '         pinbase := VALUE_NOT_SET
01dcc     01 00 00 FF 
01dd0     27 E0 06 F1 | 	add	objptr, ##551
01dd4     FF FF FF FF 
01dd8     70 FF 6B FC | 	wrlong	##-1, objptr
01ddc     01 00 00 FF 
01de0     27 E0 86 F1 | 	sub	objptr, ##551
01de4                 | LR__0130
01de4                 | _isp_bldc_motor_stop_ret
01de4     2D 00 64 FD | 	ret
01de8                 | 
01de8                 | ' 
01de8                 | ' PRI validatePinBase(eMotorBasePin) : legalBase
01de8                 | _isp_bldc_motor_validatePinBase
01de8     02 4A 06 F6 | 	mov	COUNT_, #2
01dec     28 01 A0 FD | 	call	#pushregs_
01df0     7B 01 03 F6 | 	mov	local01, arg01
01df4                 | ' 
01df4                 | '   legalBase := VALUE_NOT_SET
01df4     01 02 67 F6 | 	neg	local02, #1
01df8                 | '   if lookdown(eMotorBasePin: PINS_P0_P15, PINS_P8_P23, PINS_P16_P31, PINS_P32_P47, PINS_P40_P55) <> 0
01df8     72 FB 02 F6 | 	mov	arg03, ptr__isp_bldc_motor_dat__
01dfc     03 00 00 FF 
01e00     98 FB 06 F1 | 	add	arg03, ##1944
01e04     80 F7 02 F6 | 	mov	arg01, local01
01e08     01 F8 06 F6 | 	mov	arg02, #1
01e0c     05 FC 06 F6 | 	mov	arg04, #5
01e10     50 13 B0 FD | 	call	#__system___lookdown
01e14     00 EA 0E F2 | 	cmp	result1, #0 wz
01e18                 | '     legalBase := eMotorBasePin
01e18     80 03 03 56 |  if_ne	mov	local02, local01
01e1c     81 EB 02 F6 | 	mov	result1, local02
01e20     27 F1 03 F6 | 	mov	ptra, fp
01e24     32 01 A0 FD | 	call	#popregs_
01e28                 | _isp_bldc_motor_validatePinBase_ret
01e28     2D 00 64 FD | 	ret
01e2c                 | 
01e2c                 | ' 
01e2c                 | ' PRI init(eMotorBasePin, eMotorVoltage, eDetectionMode) | fwdDegrees, revDegrees, gapInMS
01e2c                 | _isp_bldc_motor_init
01e2c     02 4A 06 F6 | 	mov	COUNT_, #2
01e30     28 01 A0 FD | 	call	#pushregs_
01e34     14 38 07 FB | 	rdlong	muldivb_, #20
01e38     9C 39 53 F6 | 	abs	muldivb_, muldivb_ wc
01e3c     01 00 00 FF 
01e40     E8 39 17 FD | 	qdiv	muldivb_, ##1000
01e44     7D 01 03 F6 | 	mov	local01, arg03
01e48     18 38 63 FD | 	getqx	muldivb_
01e4c     9C 39 83 F6 | 	negc	muldivb_, muldivb_
01e50     72 39 63 FC | 	wrlong	muldivb_, ptr__isp_bldc_motor_dat__
01e54     14 36 07 FB | 	rdlong	muldiva_, #20
01e58     9B 37 53 F6 | 	abs	muldiva_, muldiva_ wc
01e5c     A1 07 00 FF 
01e60     40 36 17 FD | 	qdiv	muldiva_, ##1000000
01e64                 | ' '' Specify motor control board connect location for this motor BUT DON'T start the driver
01e64                 | '     ticks1ms   := (CLKFREQ / 1_000)
01e64     18 36 63 FD | 	getqx	muldiva_
01e68     F4 39 07 FD | 	qmul	muldivb_, #500
01e6c     9B 37 83 F6 | 	negc	muldiva_, muldiva_
01e70                 | '     ticks1us   := (CLKFREQ / 1_000_000)
01e70     04 E4 06 F1 | 	add	ptr__isp_bldc_motor_dat__, #4
01e74     72 37 63 FC | 	wrlong	muldiva_, ptr__isp_bldc_motor_dat__
01e78     18 36 63 FD | 	getqx	muldiva_
01e7c     9B 37 53 F6 | 	abs	muldiva_, muldiva_ wc
01e80     01 00 00 FF 
01e84     E8 37 17 FD | 	qdiv	muldiva_, ##1000
01e88     18 36 63 FD | 	getqx	muldiva_
01e8c     7D 38 07 FD | 	qmul	muldivb_, #125
01e90     9B 39 83 F6 | 	negc	muldivb_, muldiva_
01e94                 | '     ticks500us := (ticks1ms * 500) / 1_000  ' phrased this way for better result
01e94     04 E4 06 F1 | 	add	ptr__isp_bldc_motor_dat__, #4
01e98     72 39 63 FC | 	wrlong	muldivb_, ptr__isp_bldc_motor_dat__
01e9c                 | '     ticks125ms := ticks1ms * 125
01e9c     04 E4 06 F1 | 	add	ptr__isp_bldc_motor_dat__, #4
01ea0                 | ' 
01ea0                 | '     ' set up debug variables
01ea0                 | '     useDebug := FALSE
01ea0     3C E0 06 F1 | 	add	objptr, #60
01ea4                 | '     showHDMIDebug := FALSE
01ea4                 | '     pinbase := validatePinBase(eMotorBasePin)           ' record base pin number
01ea4     18 38 63 FD | 	getqx	muldivb_
01ea8     72 39 63 FC | 	wrlong	muldivb_, ptr__isp_bldc_motor_dat__
01eac     0C E4 86 F1 | 	sub	ptr__isp_bldc_motor_dat__, #12
01eb0     70 01 68 FC | 	wrlong	#0, objptr
01eb4     04 E0 06 F1 | 	add	objptr, #4
01eb8     70 01 68 FC | 	wrlong	#0, objptr
01ebc     40 E0 86 F1 | 	sub	objptr, #64
01ec0     24 FF BF FD | 	call	#_isp_bldc_motor_validatePinBase
01ec4     01 00 00 FF 
01ec8     27 E0 06 F1 | 	add	objptr, ##551
01ecc     70 EB 62 FC | 	wrlong	result1, objptr
01ed0     01 00 00 FF 
01ed4     27 E0 86 F1 | 	sub	objptr, ##551
01ed8                 | ' 
01ed8                 | '     eUserDetectionMode, bUserForced := getInternalDetectMode(eDetectionMode)
01ed8     80 F7 02 F6 | 	mov	arg01, local01
01edc     14 09 B0 FD | 	call	#_isp_bldc_motor_getInternalDetectMode
01ee0     75 01 03 F6 | 	mov	local01, result1
01ee4     76 39 03 F6 | 	mov	muldivb_, result2
01ee8     08 E0 06 F1 | 	add	objptr, #8
01eec     70 01 63 FC | 	wrlong	local01, objptr
01ef0     08 E0 06 F1 | 	add	objptr, #8
01ef4     70 39 63 FC | 	wrlong	muldivb_, objptr
01ef8     10 E0 86 F1 | 	sub	objptr, #16
01efc                 | ' 
01efc                 | '     ' set the mode now used by the driver to condition things (current-sense scaling, etc.)
01efc                 | ' 
01efc                 | '     eDetectedBoard := getBoardType()
01efc     60 05 B0 FD | 	call	#_isp_bldc_motor_getBoardType
01f00     0C E0 06 F1 | 	add	objptr, #12
01f04     70 EB 62 FC | 	wrlong	result1, objptr
01f08                 | ' 
01f08                 | '     bResetSenseData := FALSE
01f08     D3 E1 06 F1 | 	add	objptr, #467
01f0c     70 01 68 FC | 	wrlong	#0, objptr
01f10     8F E1 86 F1 | 	sub	objptr, #399
01f14                 | ' 
01f14                 | '     byte[@motorId] := 0 ' terminate an empty string
01f14     70 01 48 FC | 	wrbyte	#0, objptr
01f18                 | ' 
01f18                 | '     targetAngle := $FFFFFFFF    ' set to not used! (other values only used during testing)
01f18     DF E1 06 F1 | 	add	objptr, #479
01f1c     FF FF FF FF 
01f20     70 FF 6B FC | 	wrlong	##-1, objptr
01f24                 | ' 
01f24                 | '     degrPerTic, hallTicsPerRotation := hallTicInfoForMotor()
01f24                 | ' '' Return numbers for user selected motor (for use by two-wheel-steering object!)
01f24                 | '     if user.MOTOR_TYPE == user.MOTR_DOCO_4KRPM
01f24                 | '         ' degrees = ticks * 4
01f24                 | '         degreesPerTic := 4
01f24                 | '         ' rotations = ticks / 90
01f24                 | '         ticsPerRotation := 90
01f24     EB E1 86 F1 | 	sub	objptr, #491
01f28     70 09 68 FC | 	wrlong	#4, objptr
01f2c     04 E0 06 F1 | 	add	objptr, #4
01f30     70 B5 68 FC | 	wrlong	#90, objptr
01f34     48 E0 86 F1 | 	sub	objptr, #72
01f38                 | ' 
01f38                 | '     fwdDegrees, revDegrees := offsetsForMotor(user.MOTOR_TYPE)
01f38     00 F6 06 F6 | 	mov	arg01, #0
01f3c     FC 07 B0 FD | 	call	#_isp_bldc_motor_offsetsForMotor
01f40     75 01 03 F6 | 	mov	local01, result1
01f44                 | '     offset_fwd  := fwdDegrees frac 360
01f44     68 FB 06 F6 | 	mov	arg03, #360
01f48     00 F8 06 F6 | 	mov	arg02, #0
01f4c     28 00 63 FD | 	setq	local01
01f50     7D F9 12 FD | 	qdiv	arg02, arg03
01f54     01 00 00 FF 
01f58     D7 E0 06 F1 | 	add	objptr, ##727
01f5c                 | '     offset_rev  := revDegrees frac 360
01f5c     18 EA 62 FD | 	getqx	result1
01f60     70 EB 62 FC | 	wrlong	result1, objptr
01f64     28 EC 62 FD | 	setq	result2
01f68     7D F9 12 FD | 	qdiv	arg02, arg03
01f6c     04 E0 06 F1 | 	add	objptr, #4
01f70     18 F8 62 FD | 	getqx	arg02
01f74     70 F9 62 FC | 	wrlong	arg02, objptr
01f78     80 01 00 F6 | 	mov	0-0, local01
01f7c     75 03 00 F6 | 	mov	1-0, result1
01f80     36 44 64 FD | 	brk	#34
01f84     76 01 00 F6 | 	mov	0-0, result2
01f88     01 00 00 FF 
01f8c     DB E0 86 F1 | 	sub	objptr, ##731
01f90     7C 03 00 F6 | 	mov	1-0, arg02
01f94     36 46 64 FD | 	brk	#35
01f98                 | ' 
01f98                 | '     ' new build up our hall angle and position increment table for specific motor
01f98                 | '     if user.MOTOR_TYPE == MOTR_6_5_INCH
01f98     03 00 00 FF 
01f9c     58 E5 06 F1 | 	add	ptr__isp_bldc_motor_dat__, ##1880
01fa0     72 F7 02 F6 | 	mov	arg01, ptr__isp_bldc_motor_dat__
01fa4     03 00 00 FF 
01fa8     1A E4 86 F1 | 	sub	ptr__isp_bldc_motor_dat__, ##1562
01fac     72 F9 02 F6 | 	mov	arg02, ptr__isp_bldc_motor_dat__
01fb0     3E E5 86 F1 | 	sub	ptr__isp_bldc_motor_dat__, #318
01fb4                 | '         longmove(@hall_angles, @hltbAngles, 16)
01fb4     10 FA 06 F6 | 	mov	arg03, #16
01fb8     18 11 B0 FD | 	call	#__system__longmove
01fbc     03 00 00 FF 
01fc0     18 E5 06 F1 | 	add	ptr__isp_bldc_motor_dat__, ##1816
01fc4     72 F7 02 F6 | 	mov	arg01, ptr__isp_bldc_motor_dat__
01fc8     03 00 00 FF 
01fcc     5A E4 86 F1 | 	sub	ptr__isp_bldc_motor_dat__, ##1626
01fd0     72 F9 02 F6 | 	mov	arg02, ptr__isp_bldc_motor_dat__
01fd4     BE E4 86 F1 | 	sub	ptr__isp_bldc_motor_dat__, #190
01fd8                 | '         bytemove(@deltas, @deltas65, 64)
01fd8     40 FA 06 F6 | 	mov	arg03, #64
01fdc     64 10 B0 FD | 	call	#__system____builtin_memmove
01fe0     04 E4 06 F1 | 	add	ptr__isp_bldc_motor_dat__, #4
01fe4     72 01 03 FB | 	rdlong	local01, ptr__isp_bldc_motor_dat__
01fe8     2C 00 00 FF 
01fec     C7 00 07 FD | 	qmul	local01, ##22727
01ff0     18 00 63 FD | 	getqx	local01
01ff4     80 01 53 F6 | 	abs	local01, local01 wc
01ff8     01 00 00 FF 
01ffc     E8 01 17 FD | 	qdiv	local01, ##1000
02000                 | ' 
02000                 | ' ' average is middle plus deflection for forward or reverse
02000                 | ' '  responsiveness of motor to desire
02000                 | ' '  middle value is angular diff and motor postion relative to hall position
02000                 | ' '  deflection is direction and speed dependent
02000                 | '     frame_cnt := (ticks1us * (1_000_000_000 / PWM_RATE_IN_HZ)) / 1_000
02000     01 00 00 FF 
02004     0F E1 06 F1 | 	add	objptr, ##783
02008     18 00 63 FD | 	getqx	local01
0200c     80 01 83 F6 | 	negc	local01, local01
02010     70 01 63 FC | 	wrlong	local01, objptr
02014     80 01 00 F6 | 	mov	0-0, local01
02018     36 48 64 FD | 	brk	#36
0201c     03 00 00 FF 
02020     EC E4 06 F1 | 	add	ptr__isp_bldc_motor_dat__, ##1772
02024     72 01 63 FC | 	wrlong	local01, ptr__isp_bldc_motor_dat__
02028     70 01 03 FB | 	rdlong	local01, objptr
0202c     80 01 53 F6 | 	abs	local01, local01 wc
02030     01 00 47 F0 | 	shr	local01, #1
02034     80 01 83 F6 | 	negc	local01, local01
02038     10 00 67 F0 | 	shl	local01, #16
0203c     01 00 07 F1 | 	add	local01, #1
02040     04 E4 06 F1 | 	add	ptr__isp_bldc_motor_dat__, #4
02044     72 01 63 FC | 	wrlong	local01, ptr__isp_bldc_motor_dat__
02048     70 01 03 FB | 	rdlong	local01, objptr
0204c     80 01 53 F6 | 	abs	local01, local01 wc
02050     02 00 47 F0 | 	shr	local01, #2
02054     80 01 83 F6 | 	negc	local01, local01
02058     04 E4 06 F1 | 	add	ptr__isp_bldc_motor_dat__, #4
0205c     72 01 63 FC | 	wrlong	local01, ptr__isp_bldc_motor_dat__
02060     08 E4 86 F1 | 	sub	ptr__isp_bldc_motor_dat__, #8
02064     72 01 03 FB | 	rdlong	local01, ptr__isp_bldc_motor_dat__
02068     06 00 00 FF 
0206c     E4 00 07 FD | 	qmul	local01, ##3300
02070                 | ' 
02070                 | '     ' preload driver values before driver start
02070                 | '     adc_fram    :=    frame_cnt                         ' set ADC to full PWM frame counts
02070                 | '     fram        :=    (frame_cnt / 2) << 16 + 1         ' PWM frame: width=FRAME/2, div sysclk by 1 (no division)
02070                 | '     bias        :=    frame_cnt / 4                     ' PWM center-frame bias
02070     10 E4 06 F1 | 	add	ptr__isp_bldc_motor_dat__, #16
02074     01 00 00 FF 
02078     03 E1 86 F1 | 	sub	objptr, ##771
0207c     18 00 63 FD | 	getqx	local01
02080     72 01 63 FC | 	wrlong	local01, ptr__isp_bldc_motor_dat__
02084     70 01 03 FB | 	rdlong	local01, objptr
02088     20 00 0F F2 | 	cmp	local01, #32 wz
0208c     34 02 07 A6 |  if_e	mov	local02, #52
02090     04 03 07 56 |  if_ne	mov	local02, #260
02094     03 00 00 FF 
02098     FC E4 86 F1 | 	sub	ptr__isp_bldc_motor_dat__, ##1788
0209c     72 01 03 FB | 	rdlong	local01, ptr__isp_bldc_motor_dat__
020a0     81 01 03 FD | 	qmul	local01, local02
020a4                 | '     numerator   :=    3300 * adc_fram                   ' calculate the adc scaling based off the adc_fram count
020a4                 | ' 
020a4                 | '     ' setup driver parameters based on clock rate
020a4                 | '     if eDetectedBoard == BRD_REV_B
020a4                 | '         gapInMS:= 52
020a4                 | '     else
020a4                 | '         gapInMS:= 260
020a4     18 02 63 FD | 	getqx	local02
020a8     81 03 53 F6 | 	abs	local02, local02 wc
020ac     01 00 00 FF 
020b0     E8 03 17 FD | 	qdiv	local02, ##1000
020b4                 | '     dead_gap    := (ticks1us * gapInMS) / 1_000 ' (was OFFSET) 260 of these made into "value nS"
020b4     01 00 00 FF 
020b8     E3 E0 06 F1 | 	add	objptr, ##739
020bc                 | '     pwm_limit   := (frame_cnt / 2) - (dead_gap  / 2)    'PWM duty hard limit 1/2 freq of PWM
020bc     03 00 00 FF 
020c0     40 02 07 F6 | 	mov	local02, ##1600
020c4                 | ' 
020c4                 | '     ' .. and set up rest
020c4                 | '     ' orig higher power code used this
020c4                 | '     duty_min    := 100 << 4 #> (dead_gap / 2) << 4
020c4                 | '                                                         '    duty_min    := dead_gap << 4 #> dead_gap << 4
020c4                 | '                                                         ' Chip's new code adjusted this, why?
020c4                 | '                                                         '    duty_min    := 200 << 4 #> dead_gap << 4
020c4                 | '     duty_max    := (pwm_limit  << 4) / 2 <# pwm_limit << 4      ' ok
020c4                 | '                                                         'duty_max    := ((pwm_limit  << 4) / 4) * 3 <# pwm_limit << 4    ' BAD
020c4                 | '                                                         'duty_max    := ((pwm_limit  << 4) / 8) * 5 <# pwm_limit << 4    ' BAD
020c4                 | '     ' orig higher power code used this
020c4                 | '     duty_up     := 18
020c4                 | '     duty_dn     := 4
020c4                 | '                                                         ' Chip's new code adjusted this, why?
020c4                 | '                                                         '    duty_up     := 8   ' this drops our top-end power by 45%
020c4                 | '                                                         '    duty_dn     := 2
020c4                 | '     cfg_ctcks   := ticks500us                           ' drive control loop period
020c4     04 E4 06 F1 | 	add	ptr__isp_bldc_motor_dat__, #4
020c8                 | '     stop_mode   := SM_FLOAT                             ' enum: [SM_FLOAT, SM_BRAKE]
020c8                 | '     e_stop      := FALSE
020c8                 | '     ' NOTES: 220410 -  at 18.5v 50_000 seems to fault a lot on gravel surface (i'm switching) to 40_000 and PWR_14p8V to see if motors stay operational
020c8                 | '     ' NOTES: 220410 -  at 14.8V 40_000 seems to fault a lot on gravel surface (i'm switching) to 10_000 and PWR_14p8V to see if motors stay operational (5_000 dog slow)
020c8                 | '     ' NOTES: 220413 -  at 14.8V 10_000 better on gravel surface  but too slow a ramp to 15_000 and PWR_14p8V to see if motors stay operational
020c8                 | '     ' 50_000 for 12v & 18_5v
020c8                 | '     '   ramp_min - start ramping at this value
020c8                 | '     '   ramp_max - max ramping at this value, once reach this value, keep incrementing with this value
020c8                 | '     '   ramp_inc - ramping increment, added to ramp_min every 500us. Effectively defines the acceleration
020c8                 | '     ramp_max := 200_000                                 ' 200k angle max increment/decrement
020c8                 | '     ramp_min := 1_500                                   ' 1k5 angle min increment: start add this every 500 uSec to ramp up from zero
020c8                 | '     ramp_inc := 22                                      ' increment to ramping speed, add to ramp_min every 500us until ramp_max reached
020c8                 | '     ramp_down := 50_000                                 ' fixed ramp down speed
020c8                 | ' 
020c8                 | '     motorIsReversed := FALSE    ' by default our motor direction is not reversed
020c8                 | '     fault := FALSE
020c8                 | ' 
020c8                 | '     ' init status variables
020c8                 | '     loop_ticks := 0
020c8                 | '     minDrvTics := 65535
020c8                 | '     drv_state := DCS_Unknown
020c8                 | ' 
020c8                 | '     maxSpeed := 75            ' [1-100] default 75
020c8                 | '     maxSpeed4dist := 75      ' [1-100] default 75
020c8                 | ' 
020c8                 | '     ' preset HDMI Monitor values
020c8                 | '     resetHdmiData()
020c8     18 F8 62 FD | 	getqx	arg02
020cc     7C F9 82 F6 | 	negc	arg02, arg02
020d0     70 F9 62 FC | 	wrlong	arg02, objptr
020d4     20 E0 06 F1 | 	add	objptr, #32
020d8     70 01 03 FB | 	rdlong	local01, objptr
020dc     80 01 53 F6 | 	abs	local01, local01 wc
020e0     01 00 47 F0 | 	shr	local01, #1
020e4     80 01 83 F6 | 	negc	local01, local01
020e8     7C 39 53 F6 | 	abs	muldivb_, arg02 wc
020ec     01 38 47 F0 | 	shr	muldivb_, #1
020f0     9C 01 A3 F3 | 	sumnc	local01, muldivb_
020f4     01 00 00 FF 
020f8     C3 E0 86 F1 | 	sub	objptr, ##707
020fc     70 01 63 FC | 	wrlong	local01, objptr
02100     7C F9 52 F6 | 	abs	arg02, arg02 wc
02104     01 F8 46 F0 | 	shr	arg02, #1
02108     7C F9 82 F6 | 	negc	arg02, arg02
0210c     04 F8 66 F0 | 	shl	arg02, #4
02110     7C 03 43 F3 | 	fges	local02, arg02
02114     01 00 00 FF 
02118     93 E0 06 F1 | 	add	objptr, ##659
0211c     70 03 63 FC | 	wrlong	local02, objptr
02120     04 00 67 F0 | 	shl	local01, #4
02124     80 03 53 F6 | 	abs	local02, local01 wc
02128     01 02 47 F0 | 	shr	local02, #1
0212c     81 03 83 F6 | 	negc	local02, local02
02130     80 03 63 F3 | 	fles	local02, local01
02134     04 E0 06 F1 | 	add	objptr, #4
02138     70 03 63 FC | 	wrlong	local02, objptr
0213c     04 E0 06 F1 | 	add	objptr, #4
02140     70 25 68 FC | 	wrlong	#18, objptr
02144     04 E0 06 F1 | 	add	objptr, #4
02148     70 09 68 FC | 	wrlong	#4, objptr
0214c     72 03 03 FB | 	rdlong	local02, ptr__isp_bldc_motor_dat__
02150     08 E4 86 F1 | 	sub	ptr__isp_bldc_motor_dat__, #8
02154     0C E0 06 F1 | 	add	objptr, #12
02158     70 03 63 FC | 	wrlong	local02, objptr
0215c     04 E0 06 F1 | 	add	objptr, #4
02160     70 03 68 FC | 	wrlong	#1, objptr
02164     04 E0 06 F1 | 	add	objptr, #4
02168     70 01 68 FC | 	wrlong	#0, objptr
0216c     04 E0 06 F1 | 	add	objptr, #4
02170     86 01 80 FF 
02174     70 81 6A FC | 	wrlong	##200000, objptr
02178     04 E0 06 F1 | 	add	objptr, #4
0217c     02 00 80 FF 
02180     70 B9 6B FC | 	wrlong	##1500, objptr
02184     04 E0 06 F1 | 	add	objptr, #4
02188     70 2D 68 FC | 	wrlong	#22, objptr
0218c     18 E0 86 F1 | 	sub	objptr, #24
02190     61 00 80 FF 
02194     70 A1 6A FC | 	wrlong	##50000, objptr
02198     01 00 00 FF 
0219c     BB E0 86 F1 | 	sub	objptr, ##699
021a0     70 01 68 FC | 	wrlong	#0, objptr
021a4     01 00 00 FF 
021a8     37 E0 06 F1 | 	add	objptr, ##567
021ac     70 01 68 FC | 	wrlong	#0, objptr
021b0     0C E0 86 F1 | 	sub	objptr, #12
021b4     70 01 68 FC | 	wrlong	#0, objptr
021b8     40 E0 86 F1 | 	sub	objptr, #64
021bc     7F 00 80 FF 
021c0     70 FF 6B FC | 	wrlong	##65535, objptr
021c4     48 E0 06 F1 | 	add	objptr, #72
021c8     70 01 68 FC | 	wrlong	#0, objptr
021cc     01 00 00 FF 
021d0     47 E0 86 F1 | 	sub	objptr, ##583
021d4     70 97 68 FC | 	wrlong	#75, objptr
021d8     04 E0 06 F1 | 	add	objptr, #4
021dc     70 97 68 FC | 	wrlong	#75, objptr
021e0     28 E0 86 F1 | 	sub	objptr, #40
021e4     4C 0A B0 FD | 	call	#_isp_bldc_motor_resetHdmiData
021e8                 | ' 
021e8                 | '     eUserSelectedVolts := VALUE_NOT_SET    ' ensure we don't drive motor unles we know the users' voltage!
021e8     FF FF FF FF 
021ec     70 FF 6B FC | 	wrlong	##-1, objptr
021f0     01 00 00 FF 
021f4     EF E0 06 F1 | 	add	objptr, ##751
021f8     70 03 03 FB | 	rdlong	local02, objptr
021fc     81 01 00 F6 | 	mov	0-0, local02
02200     01 00 00 FF 
02204     A3 E0 86 F1 | 	sub	objptr, ##675
02208     70 03 03 FB | 	rdlong	local02, objptr
0220c     81 03 00 F6 | 	mov	1-0, local02
02210     03 00 00 FF 
02214     F0 E4 06 F1 | 	add	ptr__isp_bldc_motor_dat__, ##1776
02218     72 03 03 FB | 	rdlong	local02, ptr__isp_bldc_motor_dat__
0221c     03 00 00 FF 
02220     F0 E4 86 F1 | 	sub	ptr__isp_bldc_motor_dat__, ##1776
02224     81 05 00 F6 | 	mov	2-0, local02
02228     01 00 00 FF 
0222c     93 E0 06 F1 | 	add	objptr, ##659
02230     70 03 03 FB | 	rdlong	local02, objptr
02234     81 07 00 F6 | 	mov	3-0, local02
02238     04 E0 06 F1 | 	add	objptr, #4
0223c     70 03 03 FB | 	rdlong	local02, objptr
02240     81 09 00 F6 | 	mov	4-0, local02
02244     36 4A 64 FD | 	brk	#37
02248     04 E0 06 F1 | 	add	objptr, #4
0224c     70 03 03 FB | 	rdlong	local02, objptr
02250     81 01 00 F6 | 	mov	0-0, local02
02254     04 E0 06 F1 | 	add	objptr, #4
02258     70 03 03 FB | 	rdlong	local02, objptr
0225c     81 03 00 F6 | 	mov	1-0, local02
02260     0C E0 06 F1 | 	add	objptr, #12
02264     70 03 03 FB | 	rdlong	local02, objptr
02268     81 05 00 F6 | 	mov	2-0, local02
0226c     36 4C 64 FD | 	brk	#38
02270                 | ' 
02270                 | '     if user.WHEEL_DIA_IN_INCH <> 0
02270                 | '         circInMM_x10 := distConv.circInMMforDiaInInchFloat(user.WHEEL_DIA_IN_INCH) * 10
02270     00 68 20 FF 
02274     00 F6 06 F6 | 	mov	arg01, ##1087373312
02278     1D E0 06 F1 | 	add	objptr, #29
0227c     28 0D B0 FD | 	call	#_isp_dist_utils_circInMMforDiaInInchFloat
02280     75 03 03 F6 | 	mov	local02, result1
02284     81 37 03 F6 | 	mov	muldiva_, local02
02288     02 36 67 F0 | 	shl	muldiva_, #2
0228c     81 37 03 F1 | 	add	muldiva_, local02
02290     01 36 67 F0 | 	shl	muldiva_, #1
02294     9D E0 86 F1 | 	sub	objptr, #157
02298     70 37 63 FC | 	wrlong	muldiva_, objptr
0229c     01 00 00 FF 
022a0     2F E0 86 F1 | 	sub	objptr, ##559
022a4     70 39 03 FB | 	rdlong	muldivb_, objptr
022a8     48 E0 86 F1 | 	sub	objptr, #72
022ac     3A 01 A0 FD | 	call	#divide_
022b0                 | '         tickInMM_x10 := circInMM_x10 / hallTicsPerRotation
022b0     01 00 00 FF 
022b4     7B E0 06 F1 | 	add	objptr, ##635
022b8     70 39 63 FC | 	wrlong	muldivb_, objptr
022bc     01 00 00 FF 
022c0     7B E0 86 F1 | 	sub	objptr, ##635
022c4                 | ' 
022c4                 | '     confgurePowerLimits(user.DRIVE_VOLTAGE)
022c4     06 F6 06 F6 | 	mov	arg01, #6
022c8     84 05 B0 FD | 	call	#_isp_bldc_motor_confgurePowerLimits
022cc                 | ' 
022cc                 | '     rSenseForBoard := VALUE_NOT_SET
022cc     01 00 00 FF 
022d0     13 E0 06 F1 | 	add	objptr, ##531
022d4     FF FF FF FF 
022d8     70 FF 6B FC | 	wrlong	##-1, objptr
022dc                 | '     if eDetectedBoard == REV_A
022dc     01 00 00 FF 
022e0     07 E0 86 F1 | 	sub	objptr, ##519
022e4     70 03 03 FB | 	rdlong	local02, objptr
022e8     0C E0 86 F1 | 	sub	objptr, #12
022ec     15 02 0F F2 | 	cmp	local02, #21 wz
022f0                 | '         rSenseForBoard := F_REV_A_RSENSE
022f0     01 00 00 AF 
022f4     13 E0 06 A1 |  if_e	add	objptr, ##531
022f8     70 0B 68 AC |  if_e	wrlong	#5, objptr
022fc     01 00 00 AF 
02300     13 E0 86 A1 |  if_e	sub	objptr, ##531
02304     24 00 90 AD |  if_e	jmp	#LR__0140
02308                 | '     elseif eDetectedBoard == REV_B
02308     0C E0 06 F1 | 	add	objptr, #12
0230c     70 03 03 FB | 	rdlong	local02, objptr
02310     0C E0 86 F1 | 	sub	objptr, #12
02314     16 02 0F F2 | 	cmp	local02, #22 wz
02318                 | '         rSenseForBoard := F_REV_B_RSENSE
02318     01 00 00 AF 
0231c     13 E0 06 A1 |  if_e	add	objptr, ##531
02320     70 2D 69 AC |  if_e	wrlong	#150, objptr
02324     01 00 00 AF 
02328     13 E0 86 A1 |  if_e	sub	objptr, ##531
0232c                 | LR__0140
0232c     27 F1 03 F6 | 	mov	ptra, fp
02330     32 01 A0 FD | 	call	#popregs_
02334                 | _isp_bldc_motor_init_ret
02334     2D 00 64 FD | 	ret
02338                 | 
02338                 | ' 
02338                 | ' PUB driveAtPowerEx(power, sync) | limitPwr, motorIncre, correctedPower
02338                 | _isp_bldc_motor_driveAtPowerEx
02338     03 4A 06 F6 | 	mov	COUNT_, #3
0233c     28 01 A0 FD | 	call	#pushregs_
02340     7B 01 03 F6 | 	mov	local01, arg01
02344     7C 03 03 F6 | 	mov	local02, arg02
02348     64 04 67 F6 | 	neg	local03, #100
0234c     80 05 43 F3 | 	fges	local03, local01
02350     64 04 67 F3 | 	fles	local03, #100
02354                 | ' '' Control the speed and direction of this motor using the {power, [(-100) to 100]} input. (allow sync setting)
02354                 | ' '' Turns the motor on at {power}.
02354                 | ' '' AFFECTED BY:  setAcceleration(), setMaxSpeed(), holdAtStop()
02354                 | '     limitPwr :=  -100 #> power <# 100
02354                 | '     if limitPwr <> power
02354     80 05 0B F2 | 	cmp	local03, local01 wz
02358     08 00 90 AD |  if_e	jmp	#LR__0150
0235c     80 01 00 F6 | 	mov	0-0, local01
02360     36 4E 64 FD | 	brk	#39
02364                 | LR__0150
02364     50 E0 06 F1 | 	add	objptr, #80
02368     70 01 00 F6 | 	mov	0-0, objptr
0236c     82 03 00 F6 | 	mov	1-0, local03
02370     01 00 00 FF 
02374     B3 E0 06 F1 | 	add	objptr, ##691
02378     70 01 03 FB | 	rdlong	local01, objptr
0237c     80 05 00 F6 | 	mov	2-0, local01
02380     04 E0 06 F1 | 	add	objptr, #4
02384     70 01 03 FB | 	rdlong	local01, objptr
02388     80 07 00 F6 | 	mov	3-0, local01
0238c     36 50 64 FD | 	brk	#40
02390                 | '     motorPower := limitPwr := -maxSpeed #> limitPwr <# maxSpeed
02390     01 00 00 FF 
02394     E3 E0 86 F1 | 	sub	objptr, ##739
02398     70 01 03 FB | 	rdlong	local01, objptr
0239c     80 F9 62 F6 | 	neg	arg02, local01
023a0     82 F9 42 F3 | 	fges	arg02, local03
023a4     80 F9 62 F3 | 	fles	arg02, local01
023a8     10 E0 06 F1 | 	add	objptr, #16
023ac     70 F9 62 FC | 	wrlong	arg02, objptr
023b0                 | '     correctedPower := (motorIsReversed) ? 0 - limitPwr : limitPwr
023b0     04 E0 06 F1 | 	add	objptr, #4
023b4     70 05 0B FB | 	rdlong	local03, objptr wz
023b8     38 E0 86 F1 | 	sub	objptr, #56
023bc     7C F7 E2 F6 | 	negnz	arg01, arg02
023c0                 | '     motorIncre := incrementForPower(correctedPower)
023c0     D4 02 B0 FD | 	call	#_isp_bldc_motor_incrementForPower
023c4     75 F7 02 F6 | 	mov	arg01, result1
023c8                 | '     setTargetAccel(motorIncre, sync)
023c8     81 F9 02 F6 | 	mov	arg02, local02
023cc     10 06 B0 FD | 	call	#_isp_bldc_motor_setTargetAccel
023d0     27 F1 03 F6 | 	mov	ptra, fp
023d4     32 01 A0 FD | 	call	#popregs_
023d8                 | _isp_bldc_motor_driveAtPowerEx_ret
023d8     2D 00 64 FD | 	ret
023dc                 | 
023dc                 | ' 
023dc                 | ' PUB getStatus() : eStatus
023dc                 | _isp_bldc_motor_getStatus
023dc                 | ' '' Returns status of motor drive state for this motor: enumerated constant: DS_Unknown, DS_MOVING, DS_HOLDING, or DS_OFF
023dc                 | '     eStatus := DS_Unknown                               ' if not one of the following status
023dc     0A F0 06 F6 | 	mov	_var01, #10
023e0                 | '     if isStopped()
023e0                 | ' '' Return T/F where T means the motor is stopped
023e0                 | '     bState := (drv_state == DCS_STOPPED) ? true : false
023e0     01 00 00 FF 
023e4     6B E0 06 F1 | 	add	objptr, ##619
023e8     70 F3 02 FB | 	rdlong	_var02, objptr
023ec     01 00 00 FF 
023f0     6B E0 86 F1 | 	sub	objptr, ##619
023f4     01 F2 0E F2 | 	cmp	_var02, #1 wz
023f8     01 EA 66 A6 |  if_e	neg	result1, #1
023fc     00 EA 06 56 |  if_ne	mov	result1, #0
02400     00 EA 0E F2 | 	cmp	result1, #0 wz
02404     2C 00 90 AD |  if_e	jmp	#LR__0160
02408                 | '         if stop_mode == SM_BRAKE
02408     01 00 00 FF 
0240c     FB E0 06 F1 | 	add	objptr, ##763
02410     70 EB 02 FB | 	rdlong	result1, objptr
02414     01 00 00 FF 
02418     FB E0 86 F1 | 	sub	objptr, ##763
0241c     02 EA 0E F2 | 	cmp	result1, #2 wz
02420                 | '             eStatus := DS_HOLDING
02420     0C F0 06 A6 |  if_e	mov	_var01, #12
02424     30 00 90 AD |  if_e	jmp	#LR__0161
02428                 | '         elseif stop_mode == SM_FLOAT
02428     01 EA 0E F2 | 	cmp	result1, #1 wz
0242c                 | '             eStatus := DS_OFF
0242c     0D F0 06 A6 |  if_e	mov	_var01, #13
02430     24 00 90 FD | 	jmp	#LR__0161
02434                 | LR__0160
02434                 | '     elseif isReady()
02434                 | ' '' Return T/F where T means the motor cog is running
02434                 | '     bState := (drv_state <> DCS_Unknown) ? true : false
02434     01 00 00 FF 
02438     6B E0 06 F1 | 	add	objptr, ##619
0243c     70 F3 0A FB | 	rdlong	_var02, objptr wz
02440     01 00 00 FF 
02444     6B E0 86 F1 | 	sub	objptr, ##619
02448     01 EA 66 56 |  if_ne	neg	result1, #1
0244c     00 EA 06 A6 |  if_e	mov	result1, #0
02450     00 EA 0E F2 | 	cmp	result1, #0 wz
02454                 | '         eStatus := DS_MOVING
02454     0B F0 06 56 |  if_ne	mov	_var01, #11
02458                 | LR__0161
02458     78 EB 02 F6 | 	mov	result1, _var01
0245c                 | _isp_bldc_motor_getStatus_ret
0245c     2D 00 64 FD | 	ret
02460                 | 
02460                 | ' 
02460                 | ' PUB getBoardType() : eBoardRev | pSenseCommon, pinSum
02460                 | _isp_bldc_motor_getBoardType
02460     05 4A 06 F6 | 	mov	COUNT_, #5
02464     28 01 A0 FD | 	call	#pushregs_
02468                 | ' '' ID Revision of attached BLDC driver board
02468                 | '     ' returns one of REV_Unknown, REV_A, REV_B
02468                 | '     eBoardRev := REV_Unknown
02468     14 00 07 F6 | 	mov	local01, #20
0246c                 | '     ' if user is overriding detection then use users' override value
0246c                 | '      case eUserDetectionMode    ' setup by init()
0246c     08 E0 06 F1 | 	add	objptr, #8
02470     70 03 03 FB | 	rdlong	local02, objptr
02474     08 E0 86 F1 | 	sub	objptr, #8
02478     15 02 0F F2 | 	cmp	local02, #21 wz
0247c     0C 00 90 AD |  if_e	jmp	#LR__0170
02480     16 02 0F F2 | 	cmp	local02, #22 wz
02484     0C 00 90 AD |  if_e	jmp	#LR__0171
02488     10 00 90 FD | 	jmp	#LR__0172
0248c                 | LR__0170
0248c                 | '         REV_A:
0248c                 | '             eBoardRev := REV_A
0248c     15 00 07 F6 | 	mov	local01, #21
02490     BC 00 90 FD | 	jmp	#LR__0183
02494                 | LR__0171
02494                 | '         REV_B:
02494                 | '             eBoardRev := REV_B
02494     16 00 07 F6 | 	mov	local01, #22
02498     B4 00 90 FD | 	jmp	#LR__0183
0249c                 | LR__0172
0249c                 | '         other:
0249c                 | '             ' do we know the base pin of the board...??
0249c                 | '             if pinbase == VALUE_NOT_SET
0249c     01 00 00 FF 
024a0     27 E0 06 F1 | 	add	objptr, ##551
024a4     70 05 03 FB | 	rdlong	local03, objptr
024a8     01 00 00 FF 
024ac     27 E0 86 F1 | 	sub	objptr, ##551
024b0     FF FF 7F FF 
024b4     FF 05 0F F2 | 	cmp	local03, ##-1 wz
024b8     08 00 90 5D |  if_ne	jmp	#LR__0173
024bc     36 54 64 FD | 	brk	#42
024c0     8C 00 90 FD | 	jmp	#LR__0182
024c4                 | LR__0173
024c4                 | '             else
024c4                 | '                 ' yes, detect the board rev
024c4                 | '                 pinSum := 0
024c4     00 06 07 F6 | 	mov	local04, #0
024c8     01 00 00 FF 
024cc     27 E0 06 F1 | 	add	objptr, ##551
024d0     70 09 03 FB | 	rdlong	local05, objptr
024d4     01 00 00 FF 
024d8     27 E0 86 F1 | 	sub	objptr, ##551
024dc     04 08 07 F1 | 	add	local05, #4
024e0                 | '                 pSenseCommon := pinbase + 4
024e0                 | '                 'debug("BLDC: getBoardType() pinbase=(", udec_(pinbase), "), pSenseCommon=(", uhex_Long_(pSenseCommon), ")")
024e0                 | '                 pinhigh(pSenseCommon)                   ' charge 0.1uF capacitor on RevB boards
024e0     59 08 63 FD | 	drvh	local05
024e4                 | '                 waitms(1)
024e4     01 F6 06 F6 | 	mov	arg01, #1
024e8     08 0D B0 FD | 	call	#__system___waitms
024ec                 | '                 pinfloat(pSenseCommon)                  ' release the pin, ready to read state
024ec     50 08 63 FD | 	fltl	local05
024f0                 | ' 
024f0                 | '                 repeat 500                              ' check pin state 500 times, x = sum of results
024f0     17 13 48 FB | 	callpa	#(@LR__0176-@LR__0174)>>2,fcache_load_ptr_
024f4                 | LR__0174
024f4     F4 11 DC FC | 	rep	@LR__0177, #500
024f8                 | LR__0175
024f8                 | '                     pinSum += pinread(pSenseCommon)
024f8     84 F7 02 F6 | 	mov	arg01, local05
024fc     20 F6 CE F7 | 	test	arg01, #32 wz
02500     FF EB 02 56 |  if_ne	mov	result1, inb
02504     FE EB 02 A6 |  if_e	mov	result1, ina
02508     7B EB 42 F0 | 	shr	result1, arg01
0250c     06 F6 46 F0 | 	shr	arg01, #6
02510     7B EB 42 F7 | 	zerox	result1, arg01
02514     75 07 03 F1 | 	add	local04, result1
02518                 | LR__0176
02518                 | LR__0177
02518                 | '                 ' Handle the result!
02518                 | '                 ' Note: RevA will always be 0 due to a 1K pulldown on that board.
02518                 | '                 '       RevB count will vary with clkfreq (due to capacitor discharge)- typically in the range of 40 to 180
02518                 | '                 '       If no board attached, count will always be >250, and typically will be 500.
02518                 | '                 if pinSum == 0
02518     00 06 0F F2 | 	cmp	local04, #0 wz
0251c     10 00 90 5D |  if_ne	jmp	#LR__0178
02520     83 01 00 F6 | 	mov	0-0, local04
02524     36 56 64 FD | 	brk	#43
02528                 | '                     eBoardRev := REV_A
02528     15 00 07 F6 | 	mov	local01, #21
0252c     20 00 90 FD | 	jmp	#LR__0181
02530                 | LR__0178
02530                 | '                 elseif pinSum > 250
02530     FB 06 57 F2 | 	cmps	local04, #251 wc
02534     0C 00 90 CD |  if_b	jmp	#LR__0179
02538     83 01 00 F6 | 	mov	0-0, local04
0253c     36 58 64 FD | 	brk	#44
02540     0C 00 90 FD | 	jmp	#LR__0180
02544                 | LR__0179
02544                 | '                 else
02544     83 01 00 F6 | 	mov	0-0, local04
02548     36 5A 64 FD | 	brk	#45
0254c                 | '                     eBoardRev := REV_B
0254c     16 00 07 F6 | 	mov	local01, #22
02550                 | LR__0180
02550                 | LR__0181
02550                 | LR__0182
02550                 | LR__0183
02550     80 EB 02 F6 | 	mov	result1, local01
02554     27 F1 03 F6 | 	mov	ptra, fp
02558     32 01 A0 FD | 	call	#popregs_
0255c                 | _isp_bldc_motor_getBoardType_ret
0255c     2D 00 64 FD | 	ret
02560                 | 
02560                 | ' 
02560                 | ' PUB clearFaultSignal()
02560                 | _isp_bldc_motor_clearFaultSignal
02560                 | ' '' Reset top-level fault indicator
02560                 | ' ' used by two-wheel steering
02560                 | '     if fault
02560     01 00 00 FF 
02564     6F E0 06 F1 | 	add	objptr, ##623
02568     70 F1 0A FB | 	rdlong	_var01, objptr wz
0256c     01 00 00 FF 
02570     6F E0 86 F1 | 	sub	objptr, ##623
02574     18 00 90 AD |  if_e	jmp	#LR__0190
02578     36 5C 64 FD | 	brk	#46
0257c                 | '         fault := false
0257c     01 00 00 FF 
02580     6F E0 06 F1 | 	add	objptr, ##623
02584     70 01 68 FC | 	wrlong	#0, objptr
02588     01 00 00 FF 
0258c     6F E0 86 F1 | 	sub	objptr, ##623
02590                 | LR__0190
02590                 | _isp_bldc_motor_clearFaultSignal_ret
02590     2D 00 64 FD | 	ret
02594                 | 
02594                 | ' 
02594                 | ' PUB validVoltageForChoice(userVoltage) : legalVoltage
02594                 | _isp_bldc_motor_validVoltageForChoice
02594     01 4A 06 F6 | 	mov	COUNT_, #1
02598     28 01 A0 FD | 	call	#pushregs_
0259c                 | ' '' VALIDATE users' voltage choice returns legalVoltage or INVALID_VOLTAGE
0259c                 | '     legalVoltage := userVoltage
0259c     7B 01 03 F6 | 	mov	local01, arg01
025a0                 | '     if user.MOTOR_TYPE == MOTR_DOCO_4KRPM
025a0                 | '         if lookdown(userVoltage: PWR_6p0V..PWR_25p9V) == 0
025a0     72 FB 02 F6 | 	mov	arg03, ptr__isp_bldc_motor_dat__
025a4     03 00 00 FF 
025a8     C8 FB 06 F1 | 	add	arg03, ##1992
025ac     01 F8 06 F6 | 	mov	arg02, #1
025b0     09 FC 06 F6 | 	mov	arg04, #9
025b4     AC 0B B0 FD | 	call	#__system___lookdown
025b8     00 EA 0E F2 | 	cmp	result1, #0 wz
025bc                 | '             legalVoltage := INVALID_VOLTAGE
025bc     01 00 67 A6 |  if_e	neg	local01, #1
025c0     80 01 00 F6 | 	mov	0-0, local01
025c4     36 60 64 FD | 	brk	#48
025c8     80 EB 02 F6 | 	mov	result1, local01
025cc     27 F1 03 F6 | 	mov	ptra, fp
025d0     32 01 A0 FD | 	call	#popregs_
025d4                 | _isp_bldc_motor_validVoltageForChoice_ret
025d4     2D 00 64 FD | 	ret
025d8                 | 
025d8                 | ' 
025d8                 | ' PUB validDetectModeForChoice(userDetMode) : legalMode
025d8                 | _isp_bldc_motor_validDetectModeForChoice
025d8     01 4A 06 F6 | 	mov	COUNT_, #1
025dc     28 01 A0 FD | 	call	#pushregs_
025e0                 | ' '' VALIDATE users' detection mode choice returns legalMode or INVALID_DET_MODE
025e0                 | '     legalMode := userDetMode
025e0     7B 01 03 F6 | 	mov	local01, arg01
025e4                 | '     if lookdown(userDetMode: BRD_AUTO_DET..BRD_REV_B) == 0
025e4     72 FB 02 F6 | 	mov	arg03, ptr__isp_bldc_motor_dat__
025e8     03 00 00 FF 
025ec     F4 FB 06 F1 | 	add	arg03, ##2036
025f0     01 F8 06 F6 | 	mov	arg02, #1
025f4     03 FC 06 F6 | 	mov	arg04, #3
025f8     68 0B B0 FD | 	call	#__system___lookdown
025fc     00 EA 0E F2 | 	cmp	result1, #0 wz
02600                 | '         legalMode := INVALID_DET_MODE
02600     01 00 67 A6 |  if_e	neg	local01, #1
02604     80 01 00 F6 | 	mov	0-0, local01
02608     36 64 64 FD | 	brk	#50
0260c     80 EB 02 F6 | 	mov	result1, local01
02610     27 F1 03 F6 | 	mov	ptra, fp
02614     32 01 A0 FD | 	call	#popregs_
02618                 | _isp_bldc_motor_validDetectModeForChoice_ret
02618     2D 00 64 FD | 	ret
0261c                 | 
0261c                 | ' 
0261c                 | ' PRI map(inValue, inMin, inMax, outMin, outMax) : nResult | slope
0261c                 | _isp_bldc_motor_map
0261c                 | ' ' Maps inValue in range inMin..inMax to new value in range outMin..outMax
0261c                 | '     nResult := 0
0261c     00 EA 06 F6 | 	mov	result1, #0
02620                 | '     if (inValue > 0)
02620     01 F6 56 F2 | 	cmps	arg01, #1 wc
02624     18 00 90 CD |  if_b	jmp	#LR__0200
02628                 | '         ' treat positive values out-of-bounds
02628                 | '         if (inValue <= inMin)
02628     7C F7 5A F2 | 	cmps	arg01, arg02 wcz
0262c                 | '             nResult := outMin
0262c     7E EB 02 E6 |  if_be	mov	result1, arg04
02630     28 00 90 ED |  if_be	jmp	#LR__0203
02634                 | '         elseif (inValue >= inMax)
02634     7D F7 52 F2 | 	cmps	arg01, arg03 wc
02638                 | '             nResult :=  outMax
02638     7F EB 02 36 |  if_ae	mov	result1, arg05
0263c     1C 00 90 FD | 	jmp	#LR__0203
02640                 | LR__0200
02640                 | '     elseif (inValue < 0)
02640     00 F6 56 F2 | 	cmps	arg01, #0 wc
02644     14 00 90 3D |  if_ae	jmp	#LR__0202
02648                 | '         ' treat negative values out-of-bounds
02648                 | '         if (inValue >= inMin)
02648     7C F7 52 F2 | 	cmps	arg01, arg02 wc
0264c                 | '             nResult := outMin
0264c     7E EB 02 36 |  if_ae	mov	result1, arg04
02650     08 00 90 3D |  if_ae	jmp	#LR__0201
02654                 | '         elseif (inValue <= inMax)
02654     7D F7 5A F2 | 	cmps	arg01, arg03 wcz
02658                 | '             nResult :=  outMax
02658     7F EB 02 E6 |  if_be	mov	result1, arg05
0265c                 | LR__0201
0265c                 | LR__0202
0265c                 | LR__0203
0265c                 | '     ' NOT  out-of-bounds, so scale the inValue
0265c                 | '     if inValue <> 0 and nResult == 0
0265c     00 F6 0E F2 | 	cmp	arg01, #0 wz
02660     30 00 90 AD |  if_e	jmp	#LR__0204
02664     00 EA 0E F2 | 	cmp	result1, #0 wz
02668     28 00 90 5D |  if_ne	jmp	#LR__0204
0266c     7E FF 82 F1 | 	sub	arg05, arg04
02670     7C FB 82 F1 | 	sub	arg03, arg02
02674     7F 37 03 F6 | 	mov	muldiva_, arg05
02678     7D 39 03 F6 | 	mov	muldivb_, arg03
0267c     3A 01 A0 FD | 	call	#divide_
02680     7C F7 82 F1 | 	sub	arg01, arg02
02684     7B 39 03 FD | 	qmul	muldivb_, arg01
02688                 | '             slope := (outMax - outMin) / (inMax - inMin)
02688                 | '             nResult := outMin + slope * (inValue - inMin)
02688     18 38 63 FD | 	getqx	muldivb_
0268c     9C FD 02 F1 | 	add	arg04, muldivb_
02690     7E EB 02 F6 | 	mov	result1, arg04
02694                 | LR__0204
02694                 | _isp_bldc_motor_map_ret
02694     2D 00 64 FD | 	ret
02698                 | 
02698                 | '     'debug("- map() ", sdec_long(inValue - inMin), sdec_long(inMin) , sdec_long(inMax), sdec_long(inMax - inMin))
02698                 | '     'debug("-       ", sdec_long(slope), sdec_long(outMin) , sdec_long(outMax), sdec_long(outMax - outMin))
02698                 | '     'debug("- map() ", sdec_long(inValue) , " --> ", sdec_long(nResult))
02698                 | ' 
02698                 | ' PRI incrementForPower(nUserPower) : nMotorIncre
02698                 | _isp_bldc_motor_incrementForPower
02698     02 4A 06 F6 | 	mov	COUNT_, #2
0269c     28 01 A0 FD | 	call	#pushregs_
026a0     7B 01 03 F6 | 	mov	local01, arg01
026a4                 | ' ' translate -100 to +100 value to Incre value needed by motor
026a4                 | '     if eUserSelectedVolts == VALUE_NOT_SET
026a4     70 EB 02 FB | 	rdlong	result1, objptr
026a8     FF FF 7F FF 
026ac     FF EB 0E F2 | 	cmp	result1, ##-1 wz
026b0                 | '         abort
026b0     6C F7 02 A6 |  if_e	mov	arg01, abortchain
026b4     00 F8 06 A6 |  if_e	mov	arg02, #0
026b8     00 FA 06 A6 |  if_e	mov	arg03, #0
026bc     5A 01 A0 AD |  if_e	call	#__longjmp
026c0                 | ' 
026c0                 | '     if nUserPower < 0
026c0     00 00 57 F2 | 	cmps	local01, #0 wc
026c4     2C 00 90 3D |  if_ae	jmp	#LR__0210
026c8                 | '         ' map REV request
026c8                 | '         nMotorIncre := map(nUserPower, -1, -100, minRevIncreAtPwr, maxRevIncreAtPwr)
026c8     1C E0 06 F1 | 	add	objptr, #28
026cc     70 FD 02 FB | 	rdlong	arg04, objptr
026d0     04 E0 06 F1 | 	add	objptr, #4
026d4     70 FF 02 FB | 	rdlong	arg05, objptr
026d8     20 E0 86 F1 | 	sub	objptr, #32
026dc     80 F7 02 F6 | 	mov	arg01, local01
026e0     01 F8 66 F6 | 	neg	arg02, #1
026e4     64 FA 66 F6 | 	neg	arg03, #100
026e8     30 FF BF FD | 	call	#_isp_bldc_motor_map
026ec     75 03 03 F6 | 	mov	local02, result1
026f0     38 00 90 FD | 	jmp	#LR__0213
026f4                 | LR__0210
026f4                 | '     elseif nUserPower > 0
026f4     01 00 57 F2 | 	cmps	local01, #1 wc
026f8     2C 00 90 CD |  if_b	jmp	#LR__0211
026fc                 | '         ' map FWD request
026fc                 | '         nMotorIncre := map(nUserPower, +1, +100, minFwdIncreAtPwr, maxFwdIncreAtPwr)
026fc     14 E0 06 F1 | 	add	objptr, #20
02700     70 FD 02 FB | 	rdlong	arg04, objptr
02704     04 E0 06 F1 | 	add	objptr, #4
02708     70 FF 02 FB | 	rdlong	arg05, objptr
0270c     18 E0 86 F1 | 	sub	objptr, #24
02710     80 F7 02 F6 | 	mov	arg01, local01
02714     01 F8 06 F6 | 	mov	arg02, #1
02718     64 FA 06 F6 | 	mov	arg03, #100
0271c     FC FE BF FD | 	call	#_isp_bldc_motor_map
02720     75 03 03 F6 | 	mov	local02, result1
02724     04 00 90 FD | 	jmp	#LR__0212
02728                 | LR__0211
02728                 | '     else
02728                 | '         ' this is a STOP request
02728                 | '         nMotorIncre := 0    ' stop!
02728     00 02 07 F6 | 	mov	local02, #0
0272c                 | LR__0212
0272c                 | LR__0213
0272c     81 EB 02 F6 | 	mov	result1, local02
02730     27 F1 03 F6 | 	mov	ptra, fp
02734     32 01 A0 FD | 	call	#popregs_
02738                 | _isp_bldc_motor_incrementForPower_ret
02738     2D 00 64 FD | 	ret
0273c                 | 
0273c                 | ' 
0273c                 | ' PRI offsetsForMotor(eMotorType) : fwdDegrees, revDegrees | ofsDegr, index
0273c                 | _isp_bldc_motor_offsetsForMotor
0273c     04 4A 06 F6 | 	mov	COUNT_, #4
02740     28 01 A0 FD | 	call	#pushregs_
02744                 | '     case eMotorType
02744     01 F6 0E F2 | 	cmp	arg01, #1 wz
02748     8C 00 90 5D |  if_ne	jmp	#LR__0222
0274c                 | '       MOTR_DOCO_4KRPM:
0274c                 | '         index := lookdown(user.DRIVE_VOLTAGE: PWR_7p4V..PWR_24p0V)
0274c     72 FB 02 F6 | 	mov	arg03, ptr__isp_bldc_motor_dat__
02750     04 00 00 FF 
02754     00 FA 06 F1 | 	add	arg03, ##2048
02758     06 F6 06 F6 | 	mov	arg01, #6
0275c     01 F8 06 F6 | 	mov	arg02, #1
02760     07 FC 06 F6 | 	mov	arg04, #7
02764     FC 09 B0 FD | 	call	#__system___lookdown
02768     75 01 03 F6 | 	mov	local01, result1
0276c                 | '         ' 15 degrees per tic so +- 15 is our offset?
0276c                 | ' {
0276c                 | ' }
0276c                 | '         if eDetectedBoard == REV_B
0276c     0C E0 06 F1 | 	add	objptr, #12
02770     70 FD 02 FB | 	rdlong	arg04, objptr
02774     0C E0 86 F1 | 	sub	objptr, #12
02778     16 FC 0E F2 | 	cmp	arg04, #22 wz
0277c     72 FB 02 F6 | 	mov	arg03, ptr__isp_bldc_motor_dat__
02780     24 00 90 5D |  if_ne	jmp	#LR__0220
02784                 | '           if (ofsDegr := lookup(index: 33, 33, 39, 40, 36, 37, 45)) == 0
02784     04 00 00 FF 
02788     1C FA 06 F1 | 	add	arg03, ##2076
0278c     80 F7 02 F6 | 	mov	arg01, local01
02790     01 F8 06 F6 | 	mov	arg02, #1
02794     07 FC 06 F6 | 	mov	arg04, #7
02798     9C 09 B0 FD | 	call	#__system___lookup
0279c     75 03 0B F6 | 	mov	local02, result1 wz
027a0                 | '               ofsDegr := 45
027a0     2D 02 07 A6 |  if_e	mov	local02, #45
027a4     20 00 90 FD | 	jmp	#LR__0221
027a8                 | LR__0220
027a8                 | '         else
027a8                 | '           if (ofsDegr := lookup(index: 52, 53, 53, 53, 54, 54, 53)) == 0
027a8     04 00 00 FF 
027ac     38 FA 06 F1 | 	add	arg03, ##2104
027b0     80 F7 02 F6 | 	mov	arg01, local01
027b4     01 F8 06 F6 | 	mov	arg02, #1
027b8     07 FC 06 F6 | 	mov	arg04, #7
027bc     78 09 B0 FD | 	call	#__system___lookup
027c0     75 03 0B F6 | 	mov	local02, result1 wz
027c4                 | '               ofsDegr := 53
027c4     35 02 07 A6 |  if_e	mov	local02, #53
027c8                 | LR__0221
027c8                 | '         fwdDegrees := ofsDegr                           ' 0 is bad > 2A!
027c8     81 05 03 F6 | 	mov	local03, local02
027cc     68 07 07 F6 | 	mov	local04, #360
027d0     81 07 83 F1 | 	sub	local04, local02
027d4                 | '         revDegrees := 360 - ofsDegr                     ' vs. using 360?
027d4     08 00 90 FD | 	jmp	#LR__0223
027d8                 | LR__0222
027d8                 | '       other:
027d8                 | '         ' 4 degrees per tic, offset was actually 5 tics! or 20 degrees (0.0556 of rotation)
027d8                 | '         ' from characterization at 18v5:
027d8                 | '         fwdDegrees := ofsDegr := 43
027d8     2B 04 07 F6 | 	mov	local03, #43
027dc                 | '         revDegrees := 360 - fwdDegrees
027dc     3D 07 07 F6 | 	mov	local04, #317
027e0                 | LR__0223
027e0     82 EB 02 F6 | 	mov	result1, local03
027e4     83 ED 02 F6 | 	mov	result2, local04
027e8     27 F1 03 F6 | 	mov	ptra, fp
027ec     32 01 A0 FD | 	call	#popregs_
027f0                 | _isp_bldc_motor_offsetsForMotor_ret
027f0     2D 00 64 FD | 	ret
027f4                 | 
027f4                 | ' {
027f4                 | ' }
027f4                 | ' 
027f4                 | ' PRI getInternalDetectMode(eDetectMode) : eValidMode, bUserOverride | legalMode
027f4                 | _isp_bldc_motor_getInternalDetectMode
027f4     7B F1 02 F6 | 	mov	_var01, arg01
027f8                 | ' ' ensure suer specifies a good value
027f8                 | '     eValidMode := BRD_AUTO_DET
027f8     1E EA 06 F6 | 	mov	result1, #30
027fc                 | '     bUserOverride := FALSE
027fc     00 EC 06 F6 | 	mov	result2, #0
02800                 | '     legalMode := VALUE_NOT_SET
02800                 | '     CASE eDetectMode
02800     1E F0 86 F1 | 	sub	_var01, #30
02804     03 F0 26 F3 | 	fle	_var01, #3
02808     30 F0 62 FD | 	jmprel	_var01
0280c                 | LR__0230
0280c     0C 00 90 FD | 	jmp	#LR__0231
02810     10 00 90 FD | 	jmp	#LR__0232
02814     18 00 90 FD | 	jmp	#LR__0233
02818     20 00 90 FD | 	jmp	#LR__0234
0281c                 | LR__0231
0281c                 | '         user.BRD_AUTO_DET:
0281c                 | '             legalMode := BRD_AUTO_DET    ' xlate to our internal value
0281c     1E F2 06 F6 | 	mov	_var02, #30
02820     1C 00 90 FD | 	jmp	#LR__0235
02824                 | LR__0232
02824                 | '         user.BRD_REV_A:
02824                 | '             legalMode := BRD_REV_A
02824     1F F2 06 F6 | 	mov	_var02, #31
02828                 | '             bUserOverride := TRUE
02828     01 EC 66 F6 | 	neg	result2, #1
0282c     10 00 90 FD | 	jmp	#LR__0235
02830                 | LR__0233
02830                 | '         user.BRD_REV_B:
02830                 | '             legalMode := BRD_REV_B
02830     20 F2 06 F6 | 	mov	_var02, #32
02834                 | '             bUserOverride := TRUE
02834     01 EC 66 F6 | 	neg	result2, #1
02838     04 00 90 FD | 	jmp	#LR__0235
0283c                 | LR__0234
0283c                 | '         OTHER :
0283c                 | '             legalMode := VALUE_NOT_SET
0283c     01 F2 66 F6 | 	neg	_var02, #1
02840                 | LR__0235
02840                 | ' 
02840                 | '     ' if legal base-pin then start cog
02840                 | '     if legalMode <> VALUE_NOT_SET
02840     FF FF 7F FF 
02844     FF F3 0E F2 | 	cmp	_var02, ##-1 wz
02848                 | '         eValidMode := legalMode        ' record base pin number
02848     79 EB 02 56 |  if_ne	mov	result1, _var02
0284c                 | _isp_bldc_motor_getInternalDetectMode_ret
0284c     2D 00 64 FD | 	ret
02850                 | 
02850                 | ' 
02850                 | ' PRI confgurePowerLimits(userVoltage) | selectedPower, index
02850                 | _isp_bldc_motor_confgurePowerLimits
02850     03 4A 06 F6 | 	mov	COUNT_, #3
02854     28 01 A0 FD | 	call	#pushregs_
02858                 | ' ' set up our motor drive limits based upon the user configured Voltage selection
02858                 | '     selectedPower := validVoltageForChoice(userVoltage)
02858     38 FD BF FD | 	call	#_isp_bldc_motor_validVoltageForChoice
0285c     75 01 03 F6 | 	mov	local01, result1
02860     80 01 00 F6 | 	mov	0-0, local01
02864     36 66 64 FD | 	brk	#51
02868                 | '     if selectedPower == INVALID_VOLTAGE
02868     FF FF 7F FF 
0286c     FF 01 0F F2 | 	cmp	local01, ##-1 wz
02870                 | '         abort
02870     6C F7 02 A6 |  if_e	mov	arg01, abortchain
02874     00 F8 06 A6 |  if_e	mov	arg02, #0
02878     00 FA 06 A6 |  if_e	mov	arg03, #0
0287c     5A 01 A0 AD |  if_e	call	#__longjmp
02880                 | ' 
02880                 | '     eUserSelectedVolts := VALUE_NOT_SET  ' preset
02880     FF FF FF FF 
02884     70 FF 6B FC | 	wrlong	##-1, objptr
02888                 | '     minFwdIncreAtPwr := VALUE_NOT_SET
02888     14 E0 06 F1 | 	add	objptr, #20
0288c     FF FF FF FF 
02890     70 FF 6B FC | 	wrlong	##-1, objptr
02894                 | '     maxFwdIncreAtPwr := VALUE_NOT_SET
02894     04 E0 06 F1 | 	add	objptr, #4
02898     FF FF FF FF 
0289c     70 FF 6B FC | 	wrlong	##-1, objptr
028a0                 | '     minRevIncreAtPwr := VALUE_NOT_SET
028a0     04 E0 06 F1 | 	add	objptr, #4
028a4     FF FF FF FF 
028a8     70 FF 6B FC | 	wrlong	##-1, objptr
028ac                 | '     maxRevIncreAtPwr := VALUE_NOT_SET
028ac     04 E0 06 F1 | 	add	objptr, #4
028b0     FF FF FF FF 
028b4     70 FF 6B FC | 	wrlong	##-1, objptr
028b8     20 E0 86 F1 | 	sub	objptr, #32
028bc                 | ' 
028bc                 | '     if user.MOTOR_TYPE == MOTR_DOCO_4KRPM
028bc     08 00 90 FD | 	jmp	#LR__0240
028c0                 | '         if (index := lookdown(selectedPower:PWR_7p4V, PWR_11p1V, PWR_12p0V, PWR_14p8V, PWR_18p5V, PWR_22p2V, PWR_24p0V)) <> 0
028c0                 | '             if eDetectedBoard == REV_B
028c0                 | '                 maxFwdIncreAtPwr := lookup(index: -385_000_000, -287_500_000, -485_000_000, -388_000_000, -449_500_000, -420_000_000, -460_000_000)
028c0                 | '                 maxRevIncreAtPwr := lookup(index:  385_000_000,  287_500_000,  485_000_000,  388_000_000,  449_500_000,  420_000_000,  460_000_000)
028c0                 | '             else
028c0                 | '                     ' 282_000_000 100% anything above yields RPM 1885.0, cts/Sec 754, @0.11A
028c0                 | '                     ' 545_000_000 100% anything above yields RPM 3645.0, cts/Sec 1458, @0.50A
028c0                 | '                     ' 335_000_000 100% anything above yields RPM 2242.0, cts/Sec 897, @0.14A
028c0                 | '                     ' 376_000_000 100% anything above yields RPM 2517.0, cts/Sec 1007, @0.88A
028c0                 | '                     ' 376_000_000 100% anything above yields RPM 2_745, cts/sec 1_098
028c0                 | '                     ' 100% anything above yields RPM 2_810, cts/sec 1_124
028c0                 | '                     ' 100% anything above yields RPM 2_877, cts/sec 1_151
028c0                 | '                     ' 100% anything above yields RPM 2_940, cts/sec 1_178
028c0                 | '                     ' 100% anything above yields RPM 3_010, cts/sec 1_204
028c0                 | '                     ' 100% anything above yields RPM 3_077, cts/sec 1_231
028c0                 | '                     ' 100% anything above yields RPM 3_145, cts/sec 1_258
028c0                 | '                     ' 470_000_000 100% anything above yields RPM 2662.0, cts/Sec 1065, @0.89A
028c0                 | '                     ' 100% anything above yields RPM 3145.0, cts/Sec 1258, @0.78A
028c0                 | '                     ' 391_000_000 100% anything above yields RPM 2615.0, cts/Sec 1046, @0.620A
028c0                 | '                 maxFwdIncreAtPwr := lookup(index: -282_000_000, -545_000_000, -335_000_000, -376_000_000, -398_000_000, -470_000_000, -391_000_000)
028c0                 | '                 maxRevIncreAtPwr := lookup(index:  282_000_000,  545_000_000,  335_000_000,  376_000_000,  398_000_000,  470_000_000,  391_000_000)
028c0                 | '         else
028c0     80 01 00 F6 | 	mov	0-0, local01
028c4     36 68 64 FD | 	brk	#52
028c8                 | '             abort   ' SHOULD NEVER get here!
028c8                 | LR__0240
028c8                 | '     else
028c8                 | '         ' is this more readable than the case statement?
028c8                 | '         if (index := lookdown(selectedPower:PWR_6p0V..PWR_11p1V, PWR_12p0V, PWR_14p8V, PWR_18p5V, PWR_22p2V..PWR_24p0V)) <> 0
028c8     72 FB 02 F6 | 	mov	arg03, ptr__isp_bldc_motor_dat__
028cc     04 00 00 FF 
028d0     E0 FA 06 F1 | 	add	arg03, ##2272
028d4     80 F7 02 F6 | 	mov	arg01, local01
028d8     01 F8 06 F6 | 	mov	arg02, #1
028dc     08 FC 06 F6 | 	mov	arg04, #8
028e0     80 08 B0 FD | 	call	#__system___lookdown
028e4     75 03 0B F6 | 	mov	local02, result1 wz
028e8     54 00 90 AD |  if_e	jmp	#LR__0241
028ec                 | '             ' 90_000_000  anything above yields RPM 165.3, cts/Sec 248 (until fault at 170.6 256)
028ec                 | '             ' 97_000_000  anything above yields RPM 181.3, cts/Sec 272 (until fault at 186.6 280)
028ec                 | '             ' 120_000_000 anything above yields RPM 224.0, cts/Sec 336 (until fault at 229.8 344)
028ec                 | '             ' 147_000_000 anything above yields RPM 272.0, cts/Sec 408 (until fault at 277.3 416)
028ec                 | '             ' 172_000_000 anything above yields RPM 320.0, cts/Sec 480 (until fault at 325.3 480)
028ec                 | '             ' 172_000_000     FAKE above yields RPM 320.0, cts/Sec 480 (until fault at 325.3 480)
028ec                 | '             maxFwdIncreAtPwr := lookup(index:  90_000_000,  90_000_000,  90_000_000,  97_000_000,  120_000_000,  147_000_000,  172_000_000,  172_000_000)
028ec     72 FB 02 F6 | 	mov	arg03, ptr__isp_bldc_motor_dat__
028f0     04 00 00 FF 
028f4     00 FB 06 F1 | 	add	arg03, ##2304
028f8     81 F7 02 F6 | 	mov	arg01, local02
028fc     01 F8 06 F6 | 	mov	arg02, #1
02900     08 FC 06 F6 | 	mov	arg04, #8
02904     30 08 B0 FD | 	call	#__system___lookup
02908     18 E0 06 F1 | 	add	objptr, #24
0290c     70 EB 62 FC | 	wrlong	result1, objptr
02910     18 E0 86 F1 | 	sub	objptr, #24
02914                 | '             maxRevIncreAtPwr := lookup(index: -90_000_000, -90_000_000, -90_000_000, -97_000_000, -120_000_000, -147_000_000, -172_000_000, -172_000_000)
02914     72 FB 02 F6 | 	mov	arg03, ptr__isp_bldc_motor_dat__
02918     04 00 00 FF 
0291c     20 FB 06 F1 | 	add	arg03, ##2336
02920     81 F7 02 F6 | 	mov	arg01, local02
02924     01 F8 06 F6 | 	mov	arg02, #1
02928     08 FC 06 F6 | 	mov	arg04, #8
0292c     08 08 B0 FD | 	call	#__system___lookup
02930     20 E0 06 F1 | 	add	objptr, #32
02934     70 EB 62 FC | 	wrlong	result1, objptr
02938     20 E0 86 F1 | 	sub	objptr, #32
0293c     18 00 90 FD | 	jmp	#LR__0242
02940                 | LR__0241
02940                 | '         else
02940     80 01 00 F6 | 	mov	0-0, local01
02944     36 6A 64 FD | 	brk	#53
02948                 | '             abort   ' SHOULD NEVER get here!
02948     6C F7 02 F6 | 	mov	arg01, abortchain
0294c     00 F8 06 F6 | 	mov	arg02, #0
02950     00 FA 06 F6 | 	mov	arg03, #0
02954     5A 01 A0 FD | 	call	#__longjmp
02958                 | LR__0242
02958                 | ' 
02958                 | '     fMotorVolts := 0.0  ' default
02958     04 E0 06 F1 | 	add	objptr, #4
0295c     70 01 68 FC | 	wrlong	#0, objptr
02960                 | '     if maxFwdIncreAtPwr <> VALUE_NOT_SET                ' if we have good motor then set rest of values
02960     14 E0 06 F1 | 	add	objptr, #20
02964     70 05 03 FB | 	rdlong	local03, objptr
02968     18 E0 86 F1 | 	sub	objptr, #24
0296c     FF FF 7F FF 
02970     FF 05 0F F2 | 	cmp	local03, ##-1 wz
02974     30 00 90 AD |  if_e	jmp	#LR__0243
02978                 | '         eUserSelectedVolts := selectedPower
02978     70 01 63 FC | 	wrlong	local01, objptr
0297c                 | '         fMotorVolts := motorVoltage(selectedPower)
0297c     80 F7 02 F6 | 	mov	arg01, local01
02980     BC 00 B0 FD | 	call	#_isp_bldc_motor_motorVoltage
02984     04 E0 06 F1 | 	add	objptr, #4
02988     70 EB 62 FC | 	wrlong	result1, objptr
0298c                 | '         if user.MOTOR_TYPE == MOTR_DOCO_4KRPM
0298c                 | '             minFwdIncreAtPwr := 544_628           ' anything below yields NO rotation
0298c     10 E0 06 F1 | 	add	objptr, #16
02990     27 04 80 FF 
02994     70 E9 6A FC | 	wrlong	##544628, objptr
02998                 | '             minRevIncreAtPwr := 0 - minFwdIncreAtPwr
02998     08 E0 06 F1 | 	add	objptr, #8
0299c     D8 FB FF FF 
029a0     70 19 69 FC | 	wrlong	##-544628, objptr
029a4     1C E0 86 F1 | 	sub	objptr, #28
029a8                 | LR__0243
029a8     70 05 03 FB | 	rdlong	local03, objptr
029ac     82 01 00 F6 | 	mov	0-0, local03
029b0     18 E0 06 F1 | 	add	objptr, #24
029b4     70 03 03 FB | 	rdlong	local02, objptr
029b8     81 03 00 F6 | 	mov	1-0, local02
029bc     04 E0 86 F1 | 	sub	objptr, #4
029c0     70 03 03 FB | 	rdlong	local02, objptr
029c4     14 E0 86 F1 | 	sub	objptr, #20
029c8     81 05 00 F6 | 	mov	2-0, local02
029cc     36 6C 64 FD | 	brk	#54
029d0     00 EA 06 F6 | 	mov	result1, #0
029d4     27 F1 03 F6 | 	mov	ptra, fp
029d8     32 01 A0 FD | 	call	#popregs_
029dc                 | _isp_bldc_motor_confgurePowerLimits_ret
029dc     2D 00 64 FD | 	ret
029e0                 | 
029e0                 | ' 
029e0                 | ' PRI setTargetAccel(nTgtIncr, sync) | inincr
029e0                 | _isp_bldc_motor_setTargetAccel
029e0                 | '     inincr := nTgtIncr
029e0     7B F1 02 F6 | 	mov	_var01, arg01
029e4                 | '     nTgtIncr ZEROX= 30                                  ' clear bit 31
029e4     1E F6 46 F7 | 	zerox	arg01, #30
029e8     7C F3 02 F6 | 	mov	_var02, arg02
029ec     1F F2 66 F0 | 	shl	_var02, #31
029f0                 | '     nTgtIncr |= (sync << 31)                            ' bit 31 set if sync required
029f0     79 F7 42 F5 | 	or	arg01, _var02
029f4                 | '     targetIncre := nTgtIncr
029f4     01 00 00 FF 
029f8     33 E0 06 F1 | 	add	objptr, ##563
029fc     70 F7 62 FC | 	wrlong	arg01, objptr
02a00     78 01 00 F6 | 	mov	0-0, _var01
02a04     7B 03 00 F6 | 	mov	1-0, arg01
02a08     1F F6 46 F0 | 	shr	arg01, #31
02a0c     7B 05 00 F6 | 	mov	2-0, arg01
02a10     7C 07 00 F6 | 	mov	3-0, arg02
02a14     36 6E 64 FD | 	brk	#55
02a18     78 F3 52 F6 | 	abs	_var02, _var01 wc
02a1c     13 00 00 FF 
02a20     10 F3 16 FD | 	qdiv	_var02, ##10000
02a24                 | '     tvTargetIncreInM := inincr / 10_000
02a24     7C E0 06 F1 | 	add	objptr, #124
02a28     18 F2 62 FD | 	getqx	_var02
02a2c     79 F3 82 F6 | 	negc	_var02, _var02
02a30     70 F3 62 FC | 	wrlong	_var02, objptr
02a34     01 00 00 FF 
02a38     AF E0 86 F1 | 	sub	objptr, ##687
02a3c                 | _isp_bldc_motor_setTargetAccel_ret
02a3c     2D 00 64 FD | 	ret
02a40                 | 
02a40                 | ' 
02a40                 | ' PRI motorVoltage(eSelectedPower) : fVolts | index
02a40                 | _isp_bldc_motor_motorVoltage
02a40     02 4A 06 F6 | 	mov	COUNT_, #2
02a44     28 01 A0 FD | 	call	#pushregs_
02a48     7B 01 03 F6 | 	mov	local01, arg01
02a4c     00 02 07 F6 | 	mov	local02, #0
02a50                 | '     if (index := lookdown(eSelectedPower:PWR_6p0V..PWR_25p9V)) <> 0
02a50     72 FB 02 F6 | 	mov	arg03, ptr__isp_bldc_motor_dat__
02a54     04 00 00 FF 
02a58     40 FB 06 F1 | 	add	arg03, ##2368
02a5c     80 F7 02 F6 | 	mov	arg01, local01
02a60     01 F8 06 F6 | 	mov	arg02, #1
02a64     09 FC 06 F6 | 	mov	arg04, #9
02a68     F8 06 B0 FD | 	call	#__system___lookdown
02a6c     75 F9 0A F6 | 	mov	arg02, result1 wz
02a70     24 00 90 AD |  if_e	jmp	#LR__0250
02a74                 | '         fVolts := lookup(index: 6.0, 7.4, 11.1, 12.0, 14.8, 18.5, 22.2, 24.0, 25.9)
02a74     72 FB 02 F6 | 	mov	arg03, ptr__isp_bldc_motor_dat__
02a78     04 00 00 FF 
02a7c     64 FB 06 F1 | 	add	arg03, ##2404
02a80     7C F7 02 F6 | 	mov	arg01, arg02
02a84     01 F8 06 F6 | 	mov	arg02, #1
02a88     09 FC 06 F6 | 	mov	arg04, #9
02a8c     A8 06 B0 FD | 	call	#__system___lookup
02a90     75 03 03 F6 | 	mov	local02, result1
02a94     18 00 90 FD | 	jmp	#LR__0251
02a98                 | LR__0250
02a98                 | '     else
02a98     80 01 00 F6 | 	mov	0-0, local01
02a9c     36 70 64 FD | 	brk	#56
02aa0                 | '         abort   ' SHOULD NEVER get here!
02aa0     6C F7 02 F6 | 	mov	arg01, abortchain
02aa4     00 F8 06 F6 | 	mov	arg02, #0
02aa8     00 FA 06 F6 | 	mov	arg03, #0
02aac     5A 01 A0 FD | 	call	#__longjmp
02ab0                 | LR__0251
02ab0     81 EB 02 F6 | 	mov	result1, local02
02ab4     27 F1 03 F6 | 	mov	ptra, fp
02ab8     32 01 A0 FD | 	call	#popregs_
02abc                 | _isp_bldc_motor_motorVoltage_ret
02abc     2D 00 64 FD | 	ret
02ac0                 | 
02ac0                 | ' '}
02ac0                 | ' {
02ac0                 | ' '}
02ac0                 | ' 
02ac0                 | ' PUB resetWindowAccumulators()
02ac0                 | _isp_bldc_motor_resetWindowAccumulators
02ac0     01 4A 06 F6 | 	mov	COUNT_, #1
02ac4     28 01 A0 FD | 	call	#pushregs_
02ac8     70 F7 02 F6 | 	mov	arg01, objptr
02acc     E3 F7 06 F1 | 	add	arg01, #483
02ad0                 | ' '' INTERNAL USE: reset our window accumulator data
02ad0                 | '     longfill(@hallCountsWindow, 0, HALL_WINDOW_SIZE)                            ' zero our windowed accum
02ad0     07 FA 06 F6 | 	mov	arg03, #7
02ad4     28 FA 62 FD | 	setq	arg03
02ad8     7B 01 68 FC | 	wrlong	#0, arg01
02adc                 | '     hallWinEntryCt := hallWindowSum := hallWinIndex := 0
02adc     01 00 00 FF 
02ae0     03 E0 06 F1 | 	add	objptr, ##515
02ae4     70 01 68 FC | 	wrlong	#0, objptr
02ae8     0C E0 06 F1 | 	add	objptr, #12
02aec     70 01 68 FC | 	wrlong	#0, objptr
02af0     08 E0 86 F1 | 	sub	objptr, #8
02af4     70 01 68 FC | 	wrlong	#0, objptr
02af8                 | '     hallCntsIn8thSec := 0
02af8     04 E0 06 F1 | 	add	objptr, #4
02afc     70 01 68 FC | 	wrlong	#0, objptr
02b00                 | '     prioro8thSecPos := pos                                                      ' reset by adopting current value
02b00     4C E0 06 F1 | 	add	objptr, #76
02b04     70 01 03 FB | 	rdlong	local01, objptr
02b08     28 E0 06 F1 | 	add	objptr, #40
02b0c     70 01 63 FC | 	wrlong	local01, objptr
02b10     01 00 00 FF 
02b14     7F E0 86 F1 | 	sub	objptr, ##639
02b18                 | '     resetHdmiData()
02b18     18 01 B0 FD | 	call	#_isp_bldc_motor_resetHdmiData
02b1c                 | '     resetTracking()
02b1c                 | ' '' Resets the position tracking values returned by getDistance() and getRotations()
02b1c                 | '     posTrkHallTicks := 0    ' reset all of our trackers (they are incremented in sensor loop)
02b1c     01 00 00 FF 
02b20     73 E0 06 F1 | 	add	objptr, ##627
02b24     70 01 68 FC | 	wrlong	#0, objptr
02b28     01 00 00 FF 
02b2c     73 E0 86 F1 | 	sub	objptr, ##627
02b30                 | '     waitms(200) ' values will clear in 125ms
02b30     C8 F6 06 F6 | 	mov	arg01, #200
02b34     BC 06 B0 FD | 	call	#__system___waitms
02b38     27 F1 03 F6 | 	mov	ptra, fp
02b3c     32 01 A0 FD | 	call	#popregs_
02b40                 | _isp_bldc_motor_resetWindowAccumulators_ret
02b40     2D 00 64 FD | 	ret
02b44                 | 
02b44                 | ' 
02b44                 | ' PUB updateWindowAccumulators() | nHallCntsIn8thSec
02b44                 | _isp_bldc_motor_updateWindowAccumulators
02b44     01 4A 06 F6 | 	mov	COUNT_, #1
02b48     28 01 A0 FD | 	call	#pushregs_
02b4c                 | ' '' INTERNAL USE: accum our windowed values
02b4c                 | '     nHallCntsIn8thSec := absDistanceInTics(pos, prioro8thSecPos)                ' Read the next sensor value
02b4c     01 00 00 FF 
02b50     57 E0 06 F1 | 	add	objptr, ##599
02b54     70 EB 02 FB | 	rdlong	result1, objptr
02b58     28 E0 06 F1 | 	add	objptr, #40
02b5c     70 F9 02 FB | 	rdlong	arg02, objptr
02b60     75 F9 82 F1 | 	sub	arg02, result1
02b64                 | '         '  -7 -> -9 = abs(-7 - -9) = abs(2) = 2
02b64                 | '         '  -11 -> -9 = abs(-11 - -9) = abs(-2) = 2
02b64                 | '         '  9 -> -9 = abs(9 - -9) + abs(18) = 18
02b64                 | '         ' -9 -> 6 = abs(-9 - 6) = abs(-15) = 15
02b64                 | '         ' -3 -> 6 = abs(-3 - 6) = abs(-9) = 9
02b64                 | '         ' 9 -> 6 = abs(9 - 6) = abs(3) = 3
02b64                 | '         ' 9 -> 12 = abs(9 - 12) = abs(-3) = 3
02b64                 | '     nHallTics := abs(priorPos - newPos)
02b64     7C F9 42 F6 | 	abs	arg02, arg02
02b68                 | '     prioro8thSecPos := pos                                                      ' save prior
02b68     70 EB 62 FC | 	wrlong	result1, objptr
02b6c     9C E0 86 F1 | 	sub	objptr, #156
02b70     70 F7 02 F6 | 	mov	arg01, objptr
02b74     20 E0 06 F1 | 	add	objptr, #32
02b78     70 01 03 FB | 	rdlong	local01, objptr
02b7c     02 00 67 F0 | 	shl	local01, #2
02b80     7B 01 03 F1 | 	add	local01, arg01
02b84                 | '         hallWindowSum -= LONG[@hallCountsWindow][hallWinIndex]                  ' Remove the oldest entry from the sum
02b84     0C E0 06 F1 | 	add	objptr, #12
02b88     70 EB 02 FB | 	rdlong	result1, objptr
02b8c     80 01 03 FB | 	rdlong	local01, local01
02b90     80 EB 82 F1 | 	sub	result1, local01
02b94     70 EB 62 FC | 	wrlong	result1, objptr
02b98     0C E0 86 F1 | 	sub	objptr, #12
02b9c     70 01 03 FB | 	rdlong	local01, objptr
02ba0     02 00 67 F0 | 	shl	local01, #2
02ba4     7B 01 03 F1 | 	add	local01, arg01
02ba8                 | '     long [@hallCountsWindow][hallWinIndex] := nHallCntsIn8thSec                 ' place the newest reading into the window
02ba8     80 F9 62 FC | 	wrlong	arg02, local01
02bac                 | '         hallWindowSum += hallCntsIn8thSec                                       ' Add the newest reading to the sum
02bac     0C E0 06 F1 | 	add	objptr, #12
02bb0     70 01 03 FB | 	rdlong	local01, objptr
02bb4     04 E0 86 F1 | 	sub	objptr, #4
02bb8     70 EB 02 FB | 	rdlong	result1, objptr
02bbc     75 01 03 F1 | 	add	local01, result1
02bc0     04 E0 06 F1 | 	add	objptr, #4
02bc4     70 01 63 FC | 	wrlong	local01, objptr
02bc8     0C E0 86 F1 | 	sub	objptr, #12
02bcc     70 01 03 FB | 	rdlong	local01, objptr
02bd0     01 00 07 F1 | 	add	local01, #1
02bd4     07 00 07 F5 | 	and	local01, #7
02bd8                 | '         hallWinIndex := (hallWinIndex + 1) +// HALL_WINDOW_SIZE                 ' Increment the index, and wrap to 0 if it exceeds the window size
02bd8     70 01 63 FC | 	wrlong	local01, objptr
02bdc                 | '         if hallWinEntryCt < HALL_WINDOW_SIZE                                    ' incr number of samples in sum until is window size
02bdc     04 E0 06 F1 | 	add	objptr, #4
02be0     70 01 03 FB | 	rdlong	local01, objptr
02be4     01 00 00 FF 
02be8     07 E0 86 F1 | 	sub	objptr, ##519
02bec     08 00 57 F2 | 	cmps	local01, #8 wc
02bf0                 | '             hallWinEntryCt++
02bf0     01 00 00 CF 
02bf4     07 E0 06 C1 |  if_b	add	objptr, ##519
02bf8     01 00 07 C1 |  if_b	add	local01, #1
02bfc     70 01 63 CC |  if_b	wrlong	local01, objptr
02c00     01 00 00 CF 
02c04     07 E0 86 C1 |  if_b	sub	objptr, ##519
02c08                 | ' 
02c08                 | '     posTrkHallTicks += nHallCntsIn8thSec
02c08     01 00 00 FF 
02c0c     73 E0 06 F1 | 	add	objptr, ##627
02c10     70 01 03 FB | 	rdlong	local01, objptr
02c14     7C 01 03 F1 | 	add	local01, arg02
02c18     70 01 63 FC | 	wrlong	local01, objptr
02c1c     01 00 00 FF 
02c20     73 E0 86 F1 | 	sub	objptr, ##627
02c24                 | ' 
02c24                 | '     updateHdmiData()
02c24     64 00 B0 FD | 	call	#_isp_bldc_motor_updateHdmiData
02c28     27 F1 03 F6 | 	mov	ptra, fp
02c2c     32 01 A0 FD | 	call	#popregs_
02c30                 | _isp_bldc_motor_updateWindowAccumulators_ret
02c30     2D 00 64 FD | 	ret
02c34                 | 
02c34                 | ' 
02c34                 | ' PRI resetHdmiData()
02c34                 | _isp_bldc_motor_resetHdmiData
02c34                 | '     tvMaxFps_x10 := tvMaxMPH_x10 := tvMaxkPH_x10 := 0
02c34     01 00 00 FF 
02c38     A3 E0 06 F1 | 	add	objptr, ##675
02c3c     70 01 68 FC | 	wrlong	#0, objptr
02c40     04 E0 86 F1 | 	sub	objptr, #4
02c44     70 01 68 FC | 	wrlong	#0, objptr
02c48     04 E0 86 F1 | 	sub	objptr, #4
02c4c     70 01 68 FC | 	wrlong	#0, objptr
02c50                 | '     tvMaxRpmIn10ths := tvMaxCntsInSec := tvMaxMmPerSec_x10 := 0
02c50     0C E0 06 F1 | 	add	objptr, #12
02c54     70 01 68 FC | 	wrlong	#0, objptr
02c58     04 E0 06 F1 | 	add	objptr, #4
02c5c     70 01 68 FC | 	wrlong	#0, objptr
02c60     14 E0 86 F1 | 	sub	objptr, #20
02c64     70 01 68 FC | 	wrlong	#0, objptr
02c68                 | '     tv360rpm_x10 := tv360rpm := 0
02c68     24 E0 06 F1 | 	add	objptr, #36
02c6c     70 01 68 FC | 	wrlong	#0, objptr
02c70     04 E0 86 F1 | 	sub	objptr, #4
02c74     70 01 68 FC | 	wrlong	#0, objptr
02c78                 | '     tvMaxSenseI := 0
02c78     04 E0 86 F1 | 	sub	objptr, #4
02c7c     70 01 68 FC | 	wrlong	#0, objptr
02c80     01 00 00 FF 
02c84     B3 E0 86 F1 | 	sub	objptr, ##691
02c88                 | _isp_bldc_motor_resetHdmiData_ret
02c88     2D 00 64 FD | 	ret
02c8c                 | 
02c8c                 | ' 
02c8c                 | ' PRI updateHdmiData()
02c8c                 | _isp_bldc_motor_updateHdmiData
02c8c     01 4A 06 F6 | 	mov	COUNT_, #1
02c90     28 01 A0 FD | 	call	#pushregs_
02c94                 | '     cntsInSec := hallWindowSum                                                  ' moving sum
02c94     01 00 00 FF 
02c98     0F E0 06 F1 | 	add	objptr, ##527
02c9c     70 F9 02 FB | 	rdlong	arg02, objptr
02ca0     80 E0 06 F1 | 	add	objptr, #128
02ca4     70 F9 62 FC | 	wrlong	arg02, objptr
02ca8     7C F7 02 F6 | 	mov	arg01, arg02
02cac     04 F6 66 F0 | 	shl	arg01, #4
02cb0     7C F7 82 F1 | 	sub	arg01, arg02
02cb4     02 F6 66 F0 | 	shl	arg01, #2
02cb8     7B 37 03 F6 | 	mov	muldiva_, arg01
02cbc     02 36 67 F0 | 	shl	muldiva_, #2
02cc0     7B 37 03 F1 | 	add	muldiva_, arg01
02cc4     01 36 67 F0 | 	shl	muldiva_, #1
02cc8     01 00 00 FF 
02ccc     47 E0 86 F1 | 	sub	objptr, ##583
02cd0     70 39 03 FB | 	rdlong	muldivb_, objptr
02cd4     48 E0 86 F1 | 	sub	objptr, #72
02cd8     3A 01 A0 FD | 	call	#divide_
02cdc     9C EB 52 F6 | 	abs	result1, muldivb_ wc
02ce0     0A EA 16 FD | 	qdiv	result1, #10
02ce4                 | '     tvRpm_x10 := ((cntsInSec * 60) * 10) / hallTicsPerRotation
02ce4     01 00 00 FF 
02ce8     83 E0 06 F1 | 	add	objptr, ##643
02cec     70 39 63 FC | 	wrlong	muldivb_, objptr
02cf0                 | '     rpm := tvRpm_x10 / 10
02cf0     04 E0 06 F1 | 	add	objptr, #4
02cf4                 | ' 
02cf4                 | '     tvMaxRpmIn10ths := max(tvRpm_x10, tvMaxRpmIn10ths)
02cf4     18 EA 62 FD | 	getqx	result1
02cf8     75 EB 82 F6 | 	negc	result1, result1
02cfc     70 EB 62 FC | 	wrlong	result1, objptr
02d00     10 E0 06 F1 | 	add	objptr, #16
02d04     70 F9 02 FB | 	rdlong	arg02, objptr
02d08     7C 39 5B F2 | 	cmps	muldivb_, arg02 wcz
02d0c     9C EB 02 16 |  if_a	mov	result1, muldivb_
02d10     7C EB 02 E6 |  if_be	mov	result1, arg02
02d14     75 F9 52 F6 | 	abs	arg02, result1 wc
02d18     0A F8 16 FD | 	qdiv	arg02, #10
02d1c                 | ' ' return max of a or b
02d1c                 | '     nMax := (a > b) ? a : b
02d1c     70 EB 62 FC | 	wrlong	result1, objptr
02d20                 | '     maxRpm := tvMaxRpmIn10ths / 10
02d20     0C E0 86 F1 | 	sub	objptr, #12
02d24                 | '     tvMaxCntsInSec := max(cntsInSec, tvMaxCntsInSec)
02d24                 | ' ' return max of a or b
02d24                 | '     nMax := (a > b) ? a : b
02d24                 | ' 
02d24                 | '     tvMaxSenseI := max(sense_i_mV, tvMaxSenseI)
02d24                 | ' ' return max of a or b
02d24                 | '     nMax := (a > b) ? a : b
02d24     18 EA 62 FD | 	getqx	result1
02d28     75 EB 82 F6 | 	negc	result1, result1
02d2c     70 EB 62 FC | 	wrlong	result1, objptr
02d30     04 E0 06 F1 | 	add	objptr, #4
02d34     70 F7 02 FB | 	rdlong	arg01, objptr
02d38     1C E0 06 F1 | 	add	objptr, #28
02d3c     70 F9 02 FB | 	rdlong	arg02, objptr
02d40     7C F7 5A F2 | 	cmps	arg01, arg02 wcz
02d44     7B EB 02 16 |  if_a	mov	result1, arg01
02d48     7C EB 02 E6 |  if_be	mov	result1, arg02
02d4c     70 EB 62 FC | 	wrlong	result1, objptr
02d50     5C E0 86 F1 | 	sub	objptr, #92
02d54     70 37 03 FB | 	rdlong	muldiva_, objptr
02d58     64 E0 06 F1 | 	add	objptr, #100
02d5c     70 F9 02 FB | 	rdlong	arg02, objptr
02d60     7C 37 5B F2 | 	cmps	muldiva_, arg02 wcz
02d64     9B EB 02 16 |  if_a	mov	result1, muldiva_
02d68     7C EB 02 E6 |  if_be	mov	result1, arg02
02d6c     70 EB 62 FC | 	wrlong	result1, objptr
02d70     A0 E0 86 F1 | 	sub	objptr, #160
02d74     70 39 03 FB | 	rdlong	muldivb_, objptr
02d78     01 00 00 FF 
02d7c     13 E0 86 F1 | 	sub	objptr, ##531
02d80     3A 01 A0 FD | 	call	#divide_
02d84                 | '     ' power calcs
02d84                 | '     tv_mA := sense_i_mV/rSenseForBoard                                          ' in multiples of 0.1mA
02d84     01 00 00 FF 
02d88     BF E0 06 F1 | 	add	objptr, ##703
02d8c     70 39 63 FC | 	wrlong	muldivb_, objptr
02d90                 | '     tv_mW := round((float(tv_mA) *. fMotorVolts)/. F_SCALE_WATTS)               ' in mW
02d90     01 00 00 FF 
02d94     BF E0 86 F1 | 	sub	objptr, ##703
02d98     9C F7 52 F6 | 	abs	arg01, muldivb_ wc
02d9c     1F 00 C7 C9 |  if_b	decod	local01, #31
02da0     00 00 07 36 |  if_ae	mov	local01, #0
02da4     B8 04 B0 FD | 	call	#__system___float_fromuns
02da8     80 EB 62 F5 | 	xor	result1, local01
02dac     75 F7 02 F6 | 	mov	arg01, result1
02db0     04 E0 06 F1 | 	add	objptr, #4
02db4     70 F9 02 FB | 	rdlong	arg02, objptr
02db8     04 E0 86 F1 | 	sub	objptr, #4
02dbc     D4 04 B0 FD | 	call	#__system___float_mul
02dc0     75 F7 02 F6 | 	mov	arg01, result1
02dc4     00 90 20 FF 
02dc8     00 F8 06 F6 | 	mov	arg02, ##1092616192
02dcc     B4 06 B0 FD | 	call	#__system___float_div
02dd0     75 F7 02 F6 | 	mov	arg01, result1
02dd4     01 F8 06 F6 | 	mov	arg02, #1
02dd8     F8 08 B0 FD | 	call	#__system___float_tointeger
02ddc     01 00 00 FF 
02de0     C3 E0 06 F1 | 	add	objptr, ##707
02de4     70 EB 62 FC | 	wrlong	result1, objptr
02de8     34 E0 86 F1 | 	sub	objptr, #52
02dec     70 EB 02 FB | 	rdlong	result1, objptr
02df0     01 00 00 FF 
02df4     4B E0 86 F1 | 	sub	objptr, ##587
02df8     70 F9 02 FB | 	rdlong	arg02, objptr
02dfc     7C EB 02 FD | 	qmul	result1, arg02
02e00                 | ' 
02e00                 | '     if user.WHEEL_DIA_IN_INCH <> 0
02e00     01 00 00 FF 
02e04     33 E0 06 F1 | 	add	objptr, ##563
02e08     70 EB 02 FB | 	rdlong	result1, objptr
02e0c     18 F8 62 FD | 	getqx	arg02
02e10     75 F9 02 FD | 	qmul	arg02, result1
02e14     18 EA 62 FD | 	getqx	result1
02e18     75 EB 52 F6 | 	abs	result1, result1 wc
02e1c     68 EB 16 FD | 	qdiv	result1, #360
02e20                 | '         ' pos is in hall-steps of 4Degr each (4deg for 6.5motor, 15deg for doco4k).
02e20                 | '         ' circumference of wheel is in mm x10
02e20                 | '         '   degrees of rotation is cntsInSec * 4
02e20                 | '         '   number of rotations is degrees / 360
02e20                 | '         '   dist in mm is (circInMM_x10 * rotations) / 10
02e20                 | '         mmPerSec_x10 := (((cntsInSec * degrPerTic) * circInMM_x10) / 360)
02e20     50 E0 06 F1 | 	add	objptr, #80
02e24                 | '         ftPerSec_x10 := distConv.mmps2fps(mmPerSec_x10 * 10)
02e24                 | ' '' Convert distance in mm/s to fps
02e24                 | '     ' RULE: 1 mm/sec = 0.00328084 ft/sec
02e24                 | '     fValue := float(nDistInMMPS) *. kFPS_IN_MMPS
02e24     18 EA 62 FD | 	getqx	result1
02e28     75 F9 82 F6 | 	negc	arg02, result1
02e2c     70 F9 62 FC | 	wrlong	arg02, objptr
02e30     7C F7 02 F6 | 	mov	arg01, arg02
02e34     02 F6 66 F0 | 	shl	arg01, #2
02e38     7C F7 02 F1 | 	add	arg01, arg02
02e3c     01 F6 66 F0 | 	shl	arg01, #1
02e40     4D E0 06 F1 | 	add	objptr, #77
02e44     7B F7 52 F6 | 	abs	arg01, arg01 wc
02e48     1F 00 C7 C9 |  if_b	decod	local01, #31
02e4c     00 00 07 36 |  if_ae	mov	local01, #0
02e50     0C 04 B0 FD | 	call	#__system___float_fromuns
02e54     80 EB 62 F5 | 	xor	result1, local01
02e58     75 F7 02 F6 | 	mov	arg01, result1
02e5c     81 AB 1D FF 
02e60     5D F9 06 F6 | 	mov	arg02, ##995558237
02e64     2C 04 B0 FD | 	call	#__system___float_mul
02e68     75 F7 02 F6 | 	mov	arg01, result1
02e6c                 | '     nDistInFps := trunc(fValue)
02e6c     00 F8 06 F6 | 	mov	arg02, #0
02e70     60 08 B0 FD | 	call	#__system___float_tointeger
02e74     49 E0 86 F1 | 	sub	objptr, #73
02e78     70 EB 62 FC | 	wrlong	result1, objptr
02e7c     04 E0 86 F1 | 	sub	objptr, #4
02e80     70 F9 02 FB | 	rdlong	arg02, objptr
02e84     7C F7 02 F6 | 	mov	arg01, arg02
02e88     02 F6 66 F0 | 	shl	arg01, #2
02e8c     7C F7 02 F1 | 	add	arg01, arg02
02e90     01 F6 66 F0 | 	shl	arg01, #1
02e94                 | '         kmh_x10 := distConv.mmps2kmh(mmPerSec_x10 * 10)
02e94     4D E0 06 F1 | 	add	objptr, #77
02e98                 | ' '' Convert distance in mm/s to km/hr
02e98                 | '     ' RULE: 1 mm/sec = 0.0036 km/hr
02e98                 | '     fValue := float(nDistInMMPS) *. kKMH_IN_MMPS
02e98     7B F7 52 F6 | 	abs	arg01, arg01 wc
02e9c     1F 00 C7 C9 |  if_b	decod	local01, #31
02ea0     00 00 07 36 |  if_ae	mov	local01, #0
02ea4     B8 03 B0 FD | 	call	#__system___float_fromuns
02ea8     80 EB 62 F5 | 	xor	result1, local01
02eac     75 F7 02 F6 | 	mov	arg01, result1
02eb0     F6 B5 1D FF 
02eb4     FA F9 06 F6 | 	mov	arg02, ##996929018
02eb8     D8 03 B0 FD | 	call	#__system___float_mul
02ebc     75 F7 02 F6 | 	mov	arg01, result1
02ec0                 | '     nDistInkmph := trunc(fValue)
02ec0     00 F8 06 F6 | 	mov	arg02, #0
02ec4     0C 08 B0 FD | 	call	#__system___float_tointeger
02ec8     45 E0 86 F1 | 	sub	objptr, #69
02ecc     70 EB 62 FC | 	wrlong	result1, objptr
02ed0                 | '         mph_x10 := distConv.fps2mph(ftPerSec_x10)
02ed0     04 E0 86 F1 | 	sub	objptr, #4
02ed4     70 F7 02 FB | 	rdlong	arg01, objptr
02ed8     49 E0 06 F1 | 	add	objptr, #73
02edc                 | ' '' Convert distance in ft/s to mi/hr
02edc                 | '     ' RULE: 1 ft/sec = 0.681818 mi/hr
02edc                 | '     fValue := float(nDistInFPS) *. kMPH_IN_FPS
02edc     7B F7 52 F6 | 	abs	arg01, arg01 wc
02ee0     1F 00 C7 C9 |  if_b	decod	local01, #31
02ee4     00 00 07 36 |  if_ae	mov	local01, #0
02ee8     74 03 B0 FD | 	call	#__system___float_fromuns
02eec     80 EB 62 F5 | 	xor	result1, local01
02ef0     75 F7 02 F6 | 	mov	arg01, result1
02ef4     45 97 1F FF 
02ef8     A0 F9 06 F6 | 	mov	arg02, ##1060015008
02efc     94 03 B0 FD | 	call	#__system___float_mul
02f00     75 F7 02 F6 | 	mov	arg01, result1
02f04                 | '     nDistInMPH := trunc(fValue)
02f04     00 F8 06 F6 | 	mov	arg02, #0
02f08     C8 07 B0 FD | 	call	#__system___float_tointeger
02f0c     41 E0 86 F1 | 	sub	objptr, #65
02f10     70 EB 62 FC | 	wrlong	result1, objptr
02f14                 | ' 
02f14                 | '         tvMaxMmPerSec_x10 := max(mmPerSec_x10, tvMaxMmPerSec_x10)
02f14     0C E0 86 F1 | 	sub	objptr, #12
02f18     70 F7 02 FB | 	rdlong	arg01, objptr
02f1c     20 E0 86 F1 | 	sub	objptr, #32
02f20     70 F9 02 FB | 	rdlong	arg02, objptr
02f24                 | ' ' return max of a or b
02f24                 | '     nMax := (a > b) ? a : b
02f24     7C F7 5A F2 | 	cmps	arg01, arg02 wcz
02f28     7B EB 02 16 |  if_a	mov	result1, arg01
02f2c     7C EB 02 E6 |  if_be	mov	result1, arg02
02f30     70 EB 62 FC | 	wrlong	result1, objptr
02f34                 | '         tvMaxFps_x10 := max(ftPerSec_x10, tvMaxFps_x10)
02f34     24 E0 06 F1 | 	add	objptr, #36
02f38     70 F7 02 FB | 	rdlong	arg01, objptr
02f3c     30 E0 86 F1 | 	sub	objptr, #48
02f40     70 F9 02 FB | 	rdlong	arg02, objptr
02f44                 | ' ' return max of a or b
02f44                 | '     nMax := (a > b) ? a : b
02f44     7C F7 5A F2 | 	cmps	arg01, arg02 wcz
02f48     7B EB 02 16 |  if_a	mov	result1, arg01
02f4c     7C EB 02 E6 |  if_be	mov	result1, arg02
02f50     70 EB 62 FC | 	wrlong	result1, objptr
02f54                 | '         tvMaxMPH_x10 := max(mph_x10, tvMaxMPH_x10)
02f54     38 E0 06 F1 | 	add	objptr, #56
02f58     70 F7 02 FB | 	rdlong	arg01, objptr
02f5c     34 E0 86 F1 | 	sub	objptr, #52
02f60     70 F9 02 FB | 	rdlong	arg02, objptr
02f64                 | ' ' return max of a or b
02f64                 | '     nMax := (a > b) ? a : b
02f64     7C F7 5A F2 | 	cmps	arg01, arg02 wcz
02f68     7B EB 02 16 |  if_a	mov	result1, arg01
02f6c     7C EB 02 E6 |  if_be	mov	result1, arg02
02f70     70 EB 62 FC | 	wrlong	result1, objptr
02f74                 | '         tvMaxkPH_x10 := max(kmh_x10, tvMaxkPH_x10)
02f74     30 E0 06 F1 | 	add	objptr, #48
02f78     70 F7 02 FB | 	rdlong	arg01, objptr
02f7c     2C E0 86 F1 | 	sub	objptr, #44
02f80     70 F9 02 FB | 	rdlong	arg02, objptr
02f84                 | ' ' return max of a or b
02f84                 | '     nMax := (a > b) ? a : b
02f84     7C F7 5A F2 | 	cmps	arg01, arg02 wcz
02f88     7B EB 02 16 |  if_a	mov	result1, arg01
02f8c     7C EB 02 E6 |  if_be	mov	result1, arg02
02f90     70 EB 62 FC | 	wrlong	result1, objptr
02f94     01 00 00 FF 
02f98     A3 E0 86 F1 | 	sub	objptr, ##675
02f9c     27 F1 03 F6 | 	mov	ptra, fp
02fa0     32 01 A0 FD | 	call	#popregs_
02fa4                 | _isp_bldc_motor_updateHdmiData_ret
02fa4     2D 00 64 FD | 	ret
02fa8                 | 
02fa8                 | ' 
02fa8                 | ' PUB circInMMforDiaInInchFloat(fDiaInch) : nCircInMM | fValue
02fa8                 | _isp_dist_utils_circInMMforDiaInInchFloat
02fa8     01 4A 06 F6 | 	mov	COUNT_, #1
02fac     28 01 A0 FD | 	call	#pushregs_
02fb0                 | ' '' Return circumference in mm for given diameter in inch
02fb0                 | '     ' RULE: circ = 2 * pi * r
02fb0                 | '     nCircInMM := 0
02fb0     00 00 07 F6 | 	mov	local01, #0
02fb4                 | '     if fDiaInch <> 0.0
02fb4     00 F6 0E F2 | 	cmp	arg01, #0 wz
02fb8     2C 00 90 AD |  if_e	jmp	#LR__0260
02fbc                 | '         fValue := fDiaInch *. kPI
02fbc     87 24 20 FF 
02fc0     D0 F9 06 F6 | 	mov	arg02, ##1078530000
02fc4     CC 02 B0 FD | 	call	#__system___float_mul
02fc8     75 F7 02 F6 | 	mov	arg01, result1
02fcc                 | '         nCircInMM := trunc(fValue *. kMM_IN_INCH)
02fcc     99 E5 20 FF 
02fd0     33 F9 06 F6 | 	mov	arg02, ##1103835955
02fd4     BC 02 B0 FD | 	call	#__system___float_mul
02fd8     75 F7 02 F6 | 	mov	arg01, result1
02fdc     00 F8 06 F6 | 	mov	arg02, #0
02fe0     F0 06 B0 FD | 	call	#__system___float_tointeger
02fe4     75 01 03 F6 | 	mov	local01, result1
02fe8                 | LR__0260
02fe8     80 EB 02 F6 | 	mov	result1, local01
02fec     27 F1 03 F6 | 	mov	ptra, fp
02ff0     32 01 A0 FD | 	call	#popregs_
02ff4                 | _isp_dist_utils_circInMMforDiaInInchFloat_ret
02ff4     2D 00 64 FD | 	ret
02ff8                 | hubexit
02ff8     01 01 80 FD | 	jmp	#cogexit
02ffc                 | 
02ffc                 | __system___getms
02ffc     1A EC 72 FD | 	getct	result2 wc
03000     1A F0 62 FD | 	getct	_var01
03004     0C E2 06 F1 | 	add	ptr___system__dat__, #12
03008     71 F3 0A FB | 	rdlong	_var02, ptr___system__dat__ wz
0300c     0C E2 86 F1 | 	sub	ptr___system__dat__, #12
03010     20 00 90 5D |  if_ne	jmp	#LR__0270
03014     14 F2 06 FB | 	rdlong	_var02, #20
03018     01 00 00 FF 
0301c     E8 F3 16 FD | 	qdiv	_var02, ##1000
03020     0C E2 06 F1 | 	add	ptr___system__dat__, #12
03024     18 EA 62 FD | 	getqx	result1
03028     75 F3 02 F6 | 	mov	_var02, result1
0302c     71 EB 62 FC | 	wrlong	result1, ptr___system__dat__
03030     0C E2 86 F1 | 	sub	ptr___system__dat__, #12
03034                 | LR__0270
03034     28 EC 62 FD | 	setq	result2
03038     79 F1 12 FD | 	qdiv	_var01, _var02
0303c     18 EA 62 FD | 	getqx	result1
03040                 | __system___getms_ret
03040     2D 00 64 FD | 	ret
03044                 | 
03044                 | __system____builtin_memmove
03044     7B EB 02 F6 | 	mov	result1, arg01
03048     7C F7 52 F2 | 	cmps	arg01, arg02 wc
0304c     10 00 90 CD |  if_b	jmp	#LR__0280
03050     7C F1 02 F6 | 	mov	_var01, arg02
03054     7D F1 02 F1 | 	add	_var01, arg03
03058     78 F7 52 F2 | 	cmps	arg01, _var01 wc
0305c     48 00 90 CD |  if_b	jmp	#LR__0286
03060                 | LR__0280
03060     7D F3 02 F6 | 	mov	_var02, arg03
03064     02 F2 4E F0 | 	shr	_var02, #2 wz
03068     18 00 90 AD |  if_e	jmp	#LR__0285
0306c     17 0B 48 FB | 	callpa	#(@LR__0283-@LR__0281)>>2,fcache_load_ptr_
03070                 | LR__0281
03070     79 09 D8 FC | 	rep	@LR__0284, _var02
03074                 | LR__0282
03074     7C F1 02 FB | 	rdlong	_var01, arg02
03078     7B F1 62 FC | 	wrlong	_var01, arg01
0307c     04 F6 06 F1 | 	add	arg01, #4
03080     04 F8 06 F1 | 	add	arg02, #4
03084                 | LR__0283
03084                 | LR__0284
03084                 | LR__0285
03084     02 FA CE F7 | 	test	arg03, #2 wz
03088     7C F1 E2 5A |  if_ne	rdword	_var01, arg02
0308c     7B F1 52 5C |  if_ne	wrword	_var01, arg01
03090     02 F6 06 51 |  if_ne	add	arg01, #2
03094     02 F8 06 51 |  if_ne	add	arg02, #2
03098     01 FA CE F7 | 	test	arg03, #1 wz
0309c     7C F1 C2 5A |  if_ne	rdbyte	_var01, arg02
030a0     7B F1 42 5C |  if_ne	wrbyte	_var01, arg01
030a4     28 00 90 FD | 	jmp	#LR__0292
030a8                 | LR__0286
030a8     7D F7 02 F1 | 	add	arg01, arg03
030ac     7D F9 02 F1 | 	add	arg02, arg03
030b0     7D F5 0A F6 | 	mov	_var03, arg03 wz
030b4     18 00 90 AD |  if_e	jmp	#LR__0291
030b8     17 0B 48 FB | 	callpa	#(@LR__0289-@LR__0287)>>2,fcache_load_ptr_
030bc                 | LR__0287
030bc     7A 09 D8 FC | 	rep	@LR__0290, _var03
030c0                 | LR__0288
030c0     01 F6 86 F1 | 	sub	arg01, #1
030c4     01 F8 86 F1 | 	sub	arg02, #1
030c8     7C F1 C2 FA | 	rdbyte	_var01, arg02
030cc     7B F1 42 FC | 	wrbyte	_var01, arg01
030d0                 | LR__0289
030d0                 | LR__0290
030d0                 | LR__0291
030d0                 | LR__0292
030d0                 | __system____builtin_memmove_ret
030d0     2D 00 64 FD | 	ret
030d4                 | 
030d4                 | __system__longmove
030d4     7B EB 02 F6 | 	mov	result1, arg01
030d8     7C F7 52 F2 | 	cmps	arg01, arg02 wc
030dc     24 00 90 3D |  if_ae	jmp	#LR__0304
030e0     7D F1 0A F6 | 	mov	_var01, arg03 wz
030e4     4C 00 90 AD |  if_e	jmp	#LR__0310
030e8     17 0B 48 FB | 	callpa	#(@LR__0302-@LR__0300)>>2,fcache_load_ptr_
030ec                 | LR__0300
030ec     78 09 D8 FC | 	rep	@LR__0303, _var01
030f0                 | LR__0301
030f0     7C F1 02 FB | 	rdlong	_var01, arg02
030f4     7B F1 62 FC | 	wrlong	_var01, arg01
030f8     04 F6 06 F1 | 	add	arg01, #4
030fc     04 F8 06 F1 | 	add	arg02, #4
03100                 | LR__0302
03100                 | LR__0303
03100     30 00 90 FD | 	jmp	#LR__0310
03104                 | LR__0304
03104     7D F3 02 F6 | 	mov	_var02, arg03
03108     02 F2 66 F0 | 	shl	_var02, #2
0310c     79 F7 02 F1 | 	add	arg01, _var02
03110     79 F9 02 F1 | 	add	arg02, _var02
03114     7D F5 0A F6 | 	mov	_var03, arg03 wz
03118     18 00 90 AD |  if_e	jmp	#LR__0309
0311c     17 0B 48 FB | 	callpa	#(@LR__0307-@LR__0305)>>2,fcache_load_ptr_
03120                 | LR__0305
03120     7A 09 D8 FC | 	rep	@LR__0308, _var03
03124                 | LR__0306
03124     04 F6 86 F1 | 	sub	arg01, #4
03128     04 F8 86 F1 | 	sub	arg02, #4
0312c     7C F5 02 FB | 	rdlong	_var03, arg02
03130     7B F5 62 FC | 	wrlong	_var03, arg01
03134                 | LR__0307
03134                 | LR__0308
03134                 | LR__0309
03134                 | LR__0310
03134                 | __system__longmove_ret
03134     2D 00 64 FD | 	ret
03138                 | 
03138                 | __system___lookup
03138     7C F7 82 F1 | 	sub	arg01, arg02
0313c     00 F6 56 F2 | 	cmps	arg01, #0 wc
03140     18 00 90 CD |  if_b	jmp	#LR__0320
03144     7E F7 52 F2 | 	cmps	arg01, arg04 wc
03148     7B F1 02 C6 |  if_b	mov	_var01, arg01
0314c     02 F0 66 C0 |  if_b	shl	_var01, #2
03150     7D F1 02 C1 |  if_b	add	_var01, arg03
03154     78 EB 02 CB |  if_b	rdlong	result1, _var01
03158     04 00 90 CD |  if_b	jmp	#__system___lookup_ret
0315c                 | LR__0320
0315c     00 EA 06 F6 | 	mov	result1, #0
03160                 | __system___lookup_ret
03160     2D 00 64 FD | 	ret
03164                 | 
03164                 | __system___lookdown
03164     00 F0 06 F6 | 	mov	_var01, #0
03168     01 FC 86 F1 | 	sub	arg04, #1
0316c     00 FC 56 F2 | 	cmps	arg04, #0 wc
03170     01 F2 86 F6 | 	negc	_var02, #1
03174     79 FD 02 F1 | 	add	arg04, _var02
03178                 | LR__0330
03178     7D F5 02 FB | 	rdlong	_var03, arg03
0317c     7B F5 0A F2 | 	cmp	_var03, arg01 wz
03180     78 EB 02 A6 |  if_e	mov	result1, _var01
03184     7C EB 02 A1 |  if_e	add	result1, arg02
03188     14 00 90 AD |  if_e	jmp	#__system___lookdown_ret
0318c     04 FA 06 F1 | 	add	arg03, #4
03190     79 F1 02 F1 | 	add	_var01, _var02
03194     7E F1 0A F2 | 	cmp	_var01, arg04 wz
03198     DC FF 9F 5D |  if_ne	jmp	#LR__0330
0319c     00 EA 06 F6 | 	mov	result1, #0
031a0                 | __system___lookdown_ret
031a0     2D 00 64 FD | 	ret
031a4                 | 
031a4                 | __system____builtin_strncpy
031a4     02 4A 06 F6 | 	mov	COUNT_, #2
031a8     28 01 A0 FD | 	call	#pushregs_
031ac     7B 01 03 F6 | 	mov	local01, arg01
031b0     7C F7 02 F6 | 	mov	arg01, arg02
031b4     7B 03 03 F6 | 	mov	local02, arg01
031b8     17 07 48 FB | 	callpa	#(@LR__0341-@LR__0340)>>2,fcache_load_ptr_
031bc                 | LR__0340
031bc     81 EB CA FA | 	rdbyte	result1, local02 wz
031c0     01 02 07 51 |  if_ne	add	local02, #1
031c4     F4 FF 9F 5D |  if_ne	jmp	#LR__0340
031c8                 | LR__0341
031c8     7B 03 83 F1 | 	sub	local02, arg01
031cc     7D 03 63 F3 | 	fles	local02, arg03
031d0     80 F7 02 F6 | 	mov	arg01, local01
031d4     81 FB 02 F6 | 	mov	arg03, local02
031d8     68 FE BF FD | 	call	#__system____builtin_memmove
031dc     80 03 03 F1 | 	add	local02, local01
031e0     81 01 48 FC | 	wrbyte	#0, local02
031e4     80 EB 02 F6 | 	mov	result1, local01
031e8     27 F1 03 F6 | 	mov	ptra, fp
031ec     32 01 A0 FD | 	call	#popregs_
031f0                 | __system____builtin_strncpy_ret
031f0     2D 00 64 FD | 	ret
031f4                 | 
031f4                 | __system___waitms
031f4     7B F1 02 F6 | 	mov	_var01, arg01
031f8     1A F2 62 FD | 	getct	_var02
031fc     14 F4 06 FB | 	rdlong	_var03, #20
03200     17 15 48 FB | 	callpa	#(@LR__0351-@LR__0350)>>2,fcache_load_ptr_
03204                 | LR__0350
03204     01 00 00 FF 
03208     E8 F1 56 F2 | 	cmps	_var01, ##1000 wc
0320c     1C 00 90 CD |  if_b	jmp	#LR__0352
03210     7A F3 02 F1 | 	add	_var02, _var03
03214     79 F7 02 F6 | 	mov	arg01, _var02
03218     00 F6 66 FA | 	addct1	arg01, #0
0321c     24 22 60 FD | 	waitct1
03220     01 00 00 FF 
03224     E8 F1 86 F1 | 	sub	_var01, ##1000
03228     D8 FF 9F FD | 	jmp	#LR__0350
0322c                 | LR__0351
0322c                 | LR__0352
0322c     01 F0 56 F2 | 	cmps	_var01, #1 wc
03230     28 00 90 CD |  if_b	jmp	#LR__0353
03234     7A F1 02 FD | 	qmul	_var01, _var03
03238     01 00 00 FF 
0323c     E8 FB 06 F6 | 	mov	arg03, ##1000
03240     19 EA 62 FD | 	getqy	result1
03244     18 F6 62 FD | 	getqx	arg01
03248     28 EA 62 FD | 	setq	result1
0324c     7D F7 12 FD | 	qdiv	arg01, arg03
03250     18 F6 62 FD | 	getqx	arg01
03254     79 F7 62 FA | 	addct1	arg01, _var02
03258     24 22 60 FD | 	waitct1
0325c                 | LR__0353
0325c                 | __system___waitms_ret
0325c     2D 00 64 FD | 	ret
03260                 | 
03260                 | __system___float_fromuns
03260     7B FB 0A F6 | 	mov	arg03, arg01 wz
03264     7D EB 02 A6 |  if_e	mov	result1, arg03
03268     24 00 90 AD |  if_e	jmp	#LR__0360
0326c     7D F9 92 F7 | 	encod	arg02, arg03 wc
03270     01 F8 06 C1 |  if_b	add	arg02, #1
03274     01 F8 86 F1 | 	sub	arg02, #1
03278     1F F6 06 F6 | 	mov	arg01, #31
0327c     7C F7 82 F1 | 	sub	arg01, arg02
03280     7B FB 62 F0 | 	shl	arg03, arg01
03284     02 FA 46 F0 | 	shr	arg03, #2
03288     00 F6 06 F6 | 	mov	arg01, #0
0328c     F8 04 B0 FD | 	call	#__system___float_Pack
03290                 | LR__0360
03290                 | __system___float_fromuns_ret
03290     2D 00 64 FD | 	ret
03294                 | 
03294                 | __system___float_mul
03294     0C 4A 06 F6 | 	mov	COUNT_, #12
03298     28 01 A0 FD | 	call	#pushregs_
0329c     7B 01 03 F6 | 	mov	local01, arg01
032a0     7C 03 03 F6 | 	mov	local02, arg02
032a4     80 05 03 F6 | 	mov	local03, local01
032a8     82 07 03 F6 | 	mov	local04, local03
032ac     16 06 47 F7 | 	zerox	local04, #22
032b0     82 09 03 F6 | 	mov	local05, local03
032b4     01 08 67 F0 | 	shl	local05, #1
032b8     18 08 47 F0 | 	shr	local05, #24
032bc     1F 04 47 F0 | 	shr	local03, #31
032c0     81 EB 02 F6 | 	mov	result1, local02
032c4     75 0B 03 F6 | 	mov	local06, result1
032c8     85 0D 03 F6 | 	mov	local07, local06
032cc     16 0C 47 F7 | 	zerox	local07, #22
032d0     85 0F 03 F6 | 	mov	local08, local06
032d4     01 0E 67 F0 | 	shl	local08, #1
032d8     18 0E 47 F0 | 	shr	local08, #24
032dc     1F 0A 47 F0 | 	shr	local06, #31
032e0     85 05 63 F5 | 	xor	local03, local06
032e4     FF 08 0F F2 | 	cmp	local05, #255 wz
032e8     7C 00 90 AD |  if_e	jmp	#LR__0373
032ec     FF 0E 0F F2 | 	cmp	local08, #255 wz
032f0     C4 00 90 AD |  if_e	jmp	#LR__0375
032f4     00 08 0F F2 | 	cmp	local05, #0 wz
032f8     F8 00 90 AD |  if_e	jmp	#LR__0376
032fc     17 06 27 F4 | 	bith	local04, #23
03300                 | LR__0370
03300     00 0E 0F F2 | 	cmp	local08, #0 wz
03304     34 01 90 AD |  if_e	jmp	#LR__0380
03308     17 0C 27 F4 | 	bith	local07, #23
0330c                 | LR__0371
0330c     04 06 67 F0 | 	shl	local04, #4
03310     05 0C 67 F0 | 	shl	local07, #5
03314     86 07 03 FD | 	qmul	local04, local07
03318     84 11 03 F6 | 	mov	local09, local05
0331c     87 11 03 F1 | 	add	local09, local08
03320     FE 10 87 F1 | 	sub	local09, #254
03324     18 12 63 FD | 	getqx	local10
03328     19 14 63 FD | 	getqy	local11
0332c     00 80 00 FF 
03330     00 14 17 F2 | 	cmp	local11, ##16777216 wc
03334     18 00 90 CD |  if_b	jmp	#LR__0372
03338     01 10 07 F1 | 	add	local09, #1
0333c     01 12 47 F0 | 	shr	local10, #1
03340     8A 0F 03 F6 | 	mov	local08, local11
03344     1F 0E 67 F0 | 	shl	local08, #31
03348     87 13 43 F5 | 	or	local10, local08
0334c     01 14 47 F0 | 	shr	local11, #1
03350                 | LR__0372
03350     8A F7 02 F6 | 	mov	arg01, local11
03354     89 F9 02 F6 | 	mov	arg02, local10
03358     88 FB 02 F6 | 	mov	arg03, local09
0335c     82 FD 02 F6 | 	mov	arg04, local03
03360     B8 04 B0 FD | 	call	#__system__pack_0116
03364     10 01 90 FD | 	jmp	#LR__0384
03368                 | LR__0373
03368     00 06 0F F2 | 	cmp	local04, #0 wz
0336c     80 EB 02 56 |  if_ne	mov	result1, local01
03370     04 01 90 5D |  if_ne	jmp	#LR__0384
03374     FF 0E 57 F2 | 	cmps	local08, #255 wc
03378     00 0E 0F C2 |  if_b	cmp	local08, #0 wz
0337c     00 0C 0F 82 |  if_c_and_z	cmp	local07, #0 wz
03380     18 00 90 4D |  if_c_and_nz	jmp	#LR__0374
03384     00 F8 3F CF 
03388     00 EA 06 C6 |  if_b	mov	result1, ##2146435072
0338c     E8 00 90 CD |  if_b	jmp	#LR__0384
03390     00 0C 0F F2 | 	cmp	local07, #0 wz
03394     81 EB 02 56 |  if_ne	mov	result1, local02
03398     DC 00 90 5D |  if_ne	jmp	#LR__0384
0339c                 | LR__0374
0339c     02 04 47 F5 | 	or	local03, #2
033a0     00 F6 06 F6 | 	mov	arg01, #0
033a4     00 F8 06 F6 | 	mov	arg02, #0
033a8     84 FB 02 F6 | 	mov	arg03, local05
033ac     82 FD 02 F6 | 	mov	arg04, local03
033b0     68 04 B0 FD | 	call	#__system__pack_0116
033b4     C0 00 90 FD | 	jmp	#LR__0384
033b8                 | LR__0375
033b8     00 08 0F F2 | 	cmp	local05, #0 wz
033bc     00 06 0F A2 |  if_e	cmp	local04, #0 wz
033c0     00 F8 3F AF 
033c4     00 EA 06 A6 |  if_e	mov	result1, ##2146435072
033c8     AC 00 90 AD |  if_e	jmp	#LR__0384
033cc     00 0C 0F F2 | 	cmp	local07, #0 wz
033d0     81 EB 02 56 |  if_ne	mov	result1, local02
033d4     A0 00 90 5D |  if_ne	jmp	#LR__0384
033d8     82 FD 02 F6 | 	mov	arg04, local03
033dc     02 FC 46 F5 | 	or	arg04, #2
033e0     87 FB 02 F6 | 	mov	arg03, local08
033e4     00 F6 06 F6 | 	mov	arg01, #0
033e8     00 F8 06 F6 | 	mov	arg02, #0
033ec     2C 04 B0 FD | 	call	#__system__pack_0116
033f0     84 00 90 FD | 	jmp	#LR__0384
033f4                 | LR__0376
033f4     00 06 0F F2 | 	cmp	local04, #0 wz
033f8     24 00 90 AD |  if_e	jmp	#LR__0379
033fc     17 0F 48 FB | 	callpa	#(@LR__0378-@LR__0377)>>2,fcache_load_ptr_
03400                 | LR__0377
03400     01 06 67 F0 | 	shl	local04, #1
03404     00 40 00 FF 
03408     00 06 17 F2 | 	cmp	local04, ##8388608 wc
0340c     84 17 03 C6 |  if_b	mov	local12, local05
03410     01 16 87 C1 |  if_b	sub	local12, #1
03414     8B 09 03 C6 |  if_b	mov	local05, local12
03418     E4 FF 9F CD |  if_b	jmp	#LR__0377
0341c                 | LR__0378
0341c     E0 FE 9F FD | 	jmp	#LR__0370
03420                 | LR__0379
03420     08 04 47 F5 | 	or	local03, #8
03424     00 F6 06 F6 | 	mov	arg01, #0
03428     00 F8 06 F6 | 	mov	arg02, #0
0342c     00 FA 06 F6 | 	mov	arg03, #0
03430     82 FD 02 F6 | 	mov	arg04, local03
03434     E4 03 B0 FD | 	call	#__system__pack_0116
03438     3C 00 90 FD | 	jmp	#LR__0384
0343c                 | LR__0380
0343c     00 0C 0F F2 | 	cmp	local07, #0 wz
03440     1C 00 90 AD |  if_e	jmp	#LR__0383
03444     17 0B 48 FB | 	callpa	#(@LR__0382-@LR__0381)>>2,fcache_load_ptr_
03448                 | LR__0381
03448     01 0C 67 F0 | 	shl	local07, #1
0344c     00 40 00 FF 
03450     00 0C 17 F2 | 	cmp	local07, ##8388608 wc
03454     01 0E 87 C1 |  if_b	sub	local08, #1
03458     EC FF 9F CD |  if_b	jmp	#LR__0381
0345c                 | LR__0382
0345c     AC FE 9F FD | 	jmp	#LR__0371
03460                 | LR__0383
03460     08 04 47 F5 | 	or	local03, #8
03464     00 F6 06 F6 | 	mov	arg01, #0
03468     00 F8 06 F6 | 	mov	arg02, #0
0346c     00 FA 06 F6 | 	mov	arg03, #0
03470     82 FD 02 F6 | 	mov	arg04, local03
03474     A4 03 B0 FD | 	call	#__system__pack_0116
03478                 | LR__0384
03478     27 F1 03 F6 | 	mov	ptra, fp
0347c     32 01 A0 FD | 	call	#popregs_
03480                 | __system___float_mul_ret
03480     2D 00 64 FD | 	ret
03484                 | 
03484                 | __system___float_div
03484     16 4A 06 F6 | 	mov	COUNT_, #22
03488     28 01 A0 FD | 	call	#pushregs_
0348c     7B 05 03 F6 | 	mov	local03, arg01
03490     7C 07 03 F6 | 	mov	local04, arg02
03494     82 09 03 F6 | 	mov	local05, local03
03498     84 0B 03 F6 | 	mov	local06, local05
0349c     09 0A 67 F0 | 	shl	local06, #9
034a0     85 0D 03 F6 | 	mov	local07, local06
034a4     09 0C 47 F0 | 	shr	local07, #9
034a8     86 0F 03 F6 | 	mov	local08, local07
034ac     84 11 03 F6 | 	mov	local09, local05
034b0     01 10 67 F0 | 	shl	local09, #1
034b4     88 13 03 F6 | 	mov	local10, local09
034b8     18 12 47 F0 | 	shr	local10, #24
034bc     89 15 03 F6 | 	mov	local11, local10
034c0     1F 08 47 F0 | 	shr	local05, #31
034c4     83 EB 02 F6 | 	mov	result1, local04
034c8     75 17 03 F6 | 	mov	local12, result1
034cc     8B 19 03 F6 | 	mov	local13, local12
034d0     09 18 67 F0 | 	shl	local13, #9
034d4     8C 1B 03 F6 | 	mov	local14, local13
034d8     09 1A 47 F0 | 	shr	local14, #9
034dc     8D 1D 03 F6 | 	mov	local15, local14
034e0     8B 1F 03 F6 | 	mov	local16, local12
034e4     01 1E 67 F0 | 	shl	local16, #1
034e8     8F 21 03 F6 | 	mov	local17, local16
034ec     18 20 47 F0 | 	shr	local17, #24
034f0     90 23 03 F6 | 	mov	local18, local17
034f4     1F 16 47 F0 | 	shr	local12, #31
034f8     8B 09 63 F5 | 	xor	local05, local12
034fc     FF 14 0F F2 | 	cmp	local11, #255 wz
03500     D4 00 90 AD |  if_e	jmp	#LR__0395
03504     FF 22 0F F2 | 	cmp	local18, #255 wz
03508     04 01 90 AD |  if_e	jmp	#LR__0396
0350c     00 14 0F F2 | 	cmp	local11, #0 wz
03510     24 01 90 AD |  if_e	jmp	#LR__0397
03514     17 0E 27 F4 | 	bith	local08, #23
03518                 | LR__0390
03518     00 22 0F F2 | 	cmp	local18, #0 wz
0351c     6C 01 90 AD |  if_e	jmp	#LR__0401
03520     17 1C 27 F4 | 	bith	local15, #23
03524                 | LR__0391
03524     8A 25 03 F6 | 	mov	local19, local11
03528     91 25 83 F1 | 	sub	local19, local18
0352c     87 F7 02 F6 | 	mov	arg01, local08
03530     02 F6 46 F0 | 	shr	arg01, #2
03534     87 F9 02 F6 | 	mov	arg02, local08
03538     1E F8 66 F0 | 	shl	arg02, #30
0353c     8E FB 02 F6 | 	mov	arg03, local15
03540     28 F6 62 FD | 	setq	arg01
03544     7D F9 12 FD | 	qdiv	arg02, arg03
03548     00 26 07 F6 | 	mov	local20, #0
0354c     18 00 63 FD | 	getqx	local01
03550     19 EC 62 FD | 	getqy	result2
03554     76 03 03 F6 | 	mov	local02, result2
03558     80 29 03 F6 | 	mov	local21, local01
0355c     00 02 4F F2 | 	cmps	local02, #0 wz
03560     94 2B 03 F6 | 	mov	local22, local21
03564     19 2A 67 F0 | 	shl	local22, #25
03568     01 26 07 56 |  if_ne	mov	local20, #1
0356c     93 2B 43 F5 | 	or	local22, local20
03570     07 28 47 F0 | 	shr	local21, #7
03574     00 80 00 FF 
03578     00 28 17 F2 | 	cmp	local21, ##16777216 wc
0357c     1C 00 90 CD |  if_b	jmp	#LR__0392
03580     01 24 07 F1 | 	add	local19, #1
03584     01 2A 47 F0 | 	shr	local22, #1
03588     94 27 03 F6 | 	mov	local20, local21
0358c     1F 26 67 F0 | 	shl	local20, #31
03590     93 2B 43 F5 | 	or	local22, local20
03594     01 28 47 F0 | 	shr	local21, #1
03598     24 00 90 FD | 	jmp	#LR__0394
0359c                 | LR__0392
0359c     00 40 00 FF 
035a0     00 28 17 F2 | 	cmp	local21, ##8388608 wc
035a4     18 00 90 3D |  if_ae	jmp	#LR__0393
035a8     01 24 87 F1 | 	sub	local19, #1
035ac     01 28 67 F0 | 	shl	local21, #1
035b0     95 27 03 F6 | 	mov	local20, local22
035b4     1F 26 47 F0 | 	shr	local20, #31
035b8     93 29 43 F5 | 	or	local21, local20
035bc     01 2A 67 F0 | 	shl	local22, #1
035c0                 | LR__0393
035c0                 | LR__0394
035c0     94 F7 02 F6 | 	mov	arg01, local21
035c4     95 F9 02 F6 | 	mov	arg02, local22
035c8     92 FB 02 F6 | 	mov	arg03, local19
035cc     84 FD 02 F6 | 	mov	arg04, local05
035d0     48 02 B0 FD | 	call	#__system__pack_0116
035d4     F0 00 90 FD | 	jmp	#LR__0405
035d8                 | LR__0395
035d8     00 0E 0F F2 | 	cmp	local08, #0 wz
035dc     82 EB 02 56 |  if_ne	mov	result1, local03
035e0     E4 00 90 5D |  if_ne	jmp	#LR__0405
035e4     FF 22 0F F2 | 	cmp	local18, #255 wz
035e8     00 F8 3F AF 
035ec     00 EA 06 A6 |  if_e	mov	result1, ##2146435072
035f0     D4 00 90 AD |  if_e	jmp	#LR__0405
035f4     02 08 47 F5 | 	or	local05, #2
035f8     00 F6 06 F6 | 	mov	arg01, #0
035fc     00 F8 06 F6 | 	mov	arg02, #0
03600     8A FB 02 F6 | 	mov	arg03, local11
03604     84 FD 02 F6 | 	mov	arg04, local05
03608     10 02 B0 FD | 	call	#__system__pack_0116
0360c     B8 00 90 FD | 	jmp	#LR__0405
03610                 | LR__0396
03610     00 1C 0F F2 | 	cmp	local15, #0 wz
03614     83 EB 02 56 |  if_ne	mov	result1, local04
03618     AC 00 90 5D |  if_ne	jmp	#LR__0405
0361c     84 FD 02 F6 | 	mov	arg04, local05
03620     08 FC 46 F5 | 	or	arg04, #8
03624     00 F6 06 F6 | 	mov	arg01, #0
03628     00 F8 06 F6 | 	mov	arg02, #0
0362c     00 FA 06 F6 | 	mov	arg03, #0
03630     E8 01 B0 FD | 	call	#__system__pack_0116
03634     90 00 90 FD | 	jmp	#LR__0405
03638                 | LR__0397
03638     00 0E 0F F2 | 	cmp	local08, #0 wz
0363c     1C 00 90 AD |  if_e	jmp	#LR__0400
03640     17 0B 48 FB | 	callpa	#(@LR__0399-@LR__0398)>>2,fcache_load_ptr_
03644                 | LR__0398
03644     01 0E 67 F0 | 	shl	local08, #1
03648     00 40 00 FF 
0364c     00 0E 17 F2 | 	cmp	local08, ##8388608 wc
03650     01 14 87 C1 |  if_b	sub	local11, #1
03654     EC FF 9F CD |  if_b	jmp	#LR__0398
03658                 | LR__0399
03658     BC FE 9F FD | 	jmp	#LR__0390
0365c                 | LR__0400
0365c     00 22 0F F2 | 	cmp	local18, #0 wz
03660     00 1C 0F A2 |  if_e	cmp	local15, #0 wz
03664     00 F8 3F AF 
03668     00 EA 06 A6 |  if_e	mov	result1, ##2146435072
0366c     58 00 90 AD |  if_e	jmp	#LR__0405
03670     84 FD 02 F6 | 	mov	arg04, local05
03674     08 FC 46 F5 | 	or	arg04, #8
03678     00 F6 06 F6 | 	mov	arg01, #0
0367c     00 F8 06 F6 | 	mov	arg02, #0
03680     00 FA 06 F6 | 	mov	arg03, #0
03684     94 01 B0 FD | 	call	#__system__pack_0116
03688     3C 00 90 FD | 	jmp	#LR__0405
0368c                 | LR__0401
0368c     00 1C 0F F2 | 	cmp	local15, #0 wz
03690     1C 00 90 AD |  if_e	jmp	#LR__0404
03694     17 0B 48 FB | 	callpa	#(@LR__0403-@LR__0402)>>2,fcache_load_ptr_
03698                 | LR__0402
03698     01 1C 67 F0 | 	shl	local15, #1
0369c     00 40 00 FF 
036a0     00 1C 17 F2 | 	cmp	local15, ##8388608 wc
036a4     01 22 87 C1 |  if_b	sub	local18, #1
036a8     EC FF 9F CD |  if_b	jmp	#LR__0402
036ac                 | LR__0403
036ac     74 FE 9F FD | 	jmp	#LR__0391
036b0                 | LR__0404
036b0     02 08 47 F5 | 	or	local05, #2
036b4     00 F6 06 F6 | 	mov	arg01, #0
036b8     00 F8 06 F6 | 	mov	arg02, #0
036bc     00 FA 06 F6 | 	mov	arg03, #0
036c0     84 FD 02 F6 | 	mov	arg04, local05
036c4     54 01 B0 FD | 	call	#__system__pack_0116
036c8                 | LR__0405
036c8     27 F1 03 F6 | 	mov	ptra, fp
036cc     32 01 A0 FD | 	call	#popregs_
036d0                 | __system___float_div_ret
036d0     2D 00 64 FD | 	ret
036d4                 | 
036d4                 | __system___float_tointeger
036d4     02 4A 06 F6 | 	mov	COUNT_, #2
036d8     28 01 A0 FD | 	call	#pushregs_
036dc     5C 00 B0 FD | 	call	#__system___float_Unpack
036e0     75 01 03 F6 | 	mov	local01, result1
036e4     1F EC 56 F2 | 	cmps	result2, #31 wc
036e8     00 00 0F 32 |  if_ae	cmp	local01, #0 wz
036ec     1F 02 C7 19 |  if_a	decod	local02, #31
036f0     1E 02 CF 29 |  if_nc_and_z	bmask	local02, #30
036f4     81 EF 02 36 |  if_ae	mov	result3, local02
036f8     30 00 90 3D |  if_ae	jmp	#LR__0411
036fc     FF FF 7F FF 
03700     FF ED 56 F2 | 	cmps	result2, ##-1 wc
03704     00 EE 06 C6 |  if_b	mov	result3, #0
03708     20 00 90 CD |  if_b	jmp	#LR__0410
0370c     02 EE 66 F0 | 	shl	result3, #2
03710     1E 02 07 F6 | 	mov	local02, #30
03714     76 03 83 F1 | 	sub	local02, result2
03718     81 EF 42 F0 | 	shr	result3, local02
0371c     7C EF 02 F1 | 	add	result3, arg02
03720     01 EE 46 F0 | 	shr	result3, #1
03724     00 00 0F F2 | 	cmp	local01, #0 wz
03728     77 EF 62 56 |  if_ne	neg	result3, result3
0372c                 | LR__0410
0372c                 | LR__0411
0372c     77 EB 02 F6 | 	mov	result1, result3
03730     27 F1 03 F6 | 	mov	ptra, fp
03734     32 01 A0 FD | 	call	#popregs_
03738                 | __system___float_tointeger_ret
03738     2D 00 64 FD | 	ret
0373c                 | 
0373c                 | __system___float_Unpack
0373c     7B EB 02 F6 | 	mov	result1, arg01
03740     1F EA 46 F0 | 	shr	result1, #31
03744     7B ED 02 F6 | 	mov	result2, arg01
03748     01 EC 66 F0 | 	shl	result2, #1
0374c     18 EC 4E F0 | 	shr	result2, #24 wz
03750     17 F7 06 F4 | 	bitl	arg01, #279
03754     06 F6 66 50 |  if_ne	shl	arg01, #6
03758     1D F6 26 54 |  if_ne	bith	arg01, #29
0375c     1C 00 90 5D |  if_ne	jmp	#LR__0420
03760     7B F1 92 F7 | 	encod	_var01, arg01 wc
03764     01 F0 06 C1 |  if_b	add	_var01, #1
03768     17 F0 86 F1 | 	sub	_var01, #23
0376c     78 ED 02 F6 | 	mov	result2, _var01
03770     07 EE 06 F6 | 	mov	result3, #7
03774     78 EF 82 F1 | 	sub	result3, _var01
03778     77 F7 62 F0 | 	shl	arg01, result3
0377c                 | LR__0420
0377c     7F EC 86 F1 | 	sub	result2, #127
03780     7B EF 02 F6 | 	mov	result3, arg01
03784                 | __system___float_Unpack_ret
03784     2D 00 64 FD | 	ret
03788                 | 
03788                 | __system___float_Pack
03788     00 F0 06 F6 | 	mov	_var01, #0
0378c     00 FA 0E F2 | 	cmp	arg03, #0 wz
03790     80 00 90 AD |  if_e	jmp	#LR__0431
03794     7D F3 92 F7 | 	encod	_var02, arg03 wc
03798     01 F2 06 C1 |  if_b	add	_var02, #1
0379c     21 F0 06 F6 | 	mov	_var01, #33
037a0     79 F1 82 F1 | 	sub	_var01, _var02
037a4     78 FB 62 F0 | 	shl	arg03, _var01
037a8     03 F2 06 F6 | 	mov	_var02, #3
037ac     78 F3 82 F1 | 	sub	_var02, _var01
037b0     79 F9 02 F1 | 	add	arg02, _var02
037b4     00 FB 06 F1 | 	add	arg03, #256
037b8     7D F3 02 F6 | 	mov	_var02, arg03
037bc     FF F2 2E F5 | 	andn	_var02, #255 wz
037c0     01 F8 06 A1 |  if_e	add	arg02, #1
037c4     7F F8 06 F1 | 	add	arg02, #127
037c8     FF FF 7F FF 
037cc     E9 F9 46 F3 | 	fges	arg02, ##-23
037d0     FF F8 66 F3 | 	fles	arg02, #255
037d4     01 F8 56 F2 | 	cmps	arg02, #1 wc
037d8     1C 00 90 3D |  if_ae	jmp	#LR__0430
037dc     01 FA 46 F0 | 	shr	arg03, #1
037e0     1F F2 C6 F9 | 	decod	_var02, #31
037e4     7D F3 02 F1 | 	add	_var02, arg03
037e8     7C F9 62 F6 | 	neg	arg02, arg02
037ec     7C F3 42 F0 | 	shr	_var02, arg02
037f0     79 FB 02 F6 | 	mov	arg03, _var02
037f4     00 F8 06 F6 | 	mov	arg02, #0
037f8                 | LR__0430
037f8     1F F6 66 F0 | 	shl	arg01, #31
037fc     7B EB 02 F6 | 	mov	result1, arg01
03800     17 F8 66 F0 | 	shl	arg02, #23
03804     7C EB 42 F5 | 	or	result1, arg02
03808     09 FA 46 F0 | 	shr	arg03, #9
0380c     7D EB 42 F5 | 	or	result1, arg03
03810     04 00 90 FD | 	jmp	#__system___float_Pack_ret
03814                 | LR__0431
03814     78 EB 02 F6 | 	mov	result1, _var01
03818                 | __system___float_Pack_ret
03818     2D 00 64 FD | 	ret
0381c                 | 
0381c                 | __system__pack_0116
0381c     7B F1 02 F6 | 	mov	_var01, arg01
03820     7F FA 06 F1 | 	add	arg03, #127
03824     04 FC CE F7 | 	test	arg04, #4 wz
03828     10 00 90 AD |  if_e	jmp	#LR__0440
0382c     00 F0 0E F2 | 	cmp	_var01, #0 wz
03830     16 F0 C6 A9 |  if_e	decod	_var01, #22
03834     F7 F0 26 F4 | 	bith	_var01, #247
03838     AC 00 90 FD | 	jmp	#LR__0449
0383c                 | LR__0440
0383c     02 FC CE F7 | 	test	arg04, #2 wz
03840     00 C0 3F 5F 
03844     00 F0 06 56 |  if_ne	mov	_var01, ##2139095040
03848     00 F8 06 56 |  if_ne	mov	arg02, #0
0384c     98 00 90 5D |  if_ne	jmp	#LR__0448
03850     08 FC CE F7 | 	test	arg04, #8 wz
03854     00 F0 06 56 |  if_ne	mov	_var01, #0
03858     8C 00 90 5D |  if_ne	jmp	#LR__0447
0385c     FF FA 56 F2 | 	cmps	arg03, #255 wc
03860     00 C0 3F 3F 
03864     00 F0 06 36 |  if_ae	mov	_var01, ##2139095040
03868     00 F8 06 36 |  if_ae	mov	arg02, #0
0386c     78 00 90 3D |  if_ae	jmp	#LR__0446
03870     01 FA 56 F2 | 	cmps	arg03, #1 wc
03874     64 00 90 3D |  if_ae	jmp	#LR__0444
03878     01 F8 46 F0 | 	shr	arg02, #1
0387c     78 F3 02 F6 | 	mov	_var02, _var01
03880     01 F2 06 F5 | 	and	_var02, #1
03884     1F F2 66 F0 | 	shl	_var02, #31
03888     17 1F 48 FB | 	callpa	#(@LR__0442-@LR__0441)>>2,fcache_load_ptr_
0388c                 | LR__0441
0388c     79 F9 42 F5 | 	or	arg02, _var02
03890     01 F0 46 F0 | 	shr	_var01, #1
03894     00 FA 56 F2 | 	cmps	arg03, #0 wc
03898     2C 00 90 3D |  if_ae	jmp	#LR__0443
0389c     00 F0 0E F2 | 	cmp	_var01, #0 wz
038a0     24 00 90 AD |  if_e	jmp	#LR__0443
038a4     7C F3 02 F6 | 	mov	_var02, arg02
038a8     01 F2 06 F5 | 	and	_var02, #1
038ac     01 FA 06 F1 | 	add	arg03, #1
038b0     01 F8 46 F0 | 	shr	arg02, #1
038b4     78 F7 02 F6 | 	mov	arg01, _var01
038b8     01 F6 06 F5 | 	and	arg01, #1
038bc     1F F6 66 F0 | 	shl	arg01, #31
038c0     7B F9 42 F5 | 	or	arg02, arg01
038c4     C4 FF 9F FD | 	jmp	#LR__0441
038c8                 | LR__0442
038c8                 | LR__0443
038c8     00 FA 56 F2 | 	cmps	arg03, #0 wc
038cc     18 00 90 3D |  if_ae	jmp	#LR__0445
038d0     00 F8 0E F2 | 	cmp	arg02, #0 wz
038d4     6F F8 62 FD | 	wrnz	arg02
038d8     0C 00 90 FD | 	jmp	#LR__0445
038dc                 | LR__0444
038dc     17 F1 06 F4 | 	bitl	_var01, #279
038e0     17 FA 66 F0 | 	shl	arg03, #23
038e4     7D F1 42 F5 | 	or	_var01, arg03
038e8                 | LR__0445
038e8                 | LR__0446
038e8                 | LR__0447
038e8                 | LR__0448
038e8                 | LR__0449
038e8     01 F0 CE F7 | 	test	_var01, #1 wz
038ec     01 F8 46 55 |  if_ne	or	arg02, #1
038f0     7C F3 02 F6 | 	mov	_var02, arg02
038f4     00 FA 06 F6 | 	mov	arg03, #0
038f8     FF FF 3F FF 
038fc     FF F9 06 F1 | 	add	arg02, ##2147483647
03900     79 F9 12 F2 | 	cmp	arg02, _var02 wc
03904     01 FA 06 C6 |  if_b	mov	arg03, #1
03908     7D F1 02 F1 | 	add	_var01, arg03
0390c     01 FC CE F7 | 	test	arg04, #1 wz
03910     1F F0 26 54 |  if_ne	bith	_var01, #31
03914     78 EB 02 F6 | 	mov	result1, _var01
03918                 | __system__pack_0116_ret
03918     2D 00 64 FD | 	ret
0391c                 | 
0391c                 | LR__0450
0391c     6C 74 4D 6F 
03920     74          | 	byte	"ltMot"
03921     00          | 	byte	0
03922                 | LR__0451
03922     72 74 4D 6F 
03926     74          | 	byte	"rtMot"
03927     00          | 	byte	0
03928                 | LR__0452
03928     6C 74 4D 6F 
0392c     74          | 	byte	"ltMot"
0392d     00          | 	byte	0
0392e                 | LR__0453
0392e     72 74 4D 6F 
03932     74          | 	byte	"rtMot"
03933     00          | 	byte	0
03934                 | LR__0454
03934     6C 74 4D 6F 
03938     74          | 	byte	"ltMot"
03939     00          | 	byte	0
0393a                 | LR__0455
0393a     72 74 4D 6F 
0393e     74          | 	byte	"rtMot"
0393f     00          | 	byte	0
03940                 | LR__0456
03940     6C 74 4D 6F 
03944     74          | 	byte	"ltMot"
03945     00          | 	byte	0
03946                 | LR__0457
03946     72 74 4D 6F 
0394a     74          | 	byte	"rtMot"
0394b     00          | 	byte	0
0394c                 | 	alignl
0394c                 | _isp_steering_2wheel_dat_
0394c                 | 
0394c     00 00 00 00 | ltFaultSeenMS    long  0
03950     00 00 00 00 | rtFaultSeenMS    long  0
03954                 | 
03954     64 73 55 6E 
03958     6B 00       |     dsUnknown       BYTE    "dsUnk",0
0395a     64 73 4D 6F 
0395e     76 00       |     dsMOVING        BYTE    "dsMov",0
03960     64 73 48 6C 
03964     64 00       |     dsHOLDING       BYTE    "dsHld",0
03966     64 73 4F 66 
0396a     66 00       |     dsOFF           BYTE    "dsOff",0
0396c     3F 64 73 30 
03970     78          |     dsOther         BYTE    "?ds0x"
03971     30 30 2D 5B 
03975     43 4F 44 45 
03979     5D 3F 00    |     dsOtherVal      BYTE    "00-[CODE]?",0
0397c                 | 
0397c     64 63 73 55 
03980     6E 6B 00    |     dcsUnknown      BYTE    "dcsUnk",0
03983     64 63 73 53 
03987     54 4F 50 50 
0398b     45 44 00    |     dcsSTOPPED      BYTE    "dcsSTOPPED",0
0398e     64 63 73 53 
03992     50 49 4E 5F 
03996     55 50 00    |     dcsSPIN_UP      BYTE    "dcsSPIN_UP",0
03999     64 63 73 41 
0399d     54 5F 53 50 
039a1     45 45 44 00 |     dcsAT_SPEED     BYTE    "dcsAT_SPEED",0
039a5     64 63 73 53 
039a9     50 49 4E 5F 
039ad     44 4E 00    |     dcsSPIN_DN      BYTE    "dcsSPIN_DN",0
039b0     64 63 73 53 
039b4     4C 4F 57 5F 
039b8     54 4F 5F 43 
039bc     48 47 00    |     dcsSLOW_TO_CHG  BYTE    "dcsSLOW_TO_CHG",0
039bf     64 63 73 46 
039c3     41 55 4C 54 
039c7     45 44 00    |     dcsFAULTED      BYTE    "dcsFAULTED",0
039ca     64 63 73 45 
039ce     53 54 4F 50 
039d2     00          |     dcsESTOP        BYTE    "dcsESTOP",0
039d3     3F 64 63 73 
039d7     30 78       |     dcsOther        BYTE    "?dcs0x"
039d9     30 30 2D 5B 
039dd     43 4F 44 45 
039e1     5D 3F 00    |     dcsOtherVal     BYTE    "00-[CODE]?",0
039e4                 | 
039e4     00 00 00 00 |     pStatVal        LONG    0
039e8     FF FF FF FF |     priorLtStatus   LONG    -1
039ec     FF FF FF FF |     priorRtStatus   LONG    -1
039f0     FF FF FF FF |     priorLtState    LONG    -1
039f4     FF FF FF FF |     priorRtState    LONG    -1
039f8     FD FF FF FF |     priorLtFault   LONG    -3
039fc     FD FF FF FF |     priorRtFault   LONG    -3
03a00                 | 
03a00     00 00 00 00 | showHDMIDebug   LONG    FALSE
03a04                 | 
03a04                 | ' user stearing data
03a04                 | '---+-----------+---+---+---+-------------------+---+---+---+---+---+-----------+
03a04     53 74 65 65 
03a08     72 69 6E 67 
03a0c     00          | nameTitle1      BYTE    "Steering",0
03a0d     70 6F 77 65 
03a11     72 00       | name10          BYTE    "power",0
03a13     64 69 72 65 
03a17     63 2E 00    | name11          BYTE    "direc.",0
03a1a     6C 74 50 77 
03a1e     72 00       | name12          BYTE    "ltPwr",0
03a20     72 74 50 77 
03a24     72 00       | name13          BYTE    "rtPwr",0
03a26     73 74 70 54 
03a2a     63 6B 00    | name14          BYTE    "stpTck",0
03a2d     73 74 70 6D 
03a31     53 65 63 00 | name15          BYTE    "stpmSec",0
03a35     43 75 74 6F 
03a39     66 66 00    | name16          BYTE    "Cutoff",0
03a3c                 | nextAddr1
03a3c     38 00 00 00 | dataLen1        LONG    @nextAddr1 - @nameTitle1
03a40                 | 	alignl
03a40                 | _isp_bldc_motor_dat_
03a40                 | 
03a40                 |     ' time constants based on CPU freq
03a40     00 00 00 00 |     ticks1ms    LONG    0
03a44     00 00 00 00 |     ticks1us    LONG    0
03a48     00 00 00 00 |     ticks500us  long    0                       ' 2 kHz
03a4c     00 00 00 00 |     ticks125ms  long    0                       ' 8 Hz
03a50                 | 
03a50                 | ' motor drive data
03a50     4D 6F 74 6F 
03a54     72 20 44 72 
03a58     69 76 65 00 |     nameTitle1  BYTE    "Motor Drive",0
03a5c     68 61 6C 6C 
03a60     00          |     name10      BYTE    "hall",0
03a61     70 6F 73 00 |     name11      BYTE    "pos",0
03a65     64 75 74 79 
03a69     00          |     name12      BYTE    "duty",0
03a6a     65 72 72 00 |     name13      BYTE    "err",0
03a6e     6C 70 54 69 
03a72     63 6B 73 00 |     name14      BYTE    "lpTicks",0
03a76     73 74 61 74 
03a7a     65 00       |     name15      BYTE    "state",0
03a7c     46 41 55 4C 
03a80     54 00       |     name16      BYTE    "FAULT",0
03a82                 | nextAddr1
03a82     32 00 00 00 |     dataLen1     LONG    @nextAddr1 - @nameTitle1
03a86                 | 
03a86                 | ' motor sense data
03a86     4D 6F 74 6F 
03a8a     72 20 53 65 
03a8e     6E 73 65 00 |     nameTitle2  BYTE    "Motor Sense",0
03a92     52 50 4D 31 
03a96     30 74 68 00 |     name20      BYTE    "RPM10th",0
03a9a     52 50 4D 00 |     name21      BYTE    "RPM",0
03a9e     63 74 73 2F 
03aa2     73 65 63 00 |     name22      BYTE    "cts/sec",0
03aa6     64 65 6C 74 
03aaa     61 00       |     name23      BYTE    "delta",0
03aac     41 6D 70 00 |     name24      BYTE    "Amp",0
03ab0     6D 61 78 41 
03ab4     6D 70 00    |     name25      BYTE    "maxAmp",0
03ab7     52 50 4D 62 
03abb     31 30 00    |     name26      BYTE    "RPMb10",0
03abe                 | nextAddr2
03abe     38 00 00 00 |     dataLen2     LONG    @nextAddr2 - @nameTitle2
03ac2                 | 
03ac2                 | ' motor rate  data
03ac2     4D 6F 74 6F 
03ac6     72 20 52 61 
03aca     74 65 28 2E 
03ace     31 29 00    |     nameTitle3  BYTE    "Motor Rate(.1)",0
03ad1     52 50 4D 00 |     name30      BYTE    "RPM",0
03ad5     63 74 73 2F 
03ad9     73 65 63 00 |     name31      BYTE    "cts/sec",0
03add     6D 41 6D 70 
03ae1     00          |     name32      BYTE    "mAmp",0
03ae2     6D 57 61 74 
03ae6     74 00       |     name33      BYTE    "mWatt",0
03ae8     6B 4D 2F 48 
03aec     00          |     name34      BYTE    "kM/H",0
03aed     6D 6D 2F 73 
03af1     00          |     name35      BYTE    "mm/s",0
03af2     41 6E 67 2F 
03af6     31 30 6B 00 |     name36      BYTE    "Ang/10k",0
03afa                 | nextAddr3
03afa     38 00 00 00 |     dataLen3     LONG    @nextAddr3 - @nameTitle3
03afe                 | 
03afe                 | ' These table represent contants for use in BLDC pasm driver
03afe                 | '  tables specific to a given motor are copied into pasm driver image
03afe                 | '  before the driver is started
03afe                 | '
03afe                 | ' old bit shift up by 3 then new bits
03afe                 | '   old is outer index
03afe                 | '   new is inner index
03afe                 | 
03afe     00 00 00 00 
03b02     00 00 00 00 | deltas65    BYTE    0, 0, 0, 0, 0, 0, 0, 0  ' Hall-effect-sensor position deltas from (old<<3 | new)
03b06     00 00 00 FF 
03b0a     00 01 00 00 |             BYTE    0, 0, 0,-1, 0, 1, 0, 0
03b0e     00 00 00 01 
03b12     00 00 FF 00 |             BYTE    0, 0, 0, 1, 0, 0,-1, 0
03b16     00 01 FF 00 
03b1a     00 00 00 00 |             BYTE    0, 1,-1, 0, 0, 0, 0, 0
03b1e     00 00 00 00 
03b22     00 FF 01 00 |             BYTE    0, 0, 0, 0, 0,-1, 1, 0
03b26     00 FF 00 00 
03b2a     01 00 00 00 |             BYTE    0,-1, 0, 0, 1, 0, 0, 0
03b2e     00 00 01 00 
03b32     FF 00 00 00 |             BYTE    0, 0, 1, 0,-1, 0, 0, 0
03b36     00 00 00 00 
03b3a     00 00 00 00 |             BYTE    0, 0, 0, 0, 0, 0, 0, 0
03b3e                 | 
03b3e     00 00 00 00 
03b42     00 00 00 00 | deltas4k    BYTE    0, 0, 0, 0, 0, 0, 0, 0  ' old=0 - Hall-effect-sensor position deltas from (old<<3 | new)
03b46     00 00 00 FF 
03b4a     00 01 00 00 |             BYTE    0, 0, 0,-1, 0, 1, 0, 0  ' old=1
03b4e     00 00 00 01 
03b52     00 00 FF 00 |             BYTE    0, 0, 0, 1, 0, 0,-1, 0  ' old=2
03b56     00 01 FF 00 
03b5a     00 00 00 00 |             BYTE    0, 1,-1, 0, 0, 0, 0, 0  ' old=3
03b5e     00 00 00 00 
03b62     00 FF 01 00 |             BYTE    0, 0, 0, 0, 0,-1, 1, 0  ' old=4
03b66     00 FF 00 00 
03b6a     01 00 00 00 |             BYTE    0,-1, 0, 0, 1, 0, 0, 0  ' old=5
03b6e     00 00 01 00 
03b72     FF 00 00 00 |             BYTE    0, 0, 1, 0,-1, 0, 0, 0  ' old=6
03b76     00 00 00 00 
03b7a     00 00 00 00 |             BYTE    0, 0, 0, 0, 0, 0, 0, 0  ' old=7
03b7e                 | 
03b7e                 | '   amount of rotation within hall cycle - 6.5" wheel
03b7e     00 00 00 00 | hltbAngles  LONG    0           '-%000- can't happen forward-direction table
03b82     00 00 00 00 |             LONG    0 frac 6    '%001
03b86     AA AA AA AA |             LONG    4 frac 6    '%010
03b8a     55 55 55 D5 |             LONG    5 frac 6    '%011
03b8e     55 55 55 55 |             LONG    2 frac 6    '%100
03b92     AA AA AA 2A |             LONG    1 frac 6    '%101
03b96     00 00 00 80 |             LONG    3 frac 6    '%110
03b9a     00 00 00 00 |             LONG    0           '-%111- can't happen
03b9e                 | 
03b9e     00 00 00 00 | hltbAngle2  LONG    0           '-%000- can't happen - reverse-direction table
03ba2     55 55 55 D5 |             LONG    5 frac 6    '%001
03ba6     00 00 00 80 |             LONG    3 frac 6    '%010
03baa     AA AA AA AA |             LONG    4 frac 6    '%011
03bae     AA AA AA 2A |             LONG    1 frac 6    '%100
03bb2     00 00 00 00 |             LONG    0 frac 6    '%101
03bb6     55 55 55 55 |             LONG    2 frac 6    '%110
03bba     00 00 00 00 |             LONG    0           '-%111- can't happen
03bbe                 | 
03bbe                 | 
03bbe                 | '   amount of rotation within hall cycle - docoEng.com 4kRPM, 24V
03bbe     00 00 00 00 | hltbAngl4k  LONG    0           '-%000- can't happen - forward-direction table
03bc2     55 55 55 D5 |             LONG    5 frac 6    '%001
03bc6     00 00 00 80 |             LONG    3 frac 6    '%010
03bca     AA AA AA AA |             LONG    4 frac 6    '%011
03bce     AA AA AA 2A |             LONG    1 frac 6    '%100
03bd2     00 00 00 00 |             LONG    0 frac 6    '%101
03bd6     55 55 55 55 |             LONG    2 frac 6    '%110
03bda     00 00 00 00 |             LONG    0           '-%111- can't happen
03bde                 | 
03bde     00 00 00 00 | hltbAngl4k2 LONG    0           '-%000- can't happen - reverse-direction table
03be2     00 00 00 00 |             LONG    0 frac 6    '%001
03be6     AA AA AA AA |             LONG    4 frac 6    '%010
03bea     55 55 55 D5 |             LONG    5 frac 6    '%011
03bee     55 55 55 55 |             LONG    2 frac 6    '%100
03bf2     AA AA AA 2A |             LONG    1 frac 6    '%101
03bf6     00 00 00 80 |             LONG    3 frac 6    '%110
03bfa     00 00 00 00 |             LONG    0           '-%111- can't happen
03bfe                 | '
03bfe                 | ' PASM Driver Program
03bfe                 | '
03bfe     00 00       |                 org     0
03c00 000             | 
03c00 000 01 72 07 F6 | driver          mov     drv_state_, #DCS_STOPPED        ' motor is currently stopped
03c04 001             | {
03c04 001             | '}
03c04 001             | 
03c04 001 61 ED 06 FB |                 rdlong  tmpX, ptra++                    ' get base pin
03c08 002 76 8F 42 F5 |                 or      all_pins, tmpX                  '  finish the all-pins variable
03c0c 003 76 91 02 F1 |                 add     drive_pins, tmpX                '  finish the drive-pins variable
03c10 004 76 93 02 F1 |                 add     adc_pins, tmpX                  '  finish the adc-pins variable
03c14 005             | 
03c14 005 00 EE 06 F6 |                 mov     tmpY, #0                        ' make the single-pin variables
03c18 006 87 EF 8E F9 | .pin            altd    tmpY, #pin_adc_u_i              ' only 14, dont use last 2
03c1c 007 76 01 00 F6 |                 mov     0-0, tmpX
03c20 008 01 EC 06 F1 |                 add     tmpX, #1
03c24 009 0D EE 16 F7 |                 incmod  tmpY, #13                   wc
03c28 00a EC FF 9F 3D |     if_nc       jmp     #.pin
03c2c 00b             | 
03c2c 00b 61 3B 07 FB |                 rdlong  params_ptr_, ptra++             ' get parameters pointer
03c30 00c 08 F0 07 F1 |                 add     ptra, #2*4                      '  point to return data, targetIncre is at long index [-1]
03c34 00d             |                                                         '                        targetAngle is at long index [-2]
03c34 00d             | 
03c34 00d 40 8E 62 FD |                 dirl    all_pins                        ' disable PWM and ADC pins for configuration
03c38 00e             | 
03c38 00e 8F 97 02 FC |                 wrpin   pwmn, pin_pwm_u_l               ' set up PWM pins, low side is inverted
03c3c 00f 90 95 02 FC |                 wrpin   pwmt, pin_pwm_u_h               ' high side is not inverted
03c40 010 91 97 02 FC |                 wrpin   pwmn, pin_pwm_v_l
03c44 011 92 95 02 FC |                 wrpin   pwmt, pin_pwm_v_h
03c48 012 93 97 02 FC |                 wrpin   pwmn, pin_pwm_w_l
03c4c 013 94 95 02 FC |                 wrpin   pwmt, pin_pwm_w_h
03c50 014             | 
03c50 014 48 9B 12 FC |                 wxpin   fram, drive_pins                '  and set PWM frame width, too, matches adc period
03c54 015 48 01 28 FC |                 wypin   #0, drive_pins                  ' make sure pwm is off
03c58 016             | 
03c58 016             |                 ' ADC setup - GIO level
03c58 016 49 A7 02 FC |                 wrpin   adc_modes+0, adc_pins           ' switch ADC to GIO calibration
03c5c 017 49 99 12 FC |                 wxpin   adc_fram, adc_pins              ' set count period to match our PWM frame width
03c60 018 49 01 28 FC |                 wypin   #0, adc_pins
03c64 019             | 
03c64 019 41 92 62 FD |                 dirh    adc_pins                        ' enable ADC pins to use adc
03c68 01a             | 
03c68 01a 6C 04 B0 FD |                 call    #.wait4adc                      ' allow ADC rest period (wait for sample ready)
03c6c 01b             | 
03c6c 01b 87 2B 8B FA |                 rdpin   gio_levels+0, pin_adc_u_i       ' GIO samples done, read them
03c70 01c 88 2D 8B FA |                 rdpin   gio_levels+1, pin_adc_v_i
03c74 01d 89 2F 8B FA |                 rdpin   gio_levels+2, pin_adc_w_i
03c78 01e 8B 31 8B FA |                 rdpin   gio_levels+3, pin_adc_cur_i
03c7c 01f             | 
03c7c 01f             |                 ' ADC setup - VIO level
03c7c 01f 40 92 62 FD |                 dirl    adc_pins                        ' disable ADC pins for configuration
03c80 020 49 A9 02 FC |                 wrpin   adc_modes+1, adc_pins           ' switch ADC to VIO calibration
03c84 021 41 92 62 FD |                 dirh    adc_pins                        ' enable ADC to use adc
03c88 022             | 
03c88 022 4C 04 B0 FD |                 call    #.wait4adc                      ' allow ADC rest period (wait for sample ready)
03c8c 023             | 
03c8c 023 87 33 8B FA |                 rdpin   vio_levels+0, pin_adc_u_i       ' VIO samples done, read them
03c90 024 88 35 8B FA |                 rdpin   vio_levels+1, pin_adc_v_i
03c94 025 89 37 8B FA |                 rdpin   vio_levels+2, pin_adc_w_i
03c98 026 8B 39 8B FA |                 rdpin   vio_levels+3, pin_adc_cur_i
03c9c 027             | 
03c9c 027 95 33 83 F1 |                 sub     vio_levels+0, gio_levels+0      ' sub gio from vio to get range
03ca0 028 96 35 83 F1 |                 sub     vio_levels+1, gio_levels+1      ' sub gio from vio to get range
03ca4 029 97 37 83 F1 |                 sub     vio_levels+2, gio_levels+2      ' sub gio from vio to get range
03ca8 02a 98 39 83 F1 |                 sub     vio_levels+3, gio_levels+3      ' sub gio from vio to get range
03cac 02b             | 
03cac 02b 99 A1 12 FD |                 qdiv    numerator, vio_levels+0         ' calculate our values from readings
03cb0 02c 9A A1 12 FD |                 qdiv    numerator, vio_levels+1
03cb4 02d 9B A1 12 FD |                 qdiv    numerator, vio_levels+2
03cb8 02e 9C A1 12 FD |                 qdiv    numerator, vio_levels+3
03cbc 02f             | 
03cbc 02f 18 32 63 FD |                 getqx   scl_levels+0                    ' getqx waits for the results, but need to get result before next is written
03cc0 030 18 34 63 FD |                 getqx   scl_levels+1
03cc4 031 18 36 63 FD |                 getqx   scl_levels+2
03cc8 032 18 38 63 FD |                 getqx   scl_levels+3
03ccc 033             | 
03ccc 033             | 
03ccc 033             |                 ' finally, configure the current sense pins for main loop
03ccc 033 40 92 62 FD |                 dirl    adc_pins                        ' disable ADC pins for configuration
03cd0 034             | 
03cd0 034             |                  ' ADC setup for actual values
03cd0 034 49 AB 02 FC |                wrpin   adc_modes+2, adc_pins            ' switch ADC to pin sampling
03cd4 035             | 
03cd4 035 00 A4 16 F4 |                 testb   sync_required, #0           wc  ' do we need to wait for attention?
03cd8 036 24 3C 60 CD |     if_c        waitatn                                 ' Y: wait to be atn by caller
03cdc 037             | 
03cdc 037 BC 03 B0 FD |                 call    #.driveinit                     ' enable ADC and PWM pins simultaneously for phase-locked operation
03ce0 038             |                                                         ' from now on, the adc and pwm run continously
03ce0 038             | 
03ce0 038 00 68 07 F6 |                 mov     pos_, #0                        ' reset pos
03ce4 039 00 6E 07 F6 |                 mov     loop_dtcks_, #0                 ' just in case
03ce8 03a 00 70 07 F6 |                 mov     loop_ctcks_, #0                 ' just in case
03cec 03b 00 FC 06 F6 |                 mov     drv_incr, #0                    ' reset incr to stopped
03cf0 03c 00 F8 06 F6 |                 mov     prior_incr, #0                  ' just in case
03cf4 03d 00 F6 06 F6 |                 mov     tgt_incr, #0                    ' just in case
03cf8 03e 00 FA 06 F6 |                 mov     sv_tgt_incr, #0                 ' just in case
03cfc 03f 00 08 07 F6 |                 mov     fwdrev, #0                      ' just in case
03d00 040 00 04 07 F6 |                 mov     angle_, #0                      ' just in case
03d04 041             | 
03d04 041             |                 ' do initial read of parms so control loop can use them
03d04 041 28 1A 64 FD |                 setq    #DRVR_PARAMS_LONGS_COUNT-1      ' load fresh parameter table (13 DRVR_PARAMS_LONGS_COUNT longs)
03d08 042 9D 3D 03 FB |                 rdlong  params_ptr_+1, params_ptr_
03d0c 043             | 
03d0c 043 AA 03 03 F6 |                 mov     ramp_curr, ramp_min_            ' set initial inc ramp
03d10 044 A0 6B 03 F6 |                 mov     duty_, duty_min_                ' reset duty
03d14 045 A7 0D 03 F6 |                 mov     curr_stop, stop_mode_           ' save current stop mode
03d18 046 A0 03 B0 FD |                 call    #.checkstop                     ' set drive on or off according to stop mode
03d1c 047             | 
03d1c 047             |     ' =========================================================================
03d1c 047             |     '  MOTOR DRIVE LOOP - runs at 2.0 kHz (500.0 uSec period)
03d1c 047             |     '       time to adjust angle...
03d1c 047             |     ' -------------------------------------------------------------------------
03d1c 047             | .drvMotor
03d1c 047 1A F2 62 FD |                 getct   ctrlSrtTix                      ' remember when we started this loop
03d20 048             | {
03d20 048             | '}
03d20 048             | '
03d20 048             | ' with emergency stop we quickly stop and then ignore everything else until eStop request is removed!
03d20 048             | '
03d20 048 A8 51 4B F5 |                 or      e_stop_, e_stop_            wz  ' Q: Emergency Stop Requested? (T/F - where T means stop!)
03d24 049 14 00 90 AD |     if_z        jmp     #.noEStop                       ' No: continue on..
03d28 04a             | .eStop
03d28 04a 07 72 0F F2 |                 cmp     drv_state_, #DCS_ESTOP      wz  ' Q: Are we already Emergency Stopped?
03d2c 04b AC 01 90 AD |     if_z        jmp     #.endRqst                       ' YES, motor is at ESTOP, just exit (w/o increment)
03d30 04c 7C 03 B0 FD |                 call    #.driveoff                      ' set drive pwm off, regardless of stop mode
03d34 04d 07 72 07 F6 |                 mov     drv_state_, #DCS_ESTOP          ' mark that we are stopped
03d38 04e A0 01 90 FD |                 jmp     #.endRqst                       ' motor now at ESTOP, just exit (w/o increment)
03d3c 04f             | .noEStop
03d3c 04f 07 72 0F F2 |                 cmp     drv_state_, #DCS_ESTOP      wz  ' Q: were we emergency stopped?
03d40 050 01 72 07 A6 |     if_z        mov     drv_state_, #DCS_STOPPED        ' YES, reset to simply stopped so we start out pins correctly
03d44 051 7B FB 02 F6 |                 mov     sv_tgt_incr, tgt_incr
03d48 052             | 
03d48 052 34 03 B0 FD |                 call    #.gettgtincr                    ' get rate of increment ( +/- drive power, or 0 stop)
03d4c 053 7B F7 4A F5 |                 or      tgt_incr, tgt_incr          wz  ' Q: being asked to stop?
03d50 054 18 00 90 5D |     if_nz       jmp     #.notRqStop                     ' NO, not exception, check next
03d54 055             |                 ' this is a stop request
03d54 055 01 72 0F F2 |                 cmp     drv_state_, #DCS_STOPPED    wz  ' Q: are we already stopped?
03d58 056 2C 00 90 5D |     if_nz       jmp     #.newRqst                       ' NO, not stopped, go do stop!
03d5c 057 A7 0D 0B F2 |                 cmp     curr_stop, stop_mode_       wz  ' stopped, see if stop mode has changed and update drive_pin state
03d60 058 A7 0D 03 56 |     if_nz       mov     curr_stop, stop_mode_           ' update curr stop mode
03d64 059 54 03 B0 5D |     if_nz       call    #.checkstop                     ' set drive on or off according to stop mode
03d68 05a 70 01 90 FD |                 jmp     #.endRqst                       ' YES, motor at STOP, just exit (w/o increment)
03d6c 05b             | .notRqStop
03d6c 05b 7B FB 0A F2 |                 cmp     sv_tgt_incr, tgt_incr       wz  ' Q: do we have a new request?
03d70 05c 98 00 90 AD |     if_z        jmp     #.currRqst                      ' NO, same as last, just continue what we are doing
03d74 05d             |                 ' Accept a new drive command only when NOT in middle of change
03d74 05d 01 72 0F F2 |                 cmp     drv_state_, #DCS_STOPPED    wz  ' Q: STOPPED not doing anything?
03d78 05e 03 72 0F 52 |     if_nz       cmp     drv_state_, #DCS_AT_SPEED   wz  ' Q: AT_SPEED not doing anything?
03d7c 05f 06 72 0F 52 |     if_nz       cmp     drv_state_, #DCS_FAULTED    wz  ' Q: FAULTED not doing anything?
03d80 060 7D F7 02 56 |     if_nz       mov     tgt_incr, sv_tgt_incr           ' BUSY, throw away this request this request
03d84 061 84 00 90 5D |     if_nz       jmp     #.currRqst                      ' BUSY, ignore command, continue same command
03d88 062             |                 ' NOT BUSY, fall through to process new request...
03d88 062             | .newCmd
03d88 062             | {
03d88 062             | '}
03d88 062             | ' =========================================================================
03d88 062             | .newRqst    ' have new request
03d88 062             |             ' determine what we need to do
03d88 062             |             ' let's see if user wants to change speed
03d88 062             |     ' -------------------------------------------------------------------------
03d88 062 7D F9 02 F6 |                 mov     prior_incr, sv_tgt_incr         ' have new request - save the prior!
03d8c 063             |                 ' first, if faulted, clear fault
03d8c 063 06 72 0F F2 |                 cmp     drv_state_, #DCS_FAULTED    wz  ' Q: is MOTOR faulted?
03d90 064 20 00 90 5D |     if_nz       jmp     #.chkStopCmd                    ' NO, go to next check
03d94 065             |             ' MOTOR faulted, clear fault so we can run again
03d94 065             | .resetFault
03d94 065 00 FC 06 F6 |                 mov     drv_incr, #0                    ' reset incr to stopped
03d98 066 00 F8 06 F6 |                 mov     prior_incr, #0                  ' reset prior
03d9c 067 00 08 07 F6 |                 mov     fwdrev, #0                      ' just in case
03da0 068 00 04 07 F6 |                 mov     angle_, #0                      ' just in case
03da4 069 01 72 07 F6 |                 mov     drv_state_, #DCS_STOPPED        ' reset fault -> to stopped
03da8 06a             |                                                         ' drive_pins were floated when detect fault
03da8 06a 10 03 B0 FD |                 call    #.checkstop                     ' set drive pwm according to stop mode
03dac 06b             |                 ' if we were faulted, we are already stopped so just do nothing if new stop request
03dac 06b 7B F7 4A F5 |                 or      tgt_incr, tgt_incr          wz  ' Q: is stop request?
03db0 06c 28 01 90 AD |     if_z        jmp     #.endRqst                       ' YES, is stop and motor STOPPED, just exit (w/o increment)
03db4 06d             | .chkStopCmd
03db4 06d             |                 ' if NEW request is stop
03db4 06d             |                 ' NOTE: (earlier code ensures we are NOT stopped or FAULTed when we get here)
03db4 06d 7B F7 4A F5 |                 or      tgt_incr, tgt_incr          wz  ' Q: is stop request?
03db8 06e 04 72 07 A6 |     if_z        mov     drv_state_, #DCS_SPIN_DN        ' YES, mark spin-down
03dbc 06f BC 00 90 AD |     if_z        jmp     #.rampDn                        ' YES, go do it!
03dc0 070             | .chkStopped
03dc0 070             |                 ' not stop, have start or speed adjustment?
03dc0 070 01 72 0F F2 |                 cmp     drv_state_, #DCS_STOPPED    wz  ' Q: are we stopped?
03dc4 071 08 00 90 5D |     if_nz       jmp     #.doSpdChange                   ' NO, so not start, go do speed adjustment
03dc8 072             |                                                         ' have start
03dc8 072             | .dospinup
03dc8 072 02 72 07 F6 |                 mov     drv_state_, #DCS_SPIN_UP        ' We are going to ramp up
03dcc 073 4C 00 90 FD |                 jmp     #.rampUp                        ' now go ramp up!
03dd0 074             | 
03dd0 074             | .doSpdChange
03dd0 074             |     ' ------------------------------------
03dd0 074             |                ' NO, We have a speed adjustment (determine how to do...)
03dd0 074             |                 '  NOTEs: [ + >> +, + >> -, - >> -, - >> +]
03dd0 074             |                 '    + to - -> make direction change (slow down, ramp up in other direction)
03dd0 074             |                 '    - to + -> make direction change (slow down, ramp up  in other direction)
03dd0 074             |                 '    + to larger + -> ramp up to new
03dd0 074             |                 '    + to smaller + -> ramp down to new
03dd0 074             |                 '    - to larger - -> ramp up to new
03dd0 074             |                 '    - to smaller - -> ramp down to new
03dd0 074             | 
03dd0 074             |                 ' yes we were stopping and haven't yet stopped, so just do speed change
03dd0 074             |                 ' (we are currently at drv_incr but need to head for tgt_incr instead)
03dd0 074             | .notInStop
03dd0 074             |                 ' first do we have same sign?
03dd0 074 1F FC 16 F4 |                 testb   drv_incr, #31               wc   ' find dual '-' signs (CY=both nega)
03dd4 075 1F F6 56 F4 |                 testb   tgt_incr, #31               andc ' (bCY=REV)
03dd8 076 0C 00 90 CD |     if_c        jmp     #.haveSame
03ddc 077 1F FC 36 F4 |                 testbn  drv_incr, #31               wc   ' find dual '+' signs (CY=both posi)
03de0 078 1F F6 76 F4 |                 testbn  tgt_incr, #31               andc ' (bnCY=FWD)
03de4 079 1C 00 90 3D |     if_nc       jmp     #.notSame
03de8 07a             | .haveSame       ' we have prior and new with same sign, so should we slow down or speed up?
03de8 07a 1F F6 0E F4 |                 testb   tgt_incr, #31               wz  ' (bZ=REV)
03dec 07b 7B FD 52 F2 |                 cmps    drv_incr, tgt_incr          wc  ' Q: Should we slow dn or speed up? (CY=speed up)
03df0 07c 6F 60 74 5D |     if_nz       modc    _nc                         wc  ' invert C (nCY=slow down), if tgt_incr=FWD
03df4 07d 02 72 07 36 |     if_nc       mov     drv_state_, #DCS_SPIN_UP        ' CY=0: speed up
03df8 07e 20 00 90 3D |     if_nc       jmp     #.rampUp
03dfc 07f 04 72 07 C6 |     if_c        mov     drv_state_, #DCS_SPIN_DN        ' CY=1: slow down
03e00 080 78 00 90 CD |     if_c        jmp     #.rampDn
03e04 081             |     ' ------------------------------------
03e04 081             | .notSame    ' we have prior and new but NOT the same sign, let's slowdown then change direction
03e04 081             |                 ' let's change direction
03e04 081 05 72 07 F6 |                 mov     drv_state_, #DCS_SLOW_TO_CHG
03e08 082 B8 00 90 FD |                 jmp     #.slow2Chg
03e0c 083             | 
03e0c 083             |     ' ====================================
03e0c 083             | .currRqst   ' No new request, continue with
03e0c 083             |             '  current request
03e0c 083             |     ' -------------------------------------------------------------------------
03e0c 083 01 72 0F F2 | .chkStop        cmp     drv_state_, #DCS_STOPPED    wz  ' Q: Stopped?
03e10 084 C8 00 90 AD |     if_z        jmp     #.endRqst                       ' YES, motor STOPPED, just exit (w/o increment)
03e14 085             |                 ' motor is running, if ramp do ramp, else increment
03e14 085             |     ' -------------------------------------------------------------------------
03e14 085 02 72 0F F2 | .chkUp          cmp     drv_state_, #DCS_SPIN_UP    wz  ' Q: Spinning Up?
03e18 086 58 00 90 5D |     if_nz       jmp     #.chkDn                         ' NO, check next
03e1c 087             |     ' ------------------------------------
03e1c 087             | .rampUp
03e1c 087             |                 ' if we don't have it, preset our starting angle (assume motor moved during float!)
03e1c 087             | 
03e1c 087 7E FD 4A F5 |                 or      drv_incr, drv_incr          wz  ' -and- are we stopped, just about to spin up?
03e20 088 AA 03 03 A6 |     if_z        mov     ramp_curr, ramp_min_            ' set initial ramp if starting from 0
03e24 089 8C 02 B0 AD |     if_z        call    #.checkstopfloaton              ' make sure drive is on according to stop mode
03e28 08a             |                 ' if we are at target, stop the ramp effort
03e28 08a 7B FD 4A F2 |                 cmps    drv_incr, tgt_incr          wz  ' Q: Did we match target?
03e2c 08b 3C 00 90 AD |     if_z        jmp     #.endRUpAtSpeed                 ' YES, (Matched) go mark done
03e30 08c             |                 ' do next UP adjustment or set at-speed
03e30 08c 81 FF 02 F6 |                 mov     curr_ramp, ramp_curr            ' current ramp
03e34 08d AB 03 03 F1 |                 add     ramp_curr, ramp_inc_            ' increase ramp for next time
03e38 08e A9 03 53 F2 |                 cmps    ramp_curr, ramp_max_        wc  ' too high?
03e3c 08f A9 03 03 36 |     if_nc       mov     ramp_curr, ramp_max_            ' Y set to ramp_max
03e40 090             |                 ' calculate how far we are from desired
03e40 090 7B 01 03 F6 |                 mov     final_ramp, tgt_incr            ' compute our delta from curr to target
03e44 091 7E 01 C3 F1 |                 subs    final_ramp, drv_incr
03e48 092             |                 ' now are we moving FWD or REV?
03e48 092 1F F6 16 F4 |                 testb   tgt_incr, #31               wc  ' Q: moving FWD or REV? (bCY=REV)
03e4c 093             | .havefast1
03e4c 093 6F 18 6C FD |                 modz    _c                          wz  ' move C to Z
03e50 094 80 01 43 F6 |                 abs     final_ramp                      ' make sure final is +ve
03e54 095 7F 01 53 F2 |                 cmps    final_ramp, curr_ramp       wc  ' Q: is delta larger than ramp
03e58 096 7F FD 42 11 |     if_nc_and_nz adds   drv_incr, curr_ramp             ' YES, just add ramp value
03e5c 097 80 FD 42 41 |     if_c_and_nz adds    drv_incr, final_ramp            ' NO, add remaining final delta
03e60 098 7F FD C2 21 |     if_nc_and_z subs    drv_incr, curr_ramp             ' YES, just add ramp value
03e64 099 80 FD C2 81 |     if_c_and_z  subs    drv_incr, final_ramp            ' NO, add remaining final delta
03e68 09a 6C 00 90 FD |                 jmp     #.justIncr                      ' increment motor angle, then exit
03e6c 09b             | .endRUpAtSpeed
03e6c 09b 03 72 07 F6 |                 mov     drv_state_, #DCS_AT_SPEED       ' YES, show we got to desired speed!
03e70 09c 68 00 90 FD |                 jmp     #.endRqst                       ' motor AT_SPEED, just exit (w/o increment)
03e74 09d             | 
03e74 09d             |     ' -------------------------------------------------------------------------
03e74 09d 04 72 0F F2 | .chkDn          cmp     drv_state_, #DCS_SPIN_DN    wz  ' Q: Spinning Down?
03e78 09e 40 00 90 5D |     if_nz       jmp     #.chkSlow2Chg                   ' NO, check next
03e7c 09f             |     ' ------------------------------------
03e7c 09f             | .rampDn
03e7c 09f             |                 ' do next DOWN adjustment ends with AT_SPEED or STOPPED
03e7c 09f             |                 ' NOTE!!! if tgt_incr is ZERO then we don't test its sign bit here
03e7c 09f             |                 '  instead we test the sign bit of the current driver target as we are spinning down
03e7c 09f             |                 '  from the current driver target to ZERO!
03e7c 09f 7B FD 4A F2 |                 cmps    drv_incr, tgt_incr          wz  ' Q: Did we match target?
03e80 0a0 1C 00 90 AD |     if_z        jmp     #.endRDnAtTgt                   ' YES, (Matched) go mark done
03e84 0a1             |                 ' calculate how far we are from desired
03e84 0a1 7B 01 03 F6 |                 mov     final_ramp, tgt_incr            ' compute our delta from curr to target
03e88 0a2 7E 01 C3 F1 |                 subs    final_ramp, drv_incr
03e8c 0a3             |                 ' now are we moving FWD or REV?
03e8c 0a3 7B F7 4A F5 |                 or      tgt_incr, tgt_incr          wz  ' Q: are we stopping? (if stopping don't use sign of tgt_incr)
03e90 0a4 1F FC 36 A4 |     if_z        testbn  drv_incr, #31               wc  ' YES, moving FWD or REV? (bCY=FWD)
03e94 0a5 1F F6 36 54 |     if_nz       testbn  tgt_incr, #31               wc  ' NO, moving FWD or REV? (bCY=FWD)
03e98 0a6             | .havefast
03e98 0a6             | 
03e98 0a6 A5 FF 02 F6 |                 mov     curr_ramp, ramp_down_           ' we want to ramp down
03e9c 0a7 AC FF 9F FD |                 jmp     #.havefast1                     ' jmp to previous ramping code
03ea0 0a8             | .endRDnAtTgt
03ea0 0a8             |                 ' AT TARGET now adjust state
03ea0 0a8 7B F7 4A F5 |                 or      tgt_incr, tgt_incr          wz  ' Q: was our target ZERO? (are we stopping?)
03ea4 0a9             |                 ' at target but it's not zero so we are AT_SPEED!
03ea4 0a9 03 72 07 56 |     if_nz       mov     drv_state_, #DCS_AT_SPEED       ' YES, show we got here!
03ea8 0aa 30 00 90 5D |     if_nz       jmp     #.endRqst                       ' motor AT_SPEED, just exit (w/o increment)
03eac 0ab             | .endAtZero
03eac 0ab             |                 ' at target but it is zero so we are STOPPED!
03eac 0ab 01 72 07 F6 |                 mov     drv_state_, #DCS_STOPPED        ' report that we are stopped
03eb0 0ac A0 6B 03 F6 |                 mov     duty_, duty_min_                ' reset duty
03eb4 0ad             |                 ' if we are to freewheel the motor let's float all drive pins
03eb4 0ad             | 
03eb4 0ad 00 02 B0 FD |                 call    #.checkstopfloatoff             ' set drive off according to stop mode
03eb8 0ae 20 00 90 FD |                 jmp     #.endRqst                       ' motor STOPPED, just exit (w/o increment)
03ebc 0af             | 
03ebc 0af             |     ' -------------------------------------------------------------------------
03ebc 0af 05 72 0F F2 | .chkSlow2Chg    cmp     drv_state_, #DCS_SLOW_TO_CHG wz ' Q: Are we slowing down to change direction?
03ec0 0b0 14 00 90 5D |     if_nz       jmp     #.justIncr                      ' NO, check next
03ec4 0b1             |      ' ------------------------------------
03ec4 0b1             | .slow2Chg
03ec4 0b1             |                 ' do next DOWN adjustment, if stopped do spinup
03ec4 0b1             |                 '  (increment > 0, we are not stopped)
03ec4 0b1             |                 ' NOTE!!! tgt_incr is where we are going after we spin down so we don't test its sign bit here
03ec4 0b1             |                 '  instead we test the sign bit of the current driver target as we are spinning down
03ec4 0b1             |                 '  from the current driver target to ZERO!
03ec4 0b1             | .moreSlow
03ec4 0b1 7E FD 4A F5 |                 or      drv_incr, drv_incr          wz  ' Q: stopped?
03ec8 0b2 FC FE 9F AD |     if_z        jmp     #.dospinup                      ' yes, go start rampUp
03ecc 0b3             |                                                         ' calculate how far we are from desired
03ecc 0b3 7E 01 03 F6 |                 mov     final_ramp, drv_incr            ' compute our delta from curr to 0
03ed0 0b4             |                                                         ' now are we moving FWD or REV?
03ed0 0b4 1F FC 36 F4 |                 testbn  drv_incr, #31               wc  ' YES, moving FWD or REV? (bCY=FWD)
03ed4 0b5 C0 FF 9F FD |                 jmp     #.havefast                      ' jmp to previous ramp code
03ed8 0b6             | 
03ed8 0b6             |     ' -------------------------------------------------------------------------
03ed8 0b6             | .justIncr   ' just do our increment of angle and we're done!
03ed8 0b6 7E 05 03 F1 |                 add     angle_, drv_incr
03edc 0b7             | '                debug("DRV: ", uhex_(drive_pins), " A:(", sdec_(angle_), ") += DI:(", sdec_(drv_incr), ")")
03edc 0b7             | 
03edc 0b7             | .endRqst
03edc 0b7 1A 70 63 FD |                 getct   loop_ctcks_                     ' how long was this pass? send to host
03ee0 0b8 79 71 83 F1 |                 sub     loop_ctcks_, ctrlSrtTix
03ee4 0b9             |                 ' reset timer (schedule next control loop run)
03ee4 0b9 79 F5 02 F6 |                 mov     ctrlEndTix, ctrlSrtTix
03ee8 0ba A6 F5 62 FA |                 addct1  ctrlEndTix, cfg_ctcks_
03eec 0bb             | {
03eec 0bb             | '}
03eec 0bb             | 
03eec 0bb             |     ' =========================================================================
03eec 0bb             |     ' this or
03eec 0bb             |     ' =========================================================================
03eec 0bb             | {
03eec 0bb             | '}
03eec 0bb             | .ctlMotor
03eec 0bb             | 
03eec 0bb             |     ' =========================================================================
03eec 0bb             |     '  MOTOR Speed Maintenance Loop - runs at 43.9 kHz (22.8 uSec period)
03eec 0bb             |     '       keep our error rate low...
03eec 0bb             |     ' -------------------------------------------------------------------------
03eec 0bb 1A F0 62 FD |                 getct   drvrSrtTix                      ' remember when we started this loop
03ef0 0bc             | 
03ef0 0bc E4 01 B0 FD |                 call    #.wait4adc                      ' allow ADC rest period (wait for sample ready), also wait for start of ctl loop
03ef4 0bd 87 5F 8B FA |                 rdpin   sense_u_, pin_adc_u_i           ' pin samples done, read them
03ef8 0be 88 61 8B FA |                 rdpin   sense_v_, pin_adc_v_i
03efc 0bf 89 63 8B FA |                 rdpin   sense_w_, pin_adc_w_i
03f00 0c0 8B 65 8B FA |                 rdpin   sense_i_, pin_adc_cur_i
03f04 0c1             | 
03f04 0c1 95 5F 83 F1 |                 sub     sense_u_, gio_levels+0          ' compute (numerator * (pin_level - gio_level))
03f08 0c2 99 5F 13 FA |                 muls    sense_u_, scl_levels+0
03f0c 0c3             | 
03f0c 0c3 96 61 83 F1 |                 sub     sense_v_, gio_levels+1
03f10 0c4 9A 61 13 FA |                 muls    sense_v_, scl_levels+1
03f14 0c5             | 
03f14 0c5 97 63 83 F1 |                 sub     sense_w_, gio_levels+2
03f18 0c6 9B 63 13 FA |                 muls    sense_w_, scl_levels+2
03f1c 0c7             | 
03f1c 0c7 98 65 83 F1 |                 sub     sense_i_, gio_levels+3
03f20 0c8 9C 65 13 FA |                 muls    sense_i_, scl_levels+3
03f24 0c9             | 
03f24 0c9 B5 EF 02 F6 |                 mov     tmpY, duty_                     ' feed three CORDIC operations to get phase drive levels
03f28 0ca 04 EE 46 F0 |                 shr     tmpY, #4
03f2c 0cb 82 ED 02 F6 |                 mov     tmpX, angle_                    ' requested angle
03f30 0cc 76 EF 42 FD |                 qrotate tmpY, tmpX
03f34 0cd 4F ED 02 F1 |                 add     tmpX, third                     ' 120 degrees further
03f38 0ce 76 EF 42 FD |                 qrotate tmpY, tmpX
03f3c 0cf 4F ED 02 F1 |                 add     tmpX, third                     ' 240 degress further
03f40 0d0 76 EF 42 FD |                 qrotate tmpY, tmpX
03f44 0d1             | 
03f44 0d1 19 58 63 FD |                 getqy   drive_u_                        ' get three CORDIC results, duty/16*cos(angle_+N*120degree) (N->0,1,2)
03f48 0d2 19 5A 63 FD |                 getqy   drive_v_
03f4c 0d3 19 5C 63 FD |                 getqy   drive_w_
03f50 0d4             | ' used when tracking down PWM drive problem...
03f50 0d4             | '                mov     driveUsav_, drive_u_           ' copy for later display
03f50 0d4             | 
03f50 0d4 AC ED 02 F6 |                 mov     tmpX, drive_u_                  ' get smallest drive level into tmpX
03f54 0d5 AD ED 52 F2 |                 cmps    tmpX, drive_v_              wc
03f58 0d6 AD ED 02 36 |     if_nc       mov     tmpX, drive_v_
03f5c 0d7 AE ED 52 F2 |                 cmps    tmpX, drive_w_              wc
03f60 0d8 AE ED 02 36 |     if_nc       mov     tmpX, drive_w_
03f64 0d9             | 
03f64 0d9 AC EF 02 F6 |                 mov     tmpY, drive_u_                  ' get largest drive level into tmpY
03f68 0da AD EF 52 F2 |                 cmps    tmpY, drive_v_              wc
03f6c 0db AD EF 02 C6 |     if_c        mov     tmpY, drive_v_
03f70 0dc AE EF 52 F2 |                 cmps    tmpY, drive_w_              wc
03f74 0dd AE EF 02 C6 |     if_c        mov     tmpY, drive_w_
03f78 0de             | 
03f78 0de 77 ED 02 F1 |                 add     tmpX, tmpY                      ' sum smallest and largest, then divide by 2
03f7c 0df 01 EC C6 F0 |                 sar     tmpX, #1
03f80 0e0             | 
03f80 0e0 76 59 83 F1 |                 sub     drive_u_, tmpX                  ' subtract difference from drive levels
03f84 0e1 76 5B 83 F1 |                 sub     drive_v_, tmpX                  ' offset round the average drive pwm
03f88 0e2 76 5D 83 F1 |                 sub     drive_w_, tmpX
03f8c 0e3             | 
03f8c 0e3 4E 59 03 F1 |                 add     drive_u_, bias                  ' add center-bias and dead-time offsets to update PWMs
03f90 0e4 4E 5B 03 F1 |                 add     drive_v_, bias                  ' center around the triangle counter
03f94 0e5 4E 5D 03 F1 |                 add     drive_w_, bias                  ' counter counts down to 0 and then up during fram period
03f98 0e6             |                                                         ' when counting down and counter == y value, out turns on and off when counting up and counter == value
03f98 0e6             |                                                         ' pwm config of output inverted or not-inverted. low side is inverted, high side is not
03f98 0e6             |                                                         ' if drive_pins are floating then pwm isn't output
03f98 0e6             | 
03f98 0e6 00 0A 17 F4 |                 testb   driveoff, #0                wc  ' if driveoff is 0 then drive is enabled, else drive should be disabled
03f9c 0e7 48 01 28 CC |     if_c        wypin   #0, drive_pins                  ' make sure pwm is off and all drive pins low
03fa0 0e8 A4 59 03 F1 |                 add     drive_u_, dead_gap_             ' make sure low side turns off (inverted) earlier than high side turns on (non-inverted)
03fa4 0e9 8F 59 23 3C |     if_nc       wypin   drive_u_, pin_pwm_u_l           ' safety on driver board make sure high side off if both low and high side are high, in case of an error
03fa8 0ea A4 59 83 F1 |                 sub     drive_u_, dead_gap_             ' shouldn't happen with dead-gap
03fac 0eb 90 59 23 3C |     if_nc       wypin   drive_u_, pin_pwm_u_h
03fb0 0ec             | 
03fb0 0ec A4 5B 03 F1 |                 add     drive_v_, dead_gap_             ' dead-gap was OFFSET
03fb4 0ed 91 5B 23 3C |     if_nc       wypin   drive_v_, pin_pwm_v_l
03fb8 0ee A4 5B 83 F1 |                 sub     drive_v_, dead_gap_             ' dead-gap was OFFSET
03fbc 0ef 92 5B 23 3C |     if_nc       wypin   drive_v_, pin_pwm_v_h
03fc0 0f0             | 
03fc0 0f0 A4 5D 03 F1 |                 add     drive_w_, dead_gap_             ' dead-gap was OFFSET
03fc4 0f1 93 5D 23 3C |     if_nc       wypin   drive_w_, pin_pwm_w_l
03fc8 0f2 A4 5D 83 F1 |                 sub     drive_w_, dead_gap_             ' dead-gap was OFFSET
03fcc 0f3 94 5D 23 3C |     if_nc       wypin   drive_w_, pin_pwm_w_h
03fd0 0f4             | 
03fd0 0f4 40 1C 73 FD |                 testp   pin_hall_w                  wc  ' read hall effect sensor
03fd4 0f5 01 66 A7 F0 |                 rcl     hall_, #1
03fd8 0f6 40 1A 73 FD |                 testp   pin_hall_v                  wc
03fdc 0f7 01 66 A7 F0 |                 rcl     hall_, #1
03fe0 0f8 40 18 73 FD |                 testp   pin_hall_u                  wc
03fe4 0f9 01 66 A7 F0 |                 rcl     hall_, #1
03fe8 0fa 3F 66 07 F5 |                 and     hall_, #%111_111                ' (old << 3 | new) [_x_:ooo:nnn]
03fec 0fb 56 67 6F F9 |                 altgb   hall_, #deltas                  ' load byte deltas[hall_] -> [-1, 0, 1]
03ff0 0fc 00 EE E2 F8 |                 getbyte tmpY
03ff4 0fd 07 EE 66 F7 |                 signx   tmpY, #7                        ' sign-extend bit7
03ff8 0fe 77 69 03 F1 |                 add     pos_, tmpY                      ' add to current pos_
03ffc 0ff             | 
03ffc 0ff 28 1A 64 FD |                 setq    #DRVR_PARAMS_LONGS_COUNT-1      ' load fresh parameter table (13 DRVR_PARAMS_LONGS_COUNT longs)
04000 100 9D 3D 03 FB |                 rdlong  params_ptr_+1, params_ptr_
04004 101             | 
04004 101 83 05 BB F2 |                 cmpm    angle_, prior_angle         wcz ' if angle has changed, forward or reverse?
04008 102 6C 08 63 5D |     if_nz       wrc     fwdrev                          ' if angle hasn't changed then use last forward/reverse
0400c 103 82 07 03 F6 |                 mov     prior_angle, angle_
04010 104             | 
04010 104 00 08 17 F4 |                 testb   fwdrev, #0                  wc  ' determine error
04014 105 03 66 47 F4 |                 bitc    hall_, #3                       ' forward or reverse half of the hall_angles table
04018 106 0F 66 07 F5 |                 and     hall_, #%1111                   ' remove hall input from last time to stay in bounds
0401c 107 66 67 97 F9 |                 alts    hall_, #hall_angles
04020 108 00 6C 03 F6 |                 mov     err_, 0-0
04024 109 9E 6D 03 C1 |     if_c        add     err_, offset_fwd_               ' hall sensor offsets
04028 10a 9F 6D 03 31 |     if_nc       add     err_, offset_rev_
0402c 10b 82 6D C3 F2 |                 subr    err_, angle_                    ' difference from requested angle
04030 10c 18 6C C7 F0 |                 sar     err_, #24
04034 10d             | 
04034 10d B6 EF 42 F6 |                 abs     tmpY, err_                      ' fault? tmpY is absolute difference from hall angle to requested angle
04038 10e 7D EE 16 F2 |                 cmp     tmpY, #125                  wc  ' less than ~176deg differ from requested? is ok
0403c 10f 00 0A 97 F4 |                 testb   driveoff, #0                orc ' if driveoff is 1 then ignore fault, i.e., manually moving wheel
04040 110 6C 00 B0 3D |     if_nc       call    #.driveoff                      ' at FAULT: disable pwm output
04044 111 06 72 07 36 |     if_nc       mov     drv_state_, #DCS_FAULTED        '  also on FAULT: mark our motor as FAULTED
04048 112 0E A3 66 3C |     if_nc       wrlong  maxNeg, ptra[DRVR_STATUS_LONGS_COUNT] '  also on FAULT: report fault
0404c 113             | 
0404c 113 2A EE 96 F1 | .noFault        sub     tmpY, #256/6                wc  ' modulate duty (256 frac 6 - where 6 is # of hall cycles)
04050 114 A2 EF 12 3A |     if_nc       muls    tmpY, duty_up_
04054 115 A3 EF 12 CA |     if_c        muls    tmpY, duty_dn_
04058 116 08 EE C6 F0 |                 sar     tmpY, #8                        ' 8-bits is multiplying agressiveness of correction
0405c 117 77 6B 03 F1 |                 add     duty_, tmpY
04060 118 A1 6B 63 F3 |                 fles    duty_, duty_max_                ' keep duty within limits
04064 119 A0 6B 43 F3 |                 fges    duty_, duty_min_
04068 11a             | 
04068 11a 1A 6E 63 FD |                 getct   loop_dtcks_                     ' how long was this iteration? send to host
0406c 11b 78 6F 83 F1 |                 sub     loop_dtcks_, drvrSrtTix
04070 11c             | 
04070 11c 28 1A 64 FD |                 setq    #DRVR_STATUS_LONGS_COUNT-1      ' write drive[3]/sense[4]/hall/pos/duty/err/ticks[2]/state to hub
04074 11d 00 59 67 FC |                 wrlong  drive_u_, ptra
04078 11e 9C 23 CC FB | .loop           jnct1   #.ctlMotor                      ' if not time for drv loop just go to ctl loop
0407c 11f 9C FC 9F FD |                 jmp     #.drvMotor
04080 120             | 
04080 120             |     ' =========================================================================
04080 120             |     '  PRIVATE (Utiility) Subroutines
04080 120             |     ' -------------------------------------------------------------------------
04080 120             | 
04080 120             | .gettgtincr
04080 120 3F F7 06 FB |                 rdlong  tgt_incr, ptra[-1]              ' get rate of increment ( +/- drive power, or 0 stop)
04084 121 1F F6 16 F4 |                 testb   tgt_incr, #31               wc  ' bit 31 is used to carry sync info
04088 122 24 1C 68 CD |     if_c        pollatn                             wz  ' need to sync, but dont want to wait so if atn not ready
0408c 123 7D F7 02 46 |     if_c_and_nz mov     tgt_incr, sv_tgt_incr           ' reset tgt_incr, if wanting atn and not received it yet
04090 124 1F F6 06 84 |     if_c_and_z  bitl    tgt_incr, #31                   ' have the atn, so
04094 125 3F F7 66 8C |     if_c_and_z  wrlong  tgt_incr, ptra[-1]              ' let caller know we have taken it by clearing sync bit
04098 126 1E F6 66 07 |     _ret_       signx   tgt_incr, #30                   ' sign extend back to normal tgt_incr
0409c 127             | 
0409c 127             | .driveinit                                              ' init drive pwm
0409c 127 41 8E 62 FD |                 dirh    all_pins                        ' enable ADC and PWM pins simultaneously for phase-locked operation
040a0 128             |                                                         ' the ADC and PWM smart pins are never disabled after this.
040a0 128 40 18 63 FD |                 dirl    pin_hall_u                      ' make sure HALL pins are inputs
040a4 129 40 1A 63 FD |                 dirl    pin_hall_v
040a8 12a 40 1C 63 FD |                 dirl    pin_hall_w
040ac 12b 00 0A 07 06 |     _ret_       mov     driveoff, #0                    ' drive pwm output enabled, though checkstop is called before ctlMotor loop and may change this
040b0 12c             | 
040b0 12c             | .driveoff                                               ' disable pwm always
040b0 12c 01 0A 07 06 |     _ret_       mov     driveoff, #1                    ' drive pwm output disabled
040b4 12d             | 
040b4 12d             | .checkstopfloaton                                       ' set drive enabled according to stop mode
040b4 12d 31 8A 64 FD |                 skip    #%1000101                       ' same as inverted floatoff without drive disable
040b8 12e             | .checkstopfloatoff                                      ' set drive disabled according to stop mode
040b8 12e 31 18 64 FD |                 skip    #%001100                        ' same as checkstop without initAngleFmHall and duty reset
040bc 12f             | .checkstop                                              ' set drive disabled to correct state
040bc 12f 01 4E 0F F2 |                 cmp     stop_mode_, #SM_FLOAT       wz  ' Q: what is new stop mode, should motor be freewheeling?
040c0 130 6F 0A 6C FD |                 modz    _nz                         wz  ' invert Z, allows skipping invert by floaton
040c4 131 1C 00 B0 AD |     if_z        call    #.initAngleFmHall               ' make sure angle set correctly, so motor doesn't jerk when enters ctlMotor
040c8 132 A0 6B 03 A6 |     if_z        mov     duty_, duty_min_                ' reset duty, reduces jerk if not fully aligned
040cc 133 00 0A 07 A6 |     if_z        mov     driveoff, #0                    ' drive pwm output enabled
040d0 134 01 0A 07 56 |     if_nz       mov     driveoff, #1                    ' drive pwm output disabled
040d4 135 2D 00 64 FD |                 ret
040d8 136             | 
040d8 136             | .wait4adc
040d8 136 40 16 73 FD | .wait4adcAgn    testp   pin_adc_cur_i               wc  ' wait for ADC sample to be avail. (wtg on 4th pin set up)
040dc 137 F8 FF 9F 3D |     if_nc       jmp     #.wait4adcAgn
040e0 138 2D 00 64 FD | .noWait4adc     ret
040e4 139             | 
040e4 139             | .initAngleFmHall
040e4 139             |                 ' init angle & prior from current motor position
040e4 139 40 1C 73 FD |                 testp   pin_hall_w                  wc  ' read hall effect sensor
040e8 13a 01 66 A7 F0 |                 rcl     hall_, #1
040ec 13b 40 1A 73 FD |                 testp   pin_hall_v                  wc
040f0 13c 01 66 A7 F0 |                 rcl     hall_, #1
040f4 13d 40 18 73 FD |                 testp   pin_hall_u                  wc
040f8 13e 01 66 A7 F0 |                 rcl     hall_, #1
040fc 13f 1F F6 16 F4 |                 testb   tgt_incr, #31               wc  ' Q: moving FWD or REV? (bCY=REV)
04100 140 03 66 47 F4 |                 bitc    hall_, #3                       ' point to correct FWD/REV half of table
04104 141 0F 66 07 F5 |                 and     hall_, #%1111                   ' make sure rest of hall_ is cleared
04108 142 66 67 97 F9 |                 alts    hall_, #hall_angles
0410c 143 00 04 03 F6 |                 mov     angle_, 0-0
04110 144 9E 05 03 C1 |     if_c        add     angle_, offset_fwd_             ' adjust phase offset for hall sensor
04114 145 9F 05 03 31 |     if_nc       add     angle_, offset_rev_             ' can spin up in either direction
04118 146 82 07 03 06 |     _ret_       mov     prior_angle, angle_             ' show we are already here
0411c 147             | '
0411c 147             | ' =========================================================================
0411c 147 40 03 00 00 | all_pins        LONG    (13 << 6) + 0           ' all-pins variable (0 addpins 13) needs ADD/OR of basepin, skip last 2 pwm pins, not used
04120 148 48 01 00 00 | drive_pins      LONG    (5 << 6) + 8            ' drive-pins variable (+8 addpins 5) needs ADD of basepin, skip last 2 pwm pins, not used
04124 149 00 01 00 00 | adc_pins        LONG    (4 << 6) + 0            ' drive-pins variable (+0 addpins 4) needs ADD/OR of basepin, note total of 5 pins, adc_x not used
04128 14a 50 00 00 00 | pwmt            LONG    %000_000000_01_01000_0  ' PWM true (P_BITDAC | P_PWM_TRIANGLE | P_OE)
0412c 14b 50 40 00 00 | pwmn            LONG    %001_000000_01_01000_0  ' PWM not (P_INVERT_OUTPUT | P_BITDAC | P_PWM_TRIANGLE | P_OE)
04130 14c 00 00 00 00 | adc_fram        LONG    0                       ' set ADC to full PWM frame counts [was: LONG    FRAME]
04134 14d 00 00 00 00 | fram            LONG    0                       ' PWM frame: width=FRAME/2, div sysclk by 1 (no division) [was: LONG (FRAME / 2) << 16 + 1 ]
04138 14e 00 00 00 00 | bias            LONG    0                       ' PWM center-frame bias [was: LONG    FRAME / 4]
0413c 14f 55 55 55 55 | third           LONG    1 FRAC 3                ' 120 degrees
04140 150 00 20 67 00 | numerator       LONG    3300 << 11              ' numerator for ADC calculations, configured from init to match the adc_fram count rather than 1 << 11
04144 151 FF FF FF FF | maxNeg          LONG    $FFFF_FFFF              ' 32-bits of one (max negative signed value)
04148 152 00 00 00 00 | sync_required   LONG    0                       ' non zero if motor loop should wait to start
0414c 153             | 
0414c 153             |     ' -----------------------------------
0414c 153             |     ' Logic Analyzer Instrumentation Code
0414c 153             |     ' -----------------------------------
0414c 153             | {
0414c 153             | '}
0414c 153             | 
0414c 153 1E 00 10 00 | adc_modes       LONG    p_adc_gio | p_count_highs  ' +0 : adc modes, by state
04150 154 1E 80 10 00 |                 LONG    p_adc_vio | p_count_highs  ' +1
04154 155 1E 80 11 00 |                 LONG    p_adc_1x | p_count_highs   ' +2
04158 156             | 
04158 156             | ' turn motor to view hall sequence ...  learn in known direction
04158 156             | '   efficient: low current draw at given speed
04158 156             | 
04158 156             | ' max frequency is this...
04158 156             | ' max ramp rate is this...
04158 156             | 
04158 156             | ' old bit shift up by 3 then new bits
04158 156             | '   old is outer index
04158 156             | '   new is inner index
04158 156 00 00 00 00 
0415c 157 00 00 00 00 | deltas          BYTE    0,  0,  0,  0,  0,  0,  0,  0  ' Hall-effect-sensor position deltas from (old<<3 | new)
04160 158 00 00 00 FF 
04164 159 00 01 00 00 |                 BYTE    0,  0,  0, -1,  0,  1,  0,  0
04168 15a 00 00 00 01 
0416c 15b 00 00 FF 00 |                 BYTE    0,  0,  0,  1,  0,  0, -1,  0
04170 15c 00 01 FF 00 
04174 15d 00 00 00 00 |                 BYTE    0,  1, -1,  0,  0,  0,  0,  0
04178 15e 00 00 00 00 
0417c 15f 00 FF 01 00 |                 BYTE    0,  0,  0,  0,  0, -1,  1,  0
04180 160 00 FF 00 00 
04184 161 01 00 00 00 |                 BYTE    0, -1,  0,  0,  1,  0,  0,  0
04188 162 00 00 01 00 
0418c 163 FF 00 00 00 |                 BYTE    0,  0,  1,  0, -1,  0,  0,  0
04190 164 00 00 00 00 
04194 165 00 00 00 00 |                 BYTE    0,  0,  0,  0,  0,  0,  0,  0
04198 166             | 
04198 166             | ' 32bit angles
04198 166             | '  6.5" wheel
04198 166             | '    1 wheel revolution is 360 degrees
04198 166             | '   90 tics per 360 degrees
04198 166             | '    1 tic is 4 degrees
04198 166             | '    6 tics per tic-cycle
04198 166             | '   15 tic-cycles per 360 degrees
04198 166             | '   30 pole motor
04198 166             | '    1 tic-cycle is 24 degrees
04198 166             | '
04198 166             | '  docoEng.com 4k RPM 24v motor
04198 166             | '    1 shaft revolution is 360 degrees
04198 166             | '   24 tics per 360 degrees
04198 166             | '    1 tic is 15 degrees
04198 166             | '    6 tics per tic-cycle
04198 166             | '    4 tic-cycles per 360 degrees
04198 166             | '    8 pole motor
04198 166             | '    1 tic-cycle is 90 degrees
04198 166             | '
04198 166             | '   amount of rotation within hall cycle - 6.5" wheel
04198 166 00 00 00 00 | hall_angles     LONG    0           '-%000- can't happen forward-direction table
0419c 167 00 00 00 00 |                 LONG    0 frac 6    '%001
041a0 168 AA AA AA AA |                 LONG    4 frac 6    '%010
041a4 169 55 55 55 D5 |                 LONG    5 frac 6    '%011
041a8 16a 55 55 55 55 |                 LONG    2 frac 6    '%100
041ac 16b AA AA AA 2A |                 LONG    1 frac 6    '%101
041b0 16c 00 00 00 80 |                 LONG    3 frac 6    '%110
041b4 16d 00 00 00 00 |                 LONG    0           '-%111- can't happen
041b8 16e             | 
041b8 16e 00 00 00 00 |                 LONG    0           '-%000- can't happen - reverse-direction table
041bc 16f 55 55 55 D5 |                 LONG    5 frac 6    '%001
041c0 170 00 00 00 80 |                 LONG    3 frac 6    '%010
041c4 171 AA AA AA AA |                 LONG    4 frac 6    '%011
041c8 172 AA AA AA 2A |                 LONG    1 frac 6    '%100
041cc 173 00 00 00 00 |                 LONG    0 frac 6    '%101
041d0 174 55 55 55 55 |                 LONG    2 frac 6    '%110
041d4 175 00 00 00 00 |                 LONG    0           '-%111- can't happen
041d8 176             | 
041d8 176             | tmpX            res 1       ' miscellaneous
041d8 176             | tmpY            res 1
041d8 176             | ' measurements
041d8 176             | drvrSrtTix      res 1
041d8 176             | ctrlSrtTix      res 1
041d8 176             | ctrlEndTix      res 1
041d8 176             | ' driver inputs
041d8 176             | tgt_incr        res 1       ' current user requested target increment
041d8 176             | prior_incr      res 1       ' prior user requested target increment
041d8 176             | sv_tgt_incr     res 1       ' holding area for prior value
041d8 176             | ' control loop variables
041d8 176             | drv_incr        res 1       ' current driver increment
041d8 176             | ' ramp up rate, down is always fast
041d8 176             | curr_ramp       res 1       ' ramp to add/sub from drv_incr
041d8 176             | final_ramp      res 1       ' from current to target
041d8 176             | ramp_curr       res 1       ' current ramping up value, ramps up from ramp_min_ to ramp_max_
041d8 176             | 
041d8 176             | ' driver actual
041d8 176             | angle_          res 1       ' current driver angle
041d8 176             | prior_angle     res 1       ' prior driver angle
041d8 176             | fwdrev          res 1       ' driver current direction used for indexing into hall angle table
041d8 176             | driveoff        res 1       ' pwm enabled (0) or disabled (1)
041d8 176             | curr_stop       res 1       ' current stop mode
041d8 176             | ' debug variables
041d8 176             | {
041d8 176             | '}
041d8 176             | 
041d8 176             | ' temp hold areas
041d8 176             | ' used when tracking down PWM drive problem...
041d8 176             | 'driveUsav_      res 1       ' unmodified value from cordic math
041d8 176             | 
041d8 176             | ' PIN names -  single-pin variables, 14 pins, pwm x is not used
041d8 176             | pin_adc_u_i     res 1       ' basepin + 0
041d8 176             | pin_adc_v_i     res 1       ' basepin + 1
041d8 176             | pin_adc_w_i     res 1       ' basepin + 2
041d8 176             | pin_adc_x_i     res 1       ' basepin + 3
041d8 176             | pin_adc_cur_i   res 1       ' basepin + 4
041d8 176             | pin_hall_u      res 1       ' basepin + 5
041d8 176             | pin_hall_v      res 1       ' basepin + 6
041d8 176             | pin_hall_w      res 1       ' basepin + 7
041d8 176             | pin_pwm_u_l     res 1       ' basepin + 8
041d8 176             | pin_pwm_u_h     res 1       ' basepin + 9
041d8 176             | pin_pwm_v_l     res 1       ' basepin + 10
041d8 176             | pin_pwm_v_h     res 1       ' basepin + 11
041d8 176             | pin_pwm_w_l     res 1       ' basepin + 12
041d8 176             | pin_pwm_w_h     res 1       ' basepin + 13
041d8 176             | 
041d8 176             | '  ADC variables
041d8 176             | gio_levels      res 4
041d8 176             | vio_levels                      ' vio and scl are never used at the same time, so overlap
041d8 176             | scl_levels      res 4
041d8 176             | ' ------------------------------
041d8 176             | '  PRECISE FORMAT:
041d8 176             | '   copied in-to driver each loop iteration
041d8 176             | params_ptr_ res 1           ' params_ptr must be followed by:
041d8 176             | offset_fwd_ res 1           '  14 (DRVR_PARAMS_LONGS_COUNT) parameters
041d8 176             | offset_rev_ res 1
041d8 176             | duty_min_   res 1           ' minimum duty cycle for pwm
041d8 176             | duty_max_   res 1           ' maximum duty cycle for pwm
041d8 176             | duty_up_    res 1           ' up rate for duty cycle for pwm
041d8 176             | duty_dn_    res 1           ' down rate for duty cycle for pwm
041d8 176             | dead_gap_   res 1           ' gap between driving high and low side pwm
041d8 176             | ramp_down_  res 1           ' angle decrement when slowing down
041d8 176             | cfg_ctcks_  res 1           ' clocks for drv loop
041d8 176             | stop_mode_  res 1           ' float or brake mode
041d8 176             | e_stop_     res 1           ' T/F where T means stopal motor function
041d8 176             | ramp_max_   res 1           ' angle increment: max rap up every 500 uSec
041d8 176             | ramp_min_   res 1           ' angle increment: start of ramp up every 500 uSec
041d8 176             | ramp_inc_   res 1           ' angle increment: inc every 500uSec from min to max
041d8 176             | 
041d8 176             | ' ------------------------------
041d8 176             | '  PRECISE FORMAT:
041d8 176             | '   copied out-of driver each loop iteration
041d8 176             | drive_u_    res 1           ' 14 (DRVR_STATUS_LONGS_COUNT) contiguous longs for return data structure
041d8 176             | drive_v_    res 1
041d8 176             | drive_w_    res 1
041d8 176             | sense_u_    res 1
041d8 176             | sense_v_    res 1
041d8 176             | sense_w_    res 1
041d8 176             | sense_i_    res 1
041d8 176             | hall_       res 1
041d8 176             | pos_        res 1
041d8 176             | duty_       res 1
041d8 176             | err_        res 1
041d8 176             | loop_dtcks_ res 1
041d8 176             | loop_ctcks_ res 1
041d8 176             | drv_state_  res 1           ' enum: DCS_STOPPED, DCS_SPIN_UP, DCS_AT_SPEED, DCS_SPIN_DN, etc
041d8 176             | ' fault is here... (but external only)
041d8 176             | 
041d8 176             | ' $1f8 for reg cogs
041d8 176             |     fit     496  ' 443 currently works
041d8 176 00 00 00 00 
041dc 177 08 00 00 00 
041e0 178 10 00 00 00 
041e4 179 20 00 00 00 |     fit     496  ' 443 currently works
041e8 17a 28 00 00 00 
041ec 17b 02 00 00 00 
041f0 17c 03 00 00 00 
041f4 17d 04 00 00 00 | 	byte	$28, $00, $00, $00, $02, $00, $00, $00, $03, $00, $00, $00, $04, $00, $00, $00
041f8 17e 05 00 00 00 
041fc 17f 06 00 00 00 
04200 180 07 00 00 00 
04204 181 08 00 00 00 | 	byte	$05, $00, $00, $00, $06, $00, $00, $00, $07, $00, $00, $00, $08, $00, $00, $00
04208 182 01 00 00 00 
0420c 183 02 00 00 00 
04210 184 03 00 00 00 
04214 185 04 00 00 00 | 	byte	$01, $00, $00, $00, $02, $00, $00, $00, $03, $00, $00, $00, $04, $00, $00, $00
04218 186 05 00 00 00 
0421c 187 06 00 00 00 
04220 188 07 00 00 00 
04224 189 08 00 00 00 | 	byte	$05, $00, $00, $00, $06, $00, $00, $00, $07, $00, $00, $00, $08, $00, $00, $00
04228 18a 09 00 00 00 
0422c 18b 00 00 00 00 
04230 18c 01 00 00 00 
04234 18d 1E 00 00 00 | 	byte	$09, $00, $00, $00, $00, $00, $00, $00, $01, $00, $00, $00, $1e, $00, $00, $00
04238 18e 1F 00 00 00 
0423c 18f 20 00 00 00 
04240 190 02 00 00 00 
04244 191 03 00 00 00 | 	byte	$1f, $00, $00, $00, $20, $00, $00, $00, $02, $00, $00, $00, $03, $00, $00, $00
04248 192 04 00 00 00 
0424c 193 05 00 00 00 
04250 194 06 00 00 00 
04254 195 07 00 00 00 | 	byte	$04, $00, $00, $00, $05, $00, $00, $00, $06, $00, $00, $00, $07, $00, $00, $00
04258 196 08 00 00 00 
0425c 197 21 00 00 00 
04260 198 21 00 00 00 
04264 199 27 00 00 00 | 	byte	$08, $00, $00, $00, $21, $00, $00, $00, $21, $00, $00, $00, $27, $00, $00, $00
04268 19a 28 00 00 00 
0426c 19b 24 00 00 00 
04270 19c 25 00 00 00 
04274 19d 2D 00 00 00 | 	byte	$28, $00, $00, $00, $24, $00, $00, $00, $25, $00, $00, $00, $2d, $00, $00, $00
04278 19e 34 00 00 00 
0427c 19f 35 00 00 00 
04280 1a0 35 00 00 00 
04284 1a1 35 00 00 00 | 	byte	$34, $00, $00, $00, $35, $00, $00, $00, $35, $00, $00, $00, $35, $00, $00, $00
04288 1a2 36 00 00 00 
0428c 1a3 36 00 00 00 
04290 1a4 35 00 00 00 
04294 1a5 02 00 00 00 | 	byte	$36, $00, $00, $00, $36, $00, $00, $00, $35, $00, $00, $00, $02, $00, $00, $00
04298 1a6 03 00 00 00 
0429c 1a7 04 00 00 00 
042a0 1a8 05 00 00 00 
042a4 1a9 06 00 00 00 | 	byte	$03, $00, $00, $00, $04, $00, $00, $00, $05, $00, $00, $00, $06, $00, $00, $00
042a8 1aa 07 00 00 00 
042ac 1ab 08 00 00 00 
042b0 1ac C0 5D 0D E9 
042b4 1ad 20 19 DD EE | 	byte	$07, $00, $00, $00, $08, $00, $00, $00, $c0, $5d, $0d, $e9, $20, $19, $dd, $ee
042b8 1ae C0 7C 17 E3 
042bc 1af 00 97 DF E8 
042c0 1b0 A0 2C 35 E5 
042c4 1b1 00 4F F7 E6 | 	byte	$c0, $7c, $17, $e3, $00, $97, $df, $e8, $a0, $2c, $35, $e5, $00, $4f, $f7, $e6
042c8 1b2 00 F5 94 E4 
042cc 1b3 40 A2 F2 16 
042d0 1b4 E0 E6 22 11 
042d4 1b5 40 83 E8 1C | 	byte	$00, $f5, $94, $e4, $40, $a2, $f2, $16, $e0, $e6, $22, $11, $40, $83, $e8, $1c
042d8 1b6 00 69 20 17 
042dc 1b7 60 D3 CA 1A 
042e0 1b8 00 B1 08 19 
042e4 1b9 00 0B 6B 1B | 	byte	$00, $69, $20, $17, $60, $d3, $ca, $1a, $00, $b1, $08, $19, $00, $0b, $6b, $1b
042e8 1ba 80 05 31 EF 
042ec 1bb C0 F5 83 DF 
042f0 1bc 40 4E 08 EC 
042f4 1bd 00 B2 96 E9 | 	byte	$80, $05, $31, $ef, $c0, $f5, $83, $df, $40, $4e, $08, $ec, $00, $b2, $96, $e9
042f8 1be 80 00 47 E8 
042fc 1bf 80 5E FC E3 
04300 1c0 40 D0 B1 E8 
04304 1c1 80 FA CE 10 | 	byte	$80, $00, $47, $e8, $80, $5e, $fc, $e3, $40, $d0, $b1, $e8, $80, $fa, $ce, $10
04308 1c2 40 0A 7C 20 
0430c 1c3 C0 B1 F7 13 
04310 1c4 00 4E 69 16 
04314 1c5 80 FF B8 17 | 	byte	$40, $0a, $7c, $20, $c0, $b1, $f7, $13, $00, $4e, $69, $16, $80, $ff, $b8, $17
04318 1c6 80 A1 03 1C 
0431c 1c7 C0 2F 4E 17 
04320 1c8 01 00 00 00 
04324 1c9 02 00 00 00 | 	byte	$80, $a1, $03, $1c, $c0, $2f, $4e, $17, $01, $00, $00, $00, $02, $00, $00, $00
04328 1ca 03 00 00 00 
0432c 1cb 04 00 00 00 
04330 1cc 05 00 00 00 
04334 1cd 06 00 00 00 | 	byte	$03, $00, $00, $00, $04, $00, $00, $00, $05, $00, $00, $00, $06, $00, $00, $00
04338 1ce 07 00 00 00 
0433c 1cf 08 00 00 00 
04340 1d0 80 4A 5D 05 
04344 1d1 80 4A 5D 05 | 	byte	$07, $00, $00, $00, $08, $00, $00, $00, $80, $4a, $5d, $05, $80, $4a, $5d, $05
04348 1d2 80 4A 5D 05 
0434c 1d3 40 1A C8 05 
04350 1d4 00 0E 27 07 
04354 1d5 C0 0A C3 08 | 	byte	$80, $4a, $5d, $05, $40, $1a, $c8, $05, $00, $0e, $27, $07, $c0, $0a, $c3, $08
04358 1d6 00 83 40 0A 
0435c 1d7 00 83 40 0A 
04360 1d8 80 B5 A2 FA 
04364 1d9 80 B5 A2 FA | 	byte	$00, $83, $40, $0a, $00, $83, $40, $0a, $80, $b5, $a2, $fa, $80, $b5, $a2, $fa
04368 1da 80 B5 A2 FA 
0436c 1db C0 E5 37 FA 
04370 1dc 00 F2 D8 F8 
04374 1dd 40 F5 3C F7 | 	byte	$80, $b5, $a2, $fa, $c0, $e5, $37, $fa, $00, $f2, $d8, $f8, $40, $f5, $3c, $f7
04378 1de 00 7D BF F5 
0437c 1df 00 7D BF F5 
04380 1e0 01 00 00 00 
04384 1e1 02 00 00 00 | 	byte	$00, $7d, $bf, $f5, $00, $7d, $bf, $f5, $01, $00, $00, $00, $02, $00, $00, $00
04388 1e2 03 00 00 00 
0438c 1e3 04 00 00 00 
04390 1e4 05 00 00 00 
04394 1e5 06 00 00 00 | 	byte	$03, $00, $00, $00, $04, $00, $00, $00, $05, $00, $00, $00, $06, $00, $00, $00
04398 1e6 07 00 00 00 
0439c 1e7 08 00 00 00 
043a0 1e8 09 00 00 00 
043a4 1e9 00 00 C0 40 | 	byte	$07, $00, $00, $00, $08, $00, $00, $00, $09, $00, $00, $00, $00, $00, $c0, $40
043a8 1ea CD CC EC 40 
043ac 1eb 9A 99 31 41 
043b0 1ec 00 00 40 41 
043b4 1ed CD CC 6C 41 | 	byte	$cd, $cc, $ec, $40, $9a, $99, $31, $41, $00, $00, $40, $41, $cd, $cc, $6c, $41
043b8 1ee 00 00 94 41 
043bc 1ef 9A 99 B1 41 
043c0 1f0 00 00 C0 41 
043c4 1f1 33 33 CF 41 | 	byte	$00, $00, $94, $41, $9a, $99, $b1, $41, $00, $00, $c0, $41, $33, $33, $cf, $41
043c8 1f2             | 	alignl
043c8 1f2             | __system__dat_
043c8 1f2 00 00 00 00 
043cc 1f3 00 00 00 00 | 	byte	$00[8]
043d0 1f4 03 00 00 00 
043d4 1f5 00 00 00 00 
043d8 1f6 00 00 00 00 
043dc 1f7 00 00 00 00 | 	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
043e0 1f8 00 00 00 00 
043e4 1f9 00 00 00 00 | 	byte	$00, $00, $00, $00, $00, $00, $00, $00
043e8 1fa             | objmem
043e8 1fa 00 00 00 00 | 	long	0[1]
043ec 178             | 	org	COG_BSS_START
043ec 178             | _var01
043ec 178             | 	res	1
043ec 179             | _var02
043ec 179             | 	res	1
043ec 17a             | _var03
043ec 17a             | 	res	1
043ec 17b             | arg01
043ec 17b             | 	res	1
043ec 17c             | arg02
043ec 17c             | 	res	1
043ec 17d             | arg03
043ec 17d             | 	res	1
043ec 17e             | arg04
043ec 17e             | 	res	1
043ec 17f             | arg05
043ec 17f             | 	res	1
043ec 180             | local01
043ec 180             | 	res	1
043ec 181             | local02
043ec 181             | 	res	1
043ec 182             | local03
043ec 182             | 	res	1
043ec 183             | local04
043ec 183             | 	res	1
043ec 184             | local05
043ec 184             | 	res	1
043ec 185             | local06
043ec 185             | 	res	1
043ec 186             | local07
043ec 186             | 	res	1
043ec 187             | local08
043ec 187             | 	res	1
043ec 188             | local09
043ec 188             | 	res	1
043ec 189             | local10
043ec 189             | 	res	1
043ec 18a             | local11
043ec 18a             | 	res	1
043ec 18b             | local12
043ec 18b             | 	res	1
043ec 18c             | local13
043ec 18c             | 	res	1
043ec 18d             | local14
043ec 18d             | 	res	1
043ec 18e             | local15
043ec 18e             | 	res	1
043ec 18f             | local16
043ec 18f             | 	res	1
043ec 190             | local17
043ec 190             | 	res	1
043ec 191             | local18
043ec 191             | 	res	1
043ec 192             | local19
043ec 192             | 	res	1
043ec 193             | local20
043ec 193             | 	res	1
043ec 194             | local21
043ec 194             | 	res	1
043ec 195             | local22
043ec 195             | 	res	1
043ec 196             | local23
043ec 196             | 	res	1
043ec 197             | local24
043ec 197             | 	res	1
043ec 198             | local25
043ec 198             | 	res	1
043ec 199             | local26
043ec 199             | 	res	1
043ec 19a             | local27
043ec 19a             | 	res	1
043ec 19b             | muldiva_
043ec 19b             | 	res	1
043ec 19c             | muldivb_
043ec 19c             | 	res	1
043ec 19d             | 	fit	480
043ec 19d             | 
